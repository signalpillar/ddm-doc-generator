#=(clojure.lang.PersistentArrayMap/create {:class-by-name {"db2_location" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a remote DB2 location", :display-name "Db2Location", :class-name "db2_location"}), "buffer" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the buffer in a network device that queues up packets.", :display-name "Buffer", :class-name "buffer"}), "infrastructure_element" #=(clojure.lang.PersistentArrayMap/create {:description "Infrastructure Element CI Types.", :display-name "InfrastructureElement", :class-name "infrastructure_element"}), "synch_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "synch_info", :class-name "synch_info"}), "time_entry" #=(clojure.lang.PersistentArrayMap/create {:description "TimeEntry contains information about time spent on specific work. It can be viewed as a unit of entry in a time card.", :display-name "TimeEntry", :class-name "time_entry"}), "dbschedulerjob" #=(clojure.lang.PersistentArrayMap/create {:description "A scheduler job is a specified series of operations performed sequentially by the database manager.", :display-name "DB Scheduler Job", :class-name "dbschedulerjob"}), "sshprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "SSH Protocol", :display-name "SSH Protocol", :class-name "sshprotocol"}), "firewall" #=(clojure.lang.PersistentArrayMap/create {:display-name "Firewall", :class-name "firewall"}), "mqqueuemanager" #=(clojure.lang.PersistentArrayMap/create {:description "A WebSphere MQ instance may have one or more queue managers. The queue manager is responsible for functions not directly related to data movement such as storage, timing, triggering, etc. Queue Managers use a proprietary IBM technology known as a \"bindings\" connection to communicate with MQ objects it manages and with remote clients via a network  Key Attributes: 1. Name (data_name) - The name of the MQ Queue Manager 2. Container (root_container) - The container IBM WebSphere MQ Software Element", :display-name "IBM MQ Queue Manager", :class-name "mqqueuemanager"}), "fcmdb_conf_composition" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_conf_composition", :class-name "fcmdb_conf_composition"}), "jdbcdatasource" #=(clojure.lang.PersistentArrayMap/create {:description "Represents JDBC connector to data source. JDBC Data Source provides database connectivity through a pool of JDBC connections", :display-name "JDBC Data Source", :class-name "jdbcdatasource"}), "paramdefinition" #=(clojure.lang.PersistentArrayMap/create {:description "Defines a parameter for Action in MAM event system", :display-name "paramdefinition", :class-name "paramdefinition"}), "deployedPackage" #=(clojure.lang.PersistentArrayMap/create {:description "MAM's packages", :display-name "MAM package", :class-name "deployedPackage"}), "actionrepository" #=(clojure.lang.PersistentArrayMap/create {:display-name "actionrepository", :class-name "actionrepository"}), "logicalvolume_snapshot" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a snapshot of a logical volume", :display-name "Logical Volume Snapshot", :class-name "logicalvolume_snapshot"}), "iis_smtp_server" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of IIS SMTP Server", :display-name "IIS SMTP Server", :class-name "iis_smtp_server"}), "webmodule" #=(clojure.lang.PersistentArrayMap/create {:description "j2ee deployed object", :display-name "Web Module", :class-name "webmodule"}), "logfile" #=(clojure.lang.PersistentArrayMap/create {:description "Requested information which is kept in file.", :display-name "Log File", :class-name "logfile"}), "storagefabric" #=(clojure.lang.PersistentArrayMap/create {:display-name "Storage Fabric", :class-name "storagefabric"}), "httpprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "HTTP Protocol", :display-name "HTTP Protocol", :class-name "httpprotocol"}), "edgeserver" #=(clojure.lang.PersistentArrayMap/create {:description "Edge Server enables your users to communicate and collaborate with users outside the organization's firewalls. These external users can include the organization's own users who are currently working offsite, users from federated partner organizations, and outside users who have been invited to join conferences hosted on your Lync Server deployment. Edge Server also enables connectivity to public IM connectivity services, including Windows Live, AOL, and Yahoo.", :display-name "Edge Server", :class-name "edgeserver"}), "domaincontroller" #=(clojure.lang.PersistentArrayMap/create {:description "A domain controller is a directory server that physically store the Active Directory information. All domain controllers that belong to the same domain replicate information to each other. A domain controller which is defined as a global catalog server replicate and stores objects from all the domains that belong to the forest.", :display-name "DomainController", :class-name "domaincontroller"}), "underpinning_contract" #=(clojure.lang.PersistentArrayMap/create {:description "A Contract between an IT Service Provider and a Third Party. The Third Party provides goods or Services that support delivery of an IT Service to a Customer. The Underpinning Contract defines targets and responsibilities that are required to meet agreed Service Level Targets in an SLA.", :display-name "UnderpinningContract", :class-name "underpinning_contract"}), "discoverypattern" #=(clojure.lang.PersistentArrayMap/create {:description "Auto discovery entity that defines a discovery procedure", :display-name "Auto Discovery Pattern definition", :class-name "discoverypattern"}), "license" #=(clojure.lang.PersistentArrayMap/create {:description "License contains information about a license to use certain entities like software etc, and has associated with it the contract that governs such usage. Licenses are Assets and are reconciled using the unique AssetTag that they have by virtue of being an Asset.", :display-name "License", :class-name "license"}), "iisresource" #=(clojure.lang.PersistentArrayMap/create {:description "Base class for IIS resources", :display-name "IIS Resource", :class-name "iisresource"}), "jvm" #=(clojure.lang.PersistentArrayMap/create {:description "Key Attributes:  1. Name (data_name) - JVM  2. Container (root_container) - The container Software Element", :display-name "JVM", :class-name "jvm"}), "webservice" #=(clojure.lang.PersistentArrayMap/create {:description "Represent a web service", :display-name "Web Service", :class-name "webservice"}), "license_server" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the License Server software", :display-name "License Server", :class-name "license_server"}), "output" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system action/job output", :display-name "output", :class-name "output"}), "memory" #=(clojure.lang.PersistentArrayMap/create {:description "Random access memory (RAM).", :display-name "Memory", :class-name "memory"}), "sap_j2ee_dispatcher" #=(clojure.lang.PersistentArrayMap/create {:description "Receives the client request and forwards it to the server process with the lowest capacity usage.", :display-name "SAP J2EE Dispatcher", :class-name "sap_j2ee_dispatcher"}), "usage" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system Relationships", :display-name "Usage", :class-name "usage"}), "period" #=(clojure.lang.PersistentArrayMap/create {:description "A period represents a period of time. Items such as IT Financial or process metrics that are attached to a period mean that their values are measured for that period.The length of the time period is defined by its periodicity attribute.Periods of greater duration can be made up of smaller duration periods - such as a Quarter containing three months.If data is attached to the child period, that means its data happened during the parent period as well.", :display-name "Period", :class-name "period"}), "sap_transaction" #=(clojure.lang.PersistentArrayMap/create {:description "A business process defined in the SAP System", :display-name "SAP Transaction", :class-name "sap_transaction"}), "file_system_export" #=(clojure.lang.PersistentArrayMap/create {:description "A file system that is exported by a node for mounting by another node using a protocol such as NFS or SMB", :display-name "FileSystemExport", :class-name "file_system_export"}), "siebelgtwyprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "A Siebel gateway protocol", :display-name "Siebel Gateway Protocol", :class-name "siebelgtwyprotocol"}), "ntadminprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "NT-CMD Protocol", :display-name "NTCMD Protocol", :class-name "ntadminprotocol"}), "unnumbered" #=(clojure.lang.PersistentArrayMap/create {:description "The unnumbered links are links discovered by the base collector. this link represents a row data from the route table in the mib containing the data of the next_hop ip address and the destination network address. This link is only created when the route table is missing the Source IP Address from which the route takes place. The route table is in the mib address :  table is in the mib address : 1.3.6.1.2.1.4.21.1.7", :display-name "Unnumbered", :class-name "unnumbered"}), "solaris_zone_config" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Solaris Zone resource configuration which holds configuration information about the related Non-global Zone, such as zone path, memory and CPU configuration etc.", :display-name "Solaris Zone Config", :class-name "solaris_zone_config"}), "vmware_vcloud_director" #=(clojure.lang.PersistentArrayMap/create {:description "VMware vCloud Director application", :display-name "VMware vCloud Director", :class-name "vmware_vcloud_director"}), "tcp" #=(clojure.lang.PersistentArrayMap/create {:description "the tcp links are links discovered by the discover tcp connection collector. this link represent a row data from the tcpConnLocalAddress table in the mib containing the data of the tcp connections between two hosts ports whene two ports are unknown         (cant tell service from client).                                     the tcpConnLocalAddress  table is in the mib address : 1.3.6.1.2.1.6.13.1.2", :display-name "TCP", :class-name "tcp"}), "iisservice" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Service", :display-name "IIS Service", :class-name "iisservice"}), "lync" #=(clojure.lang.PersistentArrayMap/create {:description "This is an abstract CIT which represents all the Microsoft Lync Server System elements. In this case this is the parent of Lync Site CIT and Lync Pool  CIT.", :display-name "Lync", :class-name "lync"}), "dbsnapshot" #=(clojure.lang.PersistentArrayMap/create {:description "Backup that can be can be created for an entire database or individual files.", :display-name "DB Snapshot", :class-name "dbsnapshot"}), "survey_result" #=(clojure.lang.PersistentArrayMap/create {:description "Survey holds the result of a survey as it applies to the members of an organization or customer related to an ItProcessRecord for a specific survey. If it pertains to ItProcessRecord then the SurveyType must be customer_satisfaction, and it must not have the EmployeeType attribute.", :display-name "SurveyResult", :class-name "survey_result"}), "mysql" #=(clojure.lang.PersistentArrayMap/create {:description "MySQL database", :display-name "MySQL", :class-name "mysql"}), "operational_level_agreement" #=(clojure.lang.PersistentArrayMap/create {:description "An Agreement between an IT Service Provider and another part of the same Organization. For example there could be an OLA: between the IT Service Provider and a procurement department to obtain hardware in agreed times, between the Service Desk and a Support Group to provide Incident Resolution in agreed times.", :display-name "OperationalLevelAgreement", :class-name "operational_level_agreement"}), "root" #=(clojure.lang.PersistentArrayMap/create {:display-name "Root", :class-name "root"}), "chassiselanmap" #=(clojure.lang.PersistentArrayMap/create {:display-name "Chassis LAN Map", :class-name "chassiselanmap"}), "maxdb" #=(clojure.lang.PersistentArrayMap/create {:description "MaxDb\\SapDb database from SAP", :display-name "MaxDB", :class-name "maxdb"}), "archivingserver" #=(clojure.lang.PersistentArrayMap/create {:description "Archiving Server enables you to archive IM communications and meeting content for compliance reasons. If you do not have legal compliance concerns, you do not need to deploy Archiving Server.", :display-name "Archiving Server", :class-name "archivingserver"}), "schedulerjob" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM scheduler job", :display-name "schedulerjob", :class-name "schedulerjob"}), "weblogicprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "WebLogic Protocol", :display-name "WebLogic Protocol", :class-name "weblogicprotocol"}), "hacmpappresource" #=(clojure.lang.PersistentArrayMap/create {:description "This represents an application that can sucessfully be restarted in HACMP after unexpected shutdown. THis applications is highly available by a HACMP Cluster.", :display-name "HACMP Application Resource", :class-name "hacmpappresource"}), "node" #=(clojure.lang.PersistentArrayMap/create {:description "The Node class represents a general purpose machine (i.e., computer). This also is a base class from which all the other classes representing devices such as virtual machines will inherit.  Machines are typically reachable via the network but there are times when users model a machine even when it is not reachable via the network.  Examples of machines include UNIX/Windows systems, switches, routers, firewalls etc.", :display-name "Node", :class-name "node"}), "memory_unit" #=(clojure.lang.PersistentArrayMap/create {:description "This is the internal memory component reported by a network device.  Depending on device types, the type of memory getting reported will vary.", :display-name "MemoryUnit", :class-name "memory_unit"}), "vmware_resource_pool" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Resource Pool represents a pool where Virtual machines execute in, and draw their resources from", :display-name "VMware Resource Pool", :class-name "vmware_resource_pool"}), "sgresource" #=(clojure.lang.PersistentArrayMap/create {:description "SG Resource  Key Attributes:  1. Name (data_name) - Name of SG resource  2. Container (root_container) - Parent SG package ", :display-name "SG Resource", :class-name "sgresource"}), "aggregation" #=(clojure.lang.PersistentArrayMap/create {:display-name "Aggregation", :class-name "aggregation"}), "ibm_resource_pool" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the IBM CPU Pool.", :display-name "IBM Processor Pool", :class-name "ibm_resource_pool"}), "oracle_schema" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Oracle Schema", :class-name "oracle_schema"}), "telnet" #=(clojure.lang.PersistentArrayMap/create {:description "telnet", :display-name "Telnet", :class-name "telnet"}), "iseries_outqueue" #=(clojure.lang.PersistentArrayMap/create {:description "This Class represents a Output Queue on the Iseries Node", :display-name "IseriesOutputQueue", :class-name "iseries_outqueue"}), "as400" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents the AS400 agent object", :display-name "AS400Agent", :class-name "as400"}), "sap_transport_change" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Transport Change", :display-name "SAP Transport Change", :class-name "sap_transport_change"}), "management" #=(clojure.lang.PersistentArrayMap/create {:display-name "Management", :class-name "management"}), "vcloud_system_organization" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud System Organization", :display-name "vCloud System Organization", :class-name "vcloud_system_organization"}), "attachment" #=(clojure.lang.PersistentArrayMap/create {:description "A binary or text file that may be associated with another entity (e.g. ItProcessRecord) as reference or to provide additional details, instructions, etc.", :display-name "Attachment", :class-name "attachment"}), "ipunknown" #=(clojure.lang.PersistentArrayMap/create {:description "Unknown port (tcp/udp)", :display-name "IP Unknown", :class-name "ipunknown"}), "functional_group" #=(clojure.lang.PersistentArrayMap/create {:description "A group of Persons that have the same responsibilities or job functions, but do not necessarily belong to the same department or organization.  An Assignment Group is an example of a Functional Group.", :display-name "FunctionalGroup", :class-name "functional_group"}), "vlan" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents one instance of a Local Area Network logical broadcast domain set up across LAN switches.  This logical domain is also called a virtual LAN or Vlan in short.  Vlans provide some level of traffic isolation.  Switches in a Vlan will forward frames over ports in the same vlan.  There could be many Vlans that exist in a physical LAN with interconnected LAN switches.", :display-name "Vlan", :class-name "vlan"}), "exchangeedgeserver" #=(clojure.lang.PersistentArrayMap/create {:description "The Edge Transport role is installed on the edge of the network and therefore is installed on a standalone server that is not a member of the Active Directory domain. Active Directory Application Mode (ADAM) is used to sync AD with the Edge Transport server. ADAM and a component called EdgeSync are used to perform scheduled one-way synchronization of the configuration and recipient information from Active Directory. This allows the Edge Transport to perform recipient lookups and Spam filtering.", :display-name "Exchange Edge Server", :class-name "exchangeedgeserver"}), "exchange" #=(clojure.lang.PersistentArrayMap/create {:description "This abstract class is parent for the following CIT's:  - Administrative group  - Exchange organization  - Routing group  ", :display-name "Exchange", :class-name "exchange"}), "msmqmanager" #=(clojure.lang.PersistentArrayMap/create {:description "Microsoft Message Queue Mannager", :display-name "MSMQ Manager", :class-name "msmqmanager"}), "mapgroup" #=(clojure.lang.PersistentArrayMap/create {:description "map group node", :display-name "map group", :class-name "mapgroup"}), "vmware_esx_server" #=(clojure.lang.PersistentArrayMap/create {:description "VMware ESX Server is a computer that uses virtualization software, such as ESX Server 3.5 or ESX Server 3i, to run virtual machines. ESX Hosts provide CPU and memory resources, access to storage, and network connectivity to virtual machines that reside on them", :display-name "VMware ESX Server", :class-name "vmware_esx_server"}), "userfilter" #=(clojure.lang.PersistentArrayMap/create {:display-name "userfilter", :class-name "userfilter"}), "schemamaster" #=(clojure.lang.PersistentArrayMap/create {:description "The schema master domain controller controls all updates and modifications to the schema.", :display-name "SchemaMaster", :class-name "schemamaster"}), "powershellprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Powershell protocol", :display-name "Powershell Protocol", :class-name "powershellprotocol"}), "ras" #=(clojure.lang.PersistentArrayMap/create {:description "RAS - Remote Access Service", :display-name "Remote Access Service", :class-name "ras"}), "ioslot" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the I/O Slot on the PFrame.", :display-name "I/O Slot", :class-name "ioslot"}), "db_redofilegroup" #=(clojure.lang.PersistentArrayMap/create {:description "A group of transaction logs that records data modifications made in the database.", :display-name "DB_Re-do File group", :class-name "db_redofilegroup"}), "siebel_wse" #=(clojure.lang.PersistentArrayMap/create {:description "A server running the Web tier of Siebel", :display-name "Siebel Web Server Extension", :class-name "siebel_wse"}), "domain" #=(clojure.lang.PersistentArrayMap/create {:description "Auto Discovery Domain represents a network domain for which Discovery Probe Gateway has been installed", :display-name "Auto Discovery Domain", :class-name "domain"}), "activedirectoryforest" #=(clojure.lang.PersistentArrayMap/create {:description "Active Directory Forest is a logical group of Active Directory Domains.", :display-name "Active Directory Forest", :class-name "activedirectoryforest"}), "layerproperties" #=(clojure.lang.PersistentArrayMap/create {:description "layer manual properties", :display-name "layer properties", :class-name "layerproperties"}), "mainframe_subsystem" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe subsystem", :display-name "MainframeSubsystem", :class-name "mainframe_subsystem"}), "tomcat" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of Apache Tomcat Web Server", :display-name "Apache Tomcat", :class-name "tomcat"}), "usb" #=(clojure.lang.PersistentArrayMap/create {:display-name "USB", :class-name "usb"}), "smtp_connector" #=(clojure.lang.PersistentArrayMap/create {:description "CIT represents SMTP Connector, which connects Exchange Organization with the Internet or with another organization using SMTP as a transport protocol.", :display-name "SMTP Connector", :class-name "smtp_connector"}), "snapshot" #=(clojure.lang.PersistentArrayMap/create {:description "Object encapsulating result snapshots", :display-name "snapshot", :class-name "snapshot"}), "loadbalancecluster" #=(clojure.lang.PersistentArrayMap/create {:description "Load Balancing Cluster - a cluster that operates by distributing a workload evenly over multiple back end nodes.  Key Attributes:  1. Name (data_name) - Name of cluster ", :display-name "Load Balancing Cluster", :class-name "loadbalancecluster"}), "configuration_document" #=(clojure.lang.PersistentArrayMap/create {:description "A document that contains a block of arbitrary information, or resource for storing information, which is available to a computer program and is usually based on some kind of durable storage", :display-name "ConfigurationDocument", :class-name "configuration_document"}), "discoveryprobegateway" #=(clojure.lang.PersistentArrayMap/create {:description "Discovery Dependency Mapping Probe Gateway", :display-name "Discovery Probe Gateway", :class-name "discoveryprobegateway"}), "primarydomaincontrollermaster" #=(clojure.lang.PersistentArrayMap/create {:description "The PDC emulator is a domain controller that advertises itself as the primary domain controller (PDC) to workstations, member servers, and domain controllers that are running earlier versions of Windows.", :display-name "PrimaryDomainControllerMaster", :class-name "primarydomaincontrollermaster"}), "daemon" #=(clojure.lang.PersistentArrayMap/create {:description "A program that forward requests to other programs (or processes).", :display-name "Daemon", :class-name "daemon"}), "system_monitor_links" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system CI Types ", :display-name "System Monitor Links", :class-name "system_monitor_links"}), "mscsresource" #=(clojure.lang.PersistentArrayMap/create {:description "Physical or logical entity managed by a cluster node. A resource provides a service to clients in a client/server environment.  Key Attributes:  1. Name (data_name) - Name of cluster resource  2. Container (root_container) - Parent cluster group ", :display-name "MSCS resource", :class-name "mscsresource"}), "dbdatafile" #=(clojure.lang.PersistentArrayMap/create {:description "Data file messages are being used to  transfer data files from computer to computer", :display-name "DB Data File", :class-name "dbdatafile"}), "sharepoint_farm" #=(clojure.lang.PersistentArrayMap/create {:description "SharePoint Farm", :display-name "SharePoint Farm", :class-name "sharepoint_farm"}), "vcloud_media" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Media", :display-name "vCloud Media", :class-name "vcloud_media"}), "sap_r3_server" #=(clojure.lang.PersistentArrayMap/create {:description "SAP's integrated software solution for client/server and distributed open systems. ", :display-name "SAP ABAP Application Server", :class-name "sap_r3_server"}), "printq" #=(clojure.lang.PersistentArrayMap/create {:description "The printer queue", :display-name "Print Queue", :class-name "printq"}), "viewprofile" #=(clojure.lang.PersistentArrayMap/create {:display-name "viewprofile", :class-name "viewprofile"}), "mainframe_db2_resource" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is an abstract class for all the Mainframe DB2 subsystem resources", :display-name "DB2Resource", :class-name "mainframe_db2_resource"}), "kpi" #=(clojure.lang.PersistentArrayMap/create {:description "Key Performance Indicators are quantifiable measurements that reflect the critical success factors of an organization.", :display-name "Kpi", :class-name "kpi"}), "impact_dependency" #=(clojure.lang.PersistentArrayMap/create {:display-name "Impacted By (Potentially)", :class-name "impact_dependency"}), "nnmprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "NNM Integration Protocol", :display-name "NNM Protocol", :class-name "nnmprotocol"}), "sunresourcegroup" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Sun Cluster Resource Group which groups several Resources consumed by the Data Services into single unit. In case of failure this unit fails over to different cluster node as a whole.", :display-name "Sun Resource Group", :class-name "sunresourcegroup"}), "sap_bp_project" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Business Blueprint Project", :display-name "SAP Project", :class-name "sap_bp_project"}), "manage" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Manage", :class-name "manage"}), "mqaliasqueue" #=(clojure.lang.PersistentArrayMap/create {:description "An IBM Alias Queue is simply an alias of another queue. It may be an alias of a local, remote, transmission or another alias queue. The alias queue and the queue for which it is an alias are within the same queue manager. Messages/commands issued on the alias queue are forwarded to the queue for which it is an alias", :display-name "IBM MQ Alias Queue", :class-name "mqaliasqueue"}), "iseries_program" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an iSeries program object.  This is an iSeries Program File. ", :display-name "IseriesProgram", :class-name "iseries_program"}), "task" #=(clojure.lang.PersistentArrayMap/create {:description "A discrete unit of work that can be assigned to a person or functional group", :display-name "Task", :class-name "task"}), "service_level_agreement" #=(clojure.lang.PersistentArrayMap/create {:description "An Agreement between an IT Service Provider and a Customer. The Service Level Agreement (SLA) describes the IT Service, documents Service Level Targets, and specifies the responsibilities of the IT Service Provider and the Customer. A single SLA may cover multiple IT Services or multiple Customers.to accomodate BAC, the targets are in the KPI Objective class, and teh links to ITService or ITProcess are through that via KPI.", :display-name "ServiceLevelAgreement", :class-name "service_level_agreement"}), "webspheremq" #=(clojure.lang.PersistentArrayMap/create {:description "Represents IBM WebSphere MQSeries Software", :display-name "IBMWebSphereMQ", :class-name "webspheremq"}), "power_distribution_unit" #=(clojure.lang.PersistentArrayMap/create {:description "Typically a large cabinet which contains a 480v to 120/240v transformer along with one or more branch circuit panelboards. These are used in large server rooms and datacenters and available options include harmonic filters, voltage/current/power measurement, monitoring, and recording  Key attributes    1. data_name - Name of the PDU    2. root_container - Datacenter/Building/Floor/Space in which this PDU is housed    3. power_distribution_unit_serialnumber - Serial number (optional attribute)", :display-name "PowerDistributionUnit", :class-name "power_distribution_unit"}), "lyncserver" #=(clojure.lang.PersistentArrayMap/create {:description "Microsoft Lync Server (previously Microsoft Office Communications Server) is an enterprise real-time communications server, providing the infrastructure for enterprise instant messaging, presence, file transfer, peer-to-peer and multiparty voice and video calling, ad hoc and structured conferences (audio, video and web) and PSTN connectivity.", :display-name "Lync Server", :class-name "lyncserver"}), "infrastructuremaster" #=(clojure.lang.PersistentArrayMap/create {:description "The infrastructure is responsible for updating references from objects in its domain to objects in other domains.", :display-name "InfrastructureMaster", :class-name "infrastructuremaster"}), "dasd3390" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents an emulated  3390 DASD volume", :display-name "Dasd3390", :class-name "dasd3390"}), "fcmdb_configuration" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_configuration", :class-name "fcmdb_configuration"}), "servlet" #=(clojure.lang.PersistentArrayMap/create {:description "servlet", :display-name "Servlet", :class-name "servlet"}), "bcastdomain" #=(clojure.lang.PersistentArrayMap/create {:display-name "Bcast Domain", :class-name "bcastdomain"}), "provider_of" #=(clojure.lang.PersistentArrayMap/create {:description "Describes a connection of type 'provider of' between two entities. The link points from the provider entity to another entity", :display-name "Provider Of", :class-name "provider_of"}), "agent" #=(clojure.lang.PersistentArrayMap/create {:description "virtual class to all agents", :display-name "Agent", :class-name "agent"}), "budget" #=(clojure.lang.PersistentArrayMap/create {:description "Budget contains information about money that has been budgeted for use. It has associated Cost Center and the Party that has the budget allocated to them. It contains a set of Budget Lines which have details of individual budget items.", :display-name "Budget", :class-name "budget"}), "elanvlanmap" #=(clojure.lang.PersistentArrayMap/create {:display-name "ELAN-VLAN Map", :class-name "elanvlanmap"}), "volumegroup" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the Volume Group", :display-name "Volume Group", :class-name "volumegroup"}), "ms_exchange_server" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Microsoft Exchange server software installed on some host.", :display-name "MicrosoftExchangeServer", :class-name "ms_exchange_server"}), "realization" #=(clojure.lang.PersistentArrayMap/create {:description "This link represents an element being realized by some other element.", :display-name "Realization", :class-name "realization"}), "nt" #=(clojure.lang.PersistentArrayMap/create {:description "Node with Microsoft Operation system (NT).", :display-name "Windows", :class-name "nt"}), "routing_group" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a Routing Group that exists in Exchange organization.  Routing groups are used to supply varying network connectivity across servers, and to restrict access of users in specific areas.  In Exchange 2007 there are no longer Routing Groups. Instead Exchange 2007 relies on the Active Directory Sites configuration to connect between different Exchange Servers.", :display-name "Exchange Routing Group", :class-name "routing_group"}), "nlb_clustersoftware" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the Microsoft NLB Software", :display-name "NLB Cluster Software", :class-name "nlb_clustersoftware"}), "ms_nlb_cluster" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents Microsoft Network Load Balancing Cluster Key Attributes: 1. Cluster IP Address 2. Cluster Network Mask 3. Cluster Netwirk Address (MAC)", :display-name "MS NLB Cluster", :class-name "ms_nlb_cluster"}), "trail" #=(clojure.lang.PersistentArrayMap/create {:description "The Trail element describes the path from one network to another.", :display-name "Trail", :class-name "trail"}), "chassis" #=(clojure.lang.PersistentArrayMap/create {:description "a chassis that holds atm switches", :display-name "Chassis", :class-name "chassis"}), "sqlprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Generic Database Connection and Query Protocol", :display-name "Generic DB Protocol (SQL)", :class-name "sqlprotocol"}), "iisftpservice" #=(clojure.lang.PersistentArrayMap/create {:description "IIS FTP Service", :display-name "IIS FTP Service", :class-name "iisftpservice"}), "party" #=(clojure.lang.PersistentArrayMap/create {:description "Any active entity or agent - a party can be an organization or a person.", :display-name "Party", :class-name "party"}), "glassfishas" #=(clojure.lang.PersistentArrayMap/create {:description "The Glassfish Application Server", :display-name "Glassfish AS", :class-name "glassfishas"}), "siebel_app_server" #=(clojure.lang.PersistentArrayMap/create {:description "An application running the business logic tier", :display-name "Siebel Application Server", :class-name "siebel_app_server"}), "sessionbean" #=(clojure.lang.PersistentArrayMap/create {:description "ejb session", :display-name "Session Bean", :class-name "sessionbean"}), "sap_trex_instance" #=(clojure.lang.PersistentArrayMap/create {:description "Representation of TREX instance as a unit of distributed or standalone deployment", :display-name "SapTrexInstance", :class-name "sap_trex_instance"}), "deployed" #=(clojure.lang.PersistentArrayMap/create {:display-name "Deployed", :class-name "deployed"}), "msmqrule" #=(clojure.lang.PersistentArrayMap/create {:description "MSMQ Rule", :display-name "MSMQ Rule", :class-name "msmqrule"}), "running_software" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the runtime aspects of a software system that is currently running or intended to be running on a Node. An instance of the RunningSoftware class is the place for runtime overview information such as last-startup-time and application-instance-name. The rather static characteristics of an installed software are represented by the InstalledSoftware class.", :display-name "RunningSoftware", :class-name "running_software"}), "httpcontext" #=(clojure.lang.PersistentArrayMap/create {:description "IBM HTTP Server plugin", :display-name "HTTP Context", :class-name "httpcontext"}), "dns_record" #=(clojure.lang.PersistentArrayMap/create {:description "Record types in DNS, such as A-type, CNAME-type or PTR-type", :display-name "DNS Record", :class-name "dns_record"}), "mqremotequeue" #=(clojure.lang.PersistentArrayMap/create {:description "A Remote Queue is a remote or proxy instance of another queue. It may be a remote instance for a local, remote, transmission or another alias queue. The remote queue and the queue for which it is a remote may be on different queue managers", :display-name "IBM MQ Remote Queue", :class-name "mqremotequeue"}), "oraclewebcomponent" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite Web Component", :display-name "Web Component", :class-name "oraclewebcomponent"}), "cost_center" #=(clojure.lang.PersistentArrayMap/create {:description "A Business Unit to which Costs are assigned. An IT Service Provider can be run as a Cost Center or a Profit Center.  A Cost Center does not charge for Services provided. Typical examples of a Cost Center include Research and Development, Marketing and Customer service.Start date is the creation date of the cost center, and end date is the obsolescence date. They are usually empty which means 'always' active.", :display-name "CostCenter", :class-name "cost_center"}), "ms_exchange_dag" #=(clojure.lang.PersistentArrayMap/create {:description "Exchange Database Availability Group", :display-name "Exchange Database Availability Group", :class-name "ms_exchange_dag"}), "msmqqueue" #=(clojure.lang.PersistentArrayMap/create {:description "MSMQ Queue", :display-name "MSMQ Queue", :class-name "msmqqueue"}), "sharepoint_service" #=(clojure.lang.PersistentArrayMap/create {:description "The SharePoint Service", :display-name "SharePoint Service", :class-name "sharepoint_service"}), "ModelNotificationDefinitionImpl" #=(clojure.lang.PersistentArrayMap/create {:display-name "Model Notification Definition", :class-name "ModelNotificationDefinitionImpl"}), "db2_datasharing_group" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe DB2 Data Sharing Group (DB2 subsystem clustering)", :display-name "Db2DataSharingGroup", :class-name "db2_datasharing_group"}), "jmsdatastore" #=(clojure.lang.PersistentArrayMap/create {:description "jms server data store", :display-name "JMS Data Store", :class-name "jmsdatastore"}), "activedirectory" #=(clojure.lang.PersistentArrayMap/create {:display-name "Active Directory", :class-name "activedirectory"}), "vmware_drs_config" #=(clojure.lang.PersistentArrayMap/create {:description "VMware DRS Config", :display-name "VMware DRS Config", :class-name "vmware_drs_config"}), "sap_gateway" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Gateway", :display-name "SAP Gateway", :class-name "sap_gateway"}), "rulename" #=(clojure.lang.PersistentArrayMap/create {:description "link for the floatable maps of problem isolation, which represents the rule", :display-name "rulename", :class-name "rulename"}), "cics_list" #=(clojure.lang.PersistentArrayMap/create {:description "This contains a list of CICS Groups. A CICS list contains groups installed at startup.", :display-name "CICS List", :class-name "cics_list"}), "vmware_resource_config" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Resource Config", :display-name "VMware Resource Config", :class-name "vmware_resource_config"}), "contains_cmdb" #=(clojure.lang.PersistentArrayMap/create {:display-name "contains_cmdb", :class-name "contains_cmdb"}), "j2eeapplication" #=(clojure.lang.PersistentArrayMap/create {:description "J2EE application - is a deployable unit of J2EE functionality", :display-name "J2EE Application", :class-name "j2eeapplication"}), "netappdomain" #=(clojure.lang.PersistentArrayMap/create {:description ".NET AppDomain", :display-name ".NetAppDomain", :class-name "netappdomain"}), "dbextent" #=(clojure.lang.PersistentArrayMap/create {:description "A unit of space allocated to a SQL Server object, such as a table or index, whenever the object needs more space.", :display-name "DB Extend", :class-name "dbextent"}), "unix" #=(clojure.lang.PersistentArrayMap/create {:description "Node with Unix Operation system.", :display-name "Unix", :class-name "unix"}), "discoverydoc" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Auto Discovery Documentation", :class-name "discoverydoc"}), "cpu" #=(clojure.lang.PersistentArrayMap/create {:description "A central processing unit (CPU) is an electronic circuit that can execute computer programs.", :display-name "Cpu", :class-name "cpu"}), "node_dependency" #=(clojure.lang.PersistentArrayMap/create {:description "This relationship represents dependency between hosts interacting with each other over TCP protocol and consuming certain ports.", :display-name "Host Dependency", :class-name "node_dependency"}), "iiswebsite" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Web Site", :display-name "IIS Web Site", :class-name "iiswebsite"}), "ssh" #=(clojure.lang.PersistentArrayMap/create {:description "ssh agent", :display-name "SSH", :class-name "ssh"}), "ipport" #=(clojure.lang.PersistentArrayMap/create {:description "Logical connection that using the internet protocol TCP/IP.", :display-name "TCP/IP Port", :class-name "ipport"}), "sap_client" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Client", :display-name "SAP Client", :class-name "sap_client"}), "activedirectorysitelink" #=(clojure.lang.PersistentArrayMap/create {:description "Site links define the WAN connections that are between sites.", :display-name "Active Directory Site Link", :class-name "activedirectorysitelink"}), "uri_endpoint" #=(clojure.lang.PersistentArrayMap/create {:description "A Uniform Resource Identifier (URI) as a communication endpoint describes a service endpoint which is accessible via a URI specified in the \"Uri\" attribute. It must be an Absolute URI as specified in RFC3986 Section 4.3 (http://www.ietf.org/rfc/rfc3986.txt). ", :display-name "UriEndpoint", :class-name "uri_endpoint"}), "amazon_ec2_config" #=(clojure.lang.PersistentArrayMap/create {:description "Represents configuration of running EC2 instance with partially information about used Amazon Machine Image (AMI)", :display-name "Amazon EC2 Config", :class-name "amazon_ec2_config"}), "actiondefinition" #=(clojure.lang.PersistentArrayMap/create {:description "defines an action at MAM event system", :display-name "actiondefinition", :class-name "actiondefinition"}), "time_bound_membership" #=(clojure.lang.PersistentArrayMap/create {:description "This relationship should be used to represent a membership that has a start and end date, .e.g. Employment in an organization. This relationship allows optional inclusion of the start and end date of the relationship. If neither the StartDate nor EndDate attributes are defined then this is exactly equivalent to the Membership relationship type.", :display-name "TimeBoundMembership", :class-name "time_bound_membership"}), "actionkey" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system action key", :display-name "actionkey", :class-name "actionkey"}), "hsrp" #=(clojure.lang.PersistentArrayMap/create {:description "link virtual ip to the real base on hsrp protocol", :display-name "HSRP", :class-name "hsrp"}), "ejbmodule" #=(clojure.lang.PersistentArrayMap/create {:description "A module containing the ejb", :display-name "EJB Module", :class-name "ejbmodule"}), "uddiregistryprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Uddi Registry Protocol", :display-name "Uddi Registry Protocol", :class-name "uddiregistryprotocol"}), "dbuser" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a user in Database", :display-name "DB User", :class-name "dbuser"}), "sqldatabase" #=(clojure.lang.PersistentArrayMap/create {:description "SQL Data Base from Microsoft", :display-name "MSSQL Database", :class-name "sqldatabase"}), "jbossas" #=(clojure.lang.PersistentArrayMap/create {:description "The Jboss Application Server", :display-name "JBoss AS", :class-name "jbossas"}), "power_supply" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a power supply unit on a network device.", :display-name "PowerSupply", :class-name "power_supply"}), "tibco_business_works" #=(clojure.lang.PersistentArrayMap/create {:description "The class represents a running software instance of TIBCO Business Works Engine", :display-name "TibcoBusinessWorks", :class-name "tibco_business_works"}), "system_links" #=(clojure.lang.PersistentArrayMap/create {:description "System Relationships.", :display-name "System Links", :class-name "system_links"}), "profile" #=(clojure.lang.PersistentArrayMap/create {:display-name "profile", :class-name "profile"}), "dbclient" #=(clojure.lang.PersistentArrayMap/create {:display-name "DB Client", :class-name "dbclient"}), "cell_board" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the Cell in the HP cellular server", :display-name "CellBoard", :class-name "cell_board"}), "ms_exchange_mailbox_database" #=(clojure.lang.PersistentArrayMap/create {:description "Exchange storage group - a logical container for Exchange databases and their associated system and transaction log files.", :display-name "Exchange Mailbox Database", :class-name "ms_exchange_mailbox_database"}), "relativeidmaster" #=(clojure.lang.PersistentArrayMap/create {:description "The RID master is responsible for processing RID pool requests from all domain controllers in a particular domain.", :display-name "RelativeIDMaster", :class-name "relativeidmaster"}), "AbstractReportDefinition" #=(clojure.lang.PersistentArrayMap/create {:description "Abstract Report definition", :display-name "AbstractReportDefinition", :class-name "AbstractReportDefinition"}), "route" #=(clojure.lang.PersistentArrayMap/create {:description "thr route links are links discovered by the discover route collector. this link represent a row data from the route table in the mib containing the data of the next_hop ip address and the destination network address. the route table is in the mib address :  table is in the mib address : 1.3.6.1.2.1.4.21.1.7", :display-name "Route", :class-name "route"}), "mainframe_xcf_member" #=(clojure.lang.PersistentArrayMap/create {:description "Member of Mainframe XCF Group", :display-name "MainframeXcfMember", :class-name "mainframe_xcf_member"}), "lyncsite" #=(clojure.lang.PersistentArrayMap/create {:description "A Site is a set of computers that are well-connected by a high-speed, low-latency network, such as a single local area network (LAN) or two networks connected by a high-speed fiber optic network. A Lync Site is defined in a network to contain Lync Sever 2010 Components. A Lync Site can contain one or more Lync Pools with each Pool containing one or more Lync Server 2010.", :display-name "Lync Site", :class-name "lyncsite"}), "marconiatmswitch" #=(clojure.lang.PersistentArrayMap/create {:description "the atmswitch class represents a network element that his oid represent an marconiatmswitch", :display-name "Marconi ATM Switch", :class-name "marconiatmswitch"}), "databaseresource" #=(clojure.lang.PersistentArrayMap/create {:description "virtual class to all database resources", :display-name "Database Resource", :class-name "databaseresource"}), "tibco_adapter" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a TIBCO Adapter", :display-name "TibcoAdapter", :class-name "tibco_adapter"}), "logdir" #=(clojure.lang.PersistentArrayMap/create {:description "Log dir definition", :display-name "Log Dir", :class-name "logdir"}), "physical_port" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a port on a switch or a router or other multi-function network infrastructure device.  Many times this class is treated the same as an Interface since there is one to one correspondence in general between them.  However, there are instances when Port is important when we want to work with the physical object that supports an interface.  Interface  is a logical object that represents the software encapsulation of certain data-link or or higher layers.", :display-name "PhysicalPort", :class-name "physical_port"}), "exchangetransportserver" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is a common super-type for two transport roles: Edge role and Hub role.", :display-name "Exchange Transport Server", :class-name "exchangetransportserver"}), "model" #=(clojure.lang.PersistentArrayMap/create {:description "model generic data", :display-name "model generic data", :class-name "model"}), "router" #=(clojure.lang.PersistentArrayMap/create {:description "A router is a device or software  that is connected to at least two networks and  decides the next network point to which destination to send the  information packet.", :display-name "Router", :class-name "router"}), "bridge" #=(clojure.lang.PersistentArrayMap/create {:description "A device which connects a local area network (LAN) to another local area network.", :display-name "Bridge", :class-name "bridge"}), "webservice_operation" #=(clojure.lang.PersistentArrayMap/create {:description "Web Service Operation", :display-name "Web Service Operation", :class-name "webservice_operation"}), "mscsgroup" #=(clojure.lang.PersistentArrayMap/create {:description "Collection of dependent or related resources to be managed as a single unit.  Key Attributes:  1. Name (data_name) - Name of cluster group  2. Container (root_container) - Parent container, i.e. clustered service ", :display-name "MSCS Resource Group", :class-name "mscsgroup"}), "panelinstruction" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system job interactive hard coded input parameter definition", :display-name "panelinstruction", :class-name "panelinstruction"}), "ibm_lpar_profile" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the configuration profile used for the LPAR When the LPar is created with the default profile, this CI will represent the default LPar configuration.  ", :display-name "IBM LPar Profile", :class-name "ibm_lpar_profile"}), "federation_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "federation_info", :class-name "federation_info"}), "udaprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "UD Protocol", :display-name "Universal Discovery Protocol", :class-name "udaprotocol"}), "sqlfile" #=(clojure.lang.PersistentArrayMap/create {:description "sql file", :display-name "SQL File", :class-name "sqlfile"}), "vmware_vcloud" #=(clojure.lang.PersistentArrayMap/create {:description "VMware vCloud", :display-name "VMware vCloud", :class-name "vmware_vcloud"}), "eview" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents the EView agent object for a LPAR node", :display-name "EView", :class-name "eview"}), "parent" #=(clojure.lang.PersistentArrayMap/create {:display-name "Parent", :class-name "parent"}), "tenant" #=(clojure.lang.PersistentArrayMap/create {:description "A Tenant is a set of groups of persons (customer, service provider persons, and supplier persons) whose access to data in support of given (set or part of) customer contract(s) is managed as a collective whole.In Enterprise Services terminology a tenant is referred to as customer receiving organization (CRO). Tenants are managed as part of the customer on-boarding process of the service provider.", :display-name "Tenant", :class-name "tenant"}), "exchange_administrative_group" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Administrative group in Exchange organization.  In Exchange 2007, the concept of Administrator group has been deprecated, and it's mainly used for backward compatible when working in environments that includes both Exchange 2007 and 2003. In Exchange 2007, there will be only one ADM group, where all Exchange servers are members of.  ", :display-name "Administrative group", :class-name "exchange_administrative_group"}), "fchba" #=(clojure.lang.PersistentArrayMap/create {:display-name "Fibre Channel HBA", :class-name "fchba"}), "mqlocalqueue" #=(clojure.lang.PersistentArrayMap/create {:description "A Local Queue is a basic message queue and container of messages. An application can place a message in it for delivery or request/retrieve a message from it", :display-name "IBM MQ Local Queue", :class-name "mqlocalqueue"}), "applicationLink" #=(clojure.lang.PersistentArrayMap/create {:description "link between server object and BusinessProcess", :display-name "applicationLink", :class-name "applicationLink"}), "ds_access_dc" #=(clojure.lang.PersistentArrayMap/create {:description "The properties of the this class provide information about Microsoft Active Directory and Microsoft Exchange Server 5.5 domain controllers that are accessible to the Exchange 2000 Server DSAccess service.", :display-name "Directory Service Access DC", :class-name "ds_access_dc"}), "composition" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a relation between 2 objects where one is contained within the other, and the included object can not exist without its container. Therefore, when the container is deleted, all its contained object will be automatically removed", :display-name "Composition", :class-name "composition"}), "msdomain" #=(clojure.lang.PersistentArrayMap/create {:description "MSDomain class represents a Microsoft  domains and workgroups.", :display-name "MS Domain", :class-name "msdomain"}), "mqsenderchannel" #=(clojure.lang.PersistentArrayMap/create {:description "A sender channel is associated with a specific Transmission queue within the same parent queue manager and has a well-defined destination.  Key Attributes: 1. Name (data_name) - The name of the MQ Queue 2. Container (root_container) - The container IBM MQ Queue Manager", :display-name "IBM MQ Sender Channel", :class-name "mqsenderchannel"}), "timerules" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system time rule", :display-name "timerules", :class-name "timerules"}), "eventlog" #=(clojure.lang.PersistentArrayMap/create {:description "Microsoft Event log data", :display-name "Event Log", :class-name "eventlog"}), "serviceguardcluster" #=(clojure.lang.PersistentArrayMap/create {:description "A Service Guard Cluster", :display-name "Service Guard Cluster", :class-name "serviceguardcluster"}), "iisapppool" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Application Pool", :display-name "IIS Application Pool", :class-name "iisapppool"}), "ipmp_group" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an IP Multipathing Group in Solaris OS. IPMP provides failure detection and failover for interfaces on a system that are attached to the same link.", :display-name "IPMP Group", :class-name "ipmp_group"}), "system_monitor" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system CI Types ", :display-name "System Monitor", :class-name "system_monitor"}), "emc_autostart_cluster" #=(clojure.lang.PersistentArrayMap/create {:description "EMC AutoStart Cluster", :display-name "EMC AutoStart Cluster", :class-name "emc_autostart_cluster"}), "oc4j" #=(clojure.lang.PersistentArrayMap/create {:display-name "OC4J", :class-name "oc4j"}), "ibm_pseries_frame" #=(clojure.lang.PersistentArrayMap/create {:description "\"IBM Frame\" CI represents the \"Managed System\" in the terms of IBM Virtualization Solution. This class has no children CITs ", :display-name "IBM Frame", :class-name "ibm_pseries_frame"}), "data" #=(clojure.lang.PersistentArrayMap/create {:display-name "Data", :class-name "data"}), "policy_result" #=(clojure.lang.PersistentArrayMap/create {:description "PolicyResult represents the result of evaluating how a policy of any category is satisified at a given point in time in a given system. This is an aggregate value.", :display-name "PolicyResult", :class-name "policy_result"}), "input" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system action/job input", :display-name "input", :class-name "input"}), "tibco_application" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a TIBCO Business Works application", :display-name "TibcoApplication", :class-name "tibco_application"}), "fcmdb_info_composition" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_info_composition", :class-name "fcmdb_info_composition"}), "sapjmxprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "SAP JMX Protocol", :display-name "SAP JMX Protocol", :class-name "sapjmxprotocol"}), "backbone" #=(clojure.lang.PersistentArrayMap/create {:description "the backbone links are links discovered by the discover layer 2 service. the link represent a connection between two switches (physical connection)", :display-name "Backbone", :class-name "backbone"}), "mqprocess" #=(clojure.lang.PersistentArrayMap/create {:description "CIT that represents WebSphere MQ processes", :display-name "IBM MQ Process", :class-name "mqprocess"}), "powershell" #=(clojure.lang.PersistentArrayMap/create {:description "CIT representing Windows Powershell protocol", :display-name "PowerShell", :class-name "powershell"}), "eventbase" #=(clojure.lang.PersistentArrayMap/create {:description "event base", :display-name "Event Base", :class-name "eventbase"}), "virtualization_layer" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the thin software layer running on bare metal. It can represent a kernel of the ESX Server's hypervisor for Vmware virtualization solution or any other hypervisor for other vendors", :display-name "Virtualization Layer Software", :class-name "virtualization_layer"}), "includes" #=(clojure.lang.PersistentArrayMap/create {:description "This relationship connects two CIs, one of which is included into another. A child CI can be moved to another parent, but when the parent is deleted, the child will be deleted as well, except if a second includes link exist on it already. Moving of a child CI possible by creation of new link to another parent and deletion of the first one.", :display-name "Includes", :class-name "includes"}), "j2eeserver" #=(clojure.lang.PersistentArrayMap/create {:description "The J2EE server identifies the server core of one instance of a J2EE platform product as described in the Java 2 Enterprise Edition Platform specification.", :display-name "J2EE Server", :class-name "j2eeserver"}), "monitoringserver" #=(clojure.lang.PersistentArrayMap/create {:description "Monitoring Server collects data about the quality of your network media, in both Enterprise Voice calls and A/V conferences. It also collects call error records (CERs), which you can use to troubleshoot failed calls. Additionally, it collects usage information in the form of call detail records (CDRs) about various Lync Server features so that you can calculate return on investment of your deployment, and plan the future growth of your deployment.", :display-name "Monitoring Server", :class-name "monitoringserver"}), "activedirectorydomain" #=(clojure.lang.PersistentArrayMap/create {:description "A domain is a partition in an Active Directory forest, and enables organizations to replicate data only to where it is needed. Since Active directory domains are organized in hierarchical structure \"Active Directory Domain\" CIT can have one of the two types of container: \"Active Directory Forest\" or \"Active Directory Domain\"", :display-name "Active Directory Domain", :class-name "activedirectorydomain"}), "ms_exchange_clustered_mailbox" #=(clojure.lang.PersistentArrayMap/create {:description "Exchange clustered mail box is a term used in Exchange 2007 clustering, it represents the virtual mail box shared accross the clustered Exchange servers.", :display-name "Exchange Clustered Mail Box ", :class-name "ms_exchange_clustered_mailbox"}), "siebel_application" #=(clojure.lang.PersistentArrayMap/create {:description "Siebel application", :display-name "Siebel Application", :class-name "siebel_application"}), "sqlservermaintenanceplan" #=(clojure.lang.PersistentArrayMap/create {:description "Maintenance plans store the workflow information of the maintenance tasks, these tasks are used to perform automate database services for reorganize, check and backup operation that required for make sure that the database performs well.", :display-name "SQL Server Maintenance Plan", :class-name "sqlservermaintenanceplan"}), "ldom_config" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents configuration of LDOM Domain", :display-name "LDOM Config", :class-name "ldom_config"}), "sap_rfc_connection" #=(clojure.lang.PersistentArrayMap/create {:display-name "RFC Connection", :class-name "sap_rfc_connection"}), "sqlserverpublisher" #=(clojure.lang.PersistentArrayMap/create {:description "The Publisher is a database instance that makes data available to other locations through replication. The Publisher can have one or more publications, each defining a logically related set of objects and data to replicate.", :display-name "SQL Server Publisher", :class-name "sqlserverpublisher"}), "winosuser" #=(clojure.lang.PersistentArrayMap/create {:description "Register user which has access to a Windows machine.", :display-name "Windows User", :class-name "winosuser"}), "vcloud_vapp" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud vApp", :display-name "vCloud vApp", :class-name "vcloud_vapp"}), "mail_server" #=(clojure.lang.PersistentArrayMap/create {:description "A system acting as a Mail Transfer Agent, running the appropriate software required to transfer electronic mail messages from one computer to another.", :display-name "MailServer", :class-name "mail_server"}), "project_task" #=(clojure.lang.PersistentArrayMap/create {:description "ProjectTask contains information for an individual task, a set of which constitute a Project.", :display-name "ProjectTask", :class-name "project_task"}), "virtual" #=(clojure.lang.PersistentArrayMap/create {:description "Link between Node and its virtual IP", :display-name "Virtual", :class-name "virtual"}), "dependency" #=(clojure.lang.PersistentArrayMap/create {:description "represents a dependency between 2 objects", :display-name "Dependency", :class-name "dependency"}), "vmware_dpm_config" #=(clojure.lang.PersistentArrayMap/create {:description "VMware DPM Config", :display-name "VMware DPM Config", :class-name "vmware_dpm_config"}), "sap_resource" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Resource", :display-name "SAP Resource", :class-name "sap_resource"}), "wmiprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "WMI Protocol", :display-name "WMI Protocol", :class-name "wmiprotocol"}), "vmwareprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "VMware VIM Protocol", :display-name "VMware VIM Protocol", :class-name "vmwareprotocol"}), "talk" #=(clojure.lang.PersistentArrayMap/create {:display-name "Talk", :class-name "talk"}), "vmware_port_group" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Port Group", :display-name "VMware Port Group", :class-name "vmware_port_group"}), "installed_software" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a software installed on a node. ", :display-name "InstalledSoftware", :class-name "installed_software"}), "db2_schema" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "DB2 Schema", :class-name "db2_schema"}), "iis_ftp_server" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of IIS FTP Server", :display-name "IIS FTP Server", :class-name "iis_ftp_server"}), "sap_system" #=(clojure.lang.PersistentArrayMap/create {:description "A logical unit, grouping together SAP-related entities (and possibly other entities as well) into one homogenous SAP deployment", :display-name "SAP System", :class-name "sap_system"}), "bridgeheadserver" #=(clojure.lang.PersistentArrayMap/create {:description "Bridgehead Servers are the contact point for the exchange of directory information between sites.", :display-name "BridgeHeadServer", :class-name "bridgeheadserver"}), "webservice_resource" #=(clojure.lang.PersistentArrayMap/create {:description "Abstract base class  for webservices resources.", :display-name "WebService Resource", :class-name "webservice_resource"}), "ms_exchange_folder_tree" #=(clojure.lang.PersistentArrayMap/create {:description "Instances of this class provide information about public and private folder trees on Microsoft Exchange servers.", :display-name "Exchange Folder tree", :class-name "ms_exchange_folder_tree"}), "db2_ddf_alias" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Distributed Data Facility Alias", :display-name "Db2DdfAlias", :class-name "db2_ddf_alias"}), "iiswebdir" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Web Dir", :display-name "IIS Web Dir", :class-name "iiswebdir"}), "known_error" #=(clojure.lang.PersistentArrayMap/create {:description "A Record containing the details of a Known Error", :display-name "KnownError", :class-name "known_error"}), "ldom_server" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents hardware of LDOM server", :display-name "LDOM Server", :class-name "ldom_server"}), "cluster_software" #=(clojure.lang.PersistentArrayMap/create {:description "The software that provides failover cluster capabilities on a certain node (e.g. the runtime software of MC/ServiceGuard on an HP-UX cluster node)", :display-name "ClusterSoftware", :class-name "cluster_software"}), "license_resource" #=(clojure.lang.PersistentArrayMap/create {:description "The License Resource", :display-name "License Resource", :class-name "license_resource"}), "hyperv_partition_config" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a configuration of child Hyper-V partition.", :display-name "Hyper-V Partition Config", :class-name "hyperv_partition_config"}), "iissmtpservice" #=(clojure.lang.PersistentArrayMap/create {:description "IIS SMTP Service", :display-name "IIS SMTP Service", :class-name "iissmtpservice"}), "j2eedomain" #=(clojure.lang.PersistentArrayMap/create {:description "Management domain of Java EE resources (i.e. servers, clusters, application components, etc.)", :display-name "J2EE Domain", :class-name "j2eedomain"}), "vmware_datastore" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a storage location for virtual machine files. A storage location can be a VMFS volume, a directory on Network Attached Storage, or a local file system path.", :display-name "VMware Datastore", :class-name "vmware_datastore"}), "siebel_site" #=(clojure.lang.PersistentArrayMap/create {:description "A logical unit, which describes a group of servers that function together to build a full-blown Siebel toolset experience", :display-name "Siebel Enterprise", :class-name "siebel_site"}), "sap_transport" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Transport", :display-name "SAP Transport", :class-name "sap_transport"}), "execution_environment" #=(clojure.lang.PersistentArrayMap/create {:description "Relationship between entities when one is executed in (or in a scope of) another entity.", :display-name "ExecutionEnvironment", :class-name "execution_environment"}), "jeenode" #=(clojure.lang.PersistentArrayMap/create {:description "A node is a logical grouping of managed servers. ", :display-name "JEE Node", :class-name "jeenode"}), "nonstop_sql_mx" #=(clojure.lang.PersistentArrayMap/create {:description "NonStop SQL/MX Catalog", :display-name "NonStop SQL/MX", :class-name "nonstop_sql_mx"}), "oc4j_app" #=(clojure.lang.PersistentArrayMap/create {:display-name "OC4JApplication", :class-name "oc4j_app"}), "io_chassis" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents I/O Chassis", :display-name "I/O Chassis", :class-name "io_chassis"}), "discoveryjob" #=(clojure.lang.PersistentArrayMap/create {:description "Auto discovery entity that can be launched on system entities for different discovery purposes", :display-name "Auto Discovery Job", :class-name "discoveryjob"}), "j2eedeployedobject" #=(clojure.lang.PersistentArrayMap/create {:description "j2ee deployed object", :display-name "J2EE Deployed Object", :class-name "j2eedeployedobject"}), "eventmessage" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM jms message", :display-name "eventmessage", :class-name "eventmessage"}), "dir" #=(clojure.lang.PersistentArrayMap/create {:description "Name of group of files in the same location.", :display-name "Dir", :class-name "dir"}), "param" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system condition parameter", :display-name "param", :class-name "param"}), "oraclesystem" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite", :display-name "Oracle E-Business Suite", :class-name "oraclesystem"}), "fcconnect" #=(clojure.lang.PersistentArrayMap/create {:display-name "Fiber Channel Connect", :class-name "fcconnect"}), "resource_pool" #=(clojure.lang.PersistentArrayMap/create {:description "A generic Resource Pool", :display-name "Resource Pool", :class-name "resource_pool"}), "mqqueue" #=(clojure.lang.PersistentArrayMap/create {:description "The IBM MQ Queue is a container of messages in the MQ Infrastructure and controls how messages are routed between queue managers. Queues may be setup in several configurations to control message ordering and delivery (F/LIFO, message priority, sequential delivery, guaranteed delivery, etc.) and are optimized to carry small amounts of information", :display-name "IBM MQ Queue", :class-name "mqqueue"}), "print" #=(clojure.lang.PersistentArrayMap/create {:display-name "Print", :class-name "print"}), "sap_j2ee_server_process" #=(clojure.lang.PersistentArrayMap/create {:description "A single J2EE server process instance", :display-name "SAP J2EE Server Process", :class-name "sap_j2ee_server_process"}), "vax" #=(clojure.lang.PersistentArrayMap/create {:description "VAX (Virtual Address eXtension) machine.", :display-name "VAX", :class-name "vax"}), "mqnamelist" #=(clojure.lang.PersistentArrayMap/create {:description "An IBM MQ namelist contains a list of names and is typically used to hold a list of MQ Queue Manager Clusters. These namelists are then specified in clusters namelist property and may be used by all queue managers in that cluster for look up", :display-name "IBM MQ Namelist", :class-name "mqnamelist"}), "hacmpcluster" #=(clojure.lang.PersistentArrayMap/create {:description "IBM HACMP (High Availability Cluster Multi-Processing) - provides a clustering technology that keeps server-based applications available, regardless of individual component failures", :display-name "HACMP Cluster", :class-name "hacmpcluster"}), "discoveryprobemanager" #=(clojure.lang.PersistentArrayMap/create {:description "Discovery Dependency Mapping Probe Manager", :display-name "Discovery Probe Manager", :class-name "discoveryprobemanager"}), "sap_business_process" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Business Process", :display-name "SAP Business Process", :class-name "sap_business_process"}), "failover_cluster" #=(clojure.lang.PersistentArrayMap/create {:description "A FailoverCluster is a Cluster that is implemented primarily for the purpose of providing high availability of services which the cluster provides. They operate by having redundant computers or nodes which are then used to provide service when system components fail.", :display-name "FailoverCluster", :class-name "failover_cluster"}), "cost" #=(clojure.lang.PersistentArrayMap/create {:description "Cost is used to describe IT cost accounting with real price calculated. It provides monetary IT cost amount and properties associated with it.", :display-name "Cost", :class-name "cost"}), "powers" #=(clojure.lang.PersistentArrayMap/create {:description "Power supply", :display-name "Powers", :class-name "powers"}), "resource" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a relation between an object and its resource", :display-name "Resource", :class-name "resource"}), "sqlalert" #=(clojure.lang.PersistentArrayMap/create {:description "SQL Server Agent  compares events to alerts that the user has defined. When it finds  a match, it fires an alert.", :display-name "SQL Alert", :class-name "sqlalert"}), "cluster_resource_config" #=(clojure.lang.PersistentArrayMap/create {:description "Physical or logical entity managed by a cluster node. A resource provides a service to clients in a client/server environment.  Key Attributes:  1. Name (data_name) - Name of cluster resource  2. Container (root_container) - Parent cluster group ", :display-name "ClusterResourceConfig", :class-name "cluster_resource_config"}), "folder" #=(clojure.lang.PersistentArrayMap/create {:display-name "folder", :class-name "folder"}), "business_transaction_flow" #=(clojure.lang.PersistentArrayMap/create {:display-name "BusinessTransactionFlow", :class-name "business_transaction_flow"}), "instruction" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system job instruction", :display-name "instruction", :class-name "instruction"}), "business_activity" #=(clojure.lang.PersistentArrayMap/create {:description "Business Activity consists of a set or sequence of actions undertaken by an organization to produce a product or provide a unit of service as part of the defined business process.Name attribute is inherited from Object and must be unique across all business activities that belong to the same business process.", :display-name "BusinessActivity", :class-name "business_activity"}), "msmqtrigger" #=(clojure.lang.PersistentArrayMap/create {:description "MSMQ Trigger", :display-name "MSMQ Trigger", :class-name "msmqtrigger"}), "budget_line" #=(clojure.lang.PersistentArrayMap/create {:description " Represent information contained in a single Budget Line in the Budget", :display-name "BudgetLine", :class-name "budget_line"}), "vcloud_resource" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Resource", :display-name "vCloud Resource", :class-name "vcloud_resource"}), "license_reservation" #=(clojure.lang.PersistentArrayMap/create {:description "License Reservation", :display-name "License Reservation", :class-name "license_reservation"}), "mqmessagequeue" #=(clojure.lang.PersistentArrayMap/create {:description "A Queue is a container of messages in the MQ Infrastructure", :display-name "MQ Queue", :class-name "mqmessagequeue"}), "cluster_resource_group_config" #=(clojure.lang.PersistentArrayMap/create {:description "Collection of dependent or related resources to be managed as a single unit.  Key Attributes:  1. Name (data_name) - Name of cluster group  2. Container (root_container) - Parent container, i.e. clustered service ", :display-name "ClusterResourceGroupConfig", :class-name "cluster_resource_group_config"}), "apache" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of Apache Http Web Server", :display-name "Apache", :class-name "apache"}), "nameserver" #=(clojure.lang.PersistentArrayMap/create {:description "An application that implements a name service protocol.", :display-name "NameServer", :class-name "nameserver"}), "disconnectedproperties" #=(clojure.lang.PersistentArrayMap/create {:description "manual node properties", :display-name "disconnected properties", :class-name "disconnectedproperties"}), "activedirectorysite" #=(clojure.lang.PersistentArrayMap/create {:description "A Site object in Active Directory represents a physical geographic location that hosts networks. Sites contain objects called Subnets.", :display-name "Active Directory Site", :class-name "activedirectorysite"}), "responsibility" #=(clojure.lang.PersistentArrayMap/create {:display-name "Responsibility", :class-name "responsibility"}), "sqlserversubscription" #=(clojure.lang.PersistentArrayMap/create {:description "A subscription is a request for a copy of a publication to be delivered to a Subscriber. The subscription defines what publication will be received, where, and when.", :display-name "SQL Server Subscription", :class-name "sqlserversubscription"}), "suncluster" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a Sun Cluster which groups all components of the cluster under common root.", :display-name "Sun Cluster", :class-name "suncluster"}), "atmswitch" #=(clojure.lang.PersistentArrayMap/create {:description "the atmswitch class represents a network element which its oid represent an Atm switch", :display-name "ATM Switch", :class-name "atmswitch"}), "last_synch_unit_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "last_synch_unit_info", :class-name "last_synch_unit_info"}), "web_server" #=(clojure.lang.PersistentArrayMap/create {:description "A software that accepts http requests and delivers as a response web pages. WebServers allow web-clients to access the pages and resources of web-applications. Examples: 'Apache web Server' , 'IIS'.", :display-name "WebServer", :class-name "web_server"}), "sap_its_wgate" #=(clojure.lang.PersistentArrayMap/create {:description "An SAP Internet Transaction Server component that establishes the connection between the ITS and the web server and forwards user requests to the AGATE", :display-name "SAP ITS WGate", :class-name "sap_its_wgate"}), "domaincontrollerresource" #=(clojure.lang.PersistentArrayMap/create {:description "DomainController Resourc", :display-name "DomainController Resource", :class-name "domaincontrollerresource"}), "vcloud_vapp_template" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud vApp Template", :display-name "vCloud vApp Template", :class-name "vcloud_vapp_template"}), "domainnamingmaster" #=(clojure.lang.PersistentArrayMap/create {:description "The domain naming master domain controller controls the addition or removal of domains in the forest.", :display-name "DomainNamingMaster", :class-name "domainnamingmaster"}), "datacenter_resource" #=(clojure.lang.PersistentArrayMap/create {:description "Virtual CI Type representing data center resources such as buildings, floors, spaces, etc.", :display-name "DatacenterResource", :class-name "datacenter_resource"}), "mainframe_db2_tablespace" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe DB2 Tablespace", :display-name "MainframeDb2Tablespace", :class-name "mainframe_db2_tablespace"}), "synch_config_unit" #=(clojure.lang.PersistentArrayMap/create {:display-name "synch_config_unit", :class-name "synch_config_unit"}), "iseriessubsystem" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents  an  iSeries subsystem. System-supplied iseries subsystems are used to control jobs and functions. A subsystem description defines how, where, and how much work enters a subsystem, and which resources the subsystem uses to do the work", :display-name "iSeriesSubsystem", :class-name "iseriessubsystem"}), "simprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "HP SIM Protocol", :display-name "HP SIM Protocol", :class-name "simprotocol"}), "watch" #=(clojure.lang.PersistentArrayMap/create {:description "Synchronizes business model with discovered world", :display-name "Watch", :class-name "watch"}), "hardware_board" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a hardware board on a network or any other type of device.  Network devices have many kinds of boards.  Some provide multiple functions like routing, switching, or other services while others just provide a containment to host physical ports and connect themselves to the backplane.  Hardware boards are commodities that are swappable.  Sometimes hardware boards also host other sub-boards on them which then host the ports, but this class does not model sub-boards.  ", :display-name "HardwareBoard", :class-name "hardware_board"}), "directorserver" #=(clojure.lang.PersistentArrayMap/create {:description "Directors can authenticate Lync Server user requests, but do not home user accounts, or provide presence or conferencing services. Directors are most useful in deployments that enable external user access, where the Director can authenticate requests before sending them on to internal servers.", :display-name "Director Server", :class-name "directorserver"}), "process" #=(clojure.lang.PersistentArrayMap/create {:description "An instance of a program.", :display-name "Process", :class-name "process"}), "vmware_cluster" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Cluster is a collection of ESX Server hosts with shared resources and a shared management interface. When you add a host to a cluster, the host's resources become part of the cluster's resources. The cluster manages the resources of all hosts", :display-name "VMware Cluster", :class-name "vmware_cluster"}), "jbossprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "JBOSS Protocol", :display-name "JBOSS Protocol", :class-name "jbossprotocol"}), "virtual_management_software" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a Virtual Management Software", :display-name "Virtual Management Software", :class-name "virtual_management_software"}), "sqljob" #=(clojure.lang.PersistentArrayMap/create {:description "A job is a specified series of operations performed sequentially by SQL Server Agent. A job can perform a wide range of activities, including running Transact-SQL scripts, command line applications, and Microsoft ActiveX scripts.", :display-name "SQL Job", :class-name "sqljob"}), "ownership" #=(clojure.lang.PersistentArrayMap/create {:display-name "Ownership", :class-name "ownership"}), "mainframe_imsdbarea" #=(clojure.lang.PersistentArrayMap/create {:description "IMS Database Area. IMS databases of type DEDB (Data Entry DB) are grouped beneath these Areas.", :display-name "IMS DB Area", :class-name "mainframe_imsdbarea"}), "adam" #=(clojure.lang.PersistentArrayMap/create {:description "Identifies the Active Directory Application Mode software", :display-name "ActiveDirectoryApplicationMode", :class-name "adam"}), "imstransaction" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe IMS Transaction. An IMS transaction is a specific set of input data that triggers the execution of a specific process or job. An IMS transaction is a message destined for an application program.", :display-name "IMS Transaction", :class-name "imstransaction"}), "mysql_replication" #=(clojure.lang.PersistentArrayMap/create {:description "MySQL replication job", :display-name "MySQL Replication", :class-name "mysql_replication"}), "osuser" #=(clojure.lang.PersistentArrayMap/create {:description "OS user", :display-name "OS User", :class-name "osuser"}), "cmdbclass" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a cmdb type (host, application etc.)", :display-name "Cmdb Type", :class-name "cmdbclass"}), "logical_volume" #=(clojure.lang.PersistentArrayMap/create {:description "A region of storage on which a FileSystem can be created ", :display-name "LogicalVolume", :class-name "logical_volume"}), "mainframe_xcf_group" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe Cross System Coupling Facility (XCF) group, used to support messaging between XCF members across LPARs inside a Sysplex", :display-name "MainframeXcfGroup", :class-name "mainframe_xcf_group"}), "eventtimerules" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system rule", :display-name "eventtimerules", :class-name "eventtimerules"}), "business_process" #=(clojure.lang.PersistentArrayMap/create {:description "A Business Process is a collection of interrelated tasks (user-triggers or automatic), which solve a particular issue to define the functional needs of the business service being provided. A process can be hierarchically decomposed into business activities. Usage:  Some of the business processes are provided to the external customers, others are internal processes that are essential for the effective management of the business. Example: Order processing, new employee on-boarding, etc.", :display-name "BusinessProcess", :class-name "business_process"}), "sqlbackup" #=(clojure.lang.PersistentArrayMap/create {:description "A backup file, which was generated by the system or by user requests", :display-name "SQL Backup", :class-name "sqlbackup"}), "cost_category" #=(clojure.lang.PersistentArrayMap/create {:description "The cost categories are a classification of expenses. Typical examples include hardware, telephone, software, etc.", :display-name "CostCategory", :class-name "cost_category"}), "mqqueuesharinggroup" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe MQ Sharing Group (MQ subsystem clustering)", :display-name "MQSharingGroup", :class-name "mqqueuesharinggroup"}), "lyncresource" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is an abstract CIT representing all the Microsoft Lync Server Resources like Lync Server Role.", :display-name "Lync Resource", :class-name "lyncresource"}), "mqreceiverchannel" #=(clojure.lang.PersistentArrayMap/create {:description "A receiver channel will receive messages from remote queue managers through a sending channel with the same name.  Key Attributes: 1. Name (data_name) - The name of the MQ Queue 2. Container (root_container) - The container IBM MQ Queue Manager", :display-name "IBM MQ Receiver Channel", :class-name "mqreceiverchannel"}), "dbtable" #=(clojure.lang.PersistentArrayMap/create {:description "A table organizes the information about a single topic into rows and columns.", :display-name "DB Table", :class-name "dbtable"}), "shell" #=(clojure.lang.PersistentArrayMap/create {:description "Operation System shell", :display-name "Shell", :class-name "shell"}), "lb_software" #=(clojure.lang.PersistentArrayMap/create {:description "Abstract class for all Load balancers software", :display-name "Load balancer software", :class-name "lb_software"}), "registrarserver" #=(clojure.lang.PersistentArrayMap/create {:description "A registrar is a service that accepts register requests from Session Initiation Protocol (SIP) endpoints. Registrars then save the registration information into a location database. The information in this database is used to route signaling information to the endpoint.", :display-name "Registrar Server", :class-name "registrarserver"}), "asset" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an Asset/CI from an Asset management perspective. Usage: The Asset class is used as support for asset management discipline. An asset should represent an item of some value (usually dollars) that needs to be tracked and managed through various applications.Examples: An email system, a server, a software license, etc.", :display-name "Asset", :class-name "asset"}), "configuration_links" #=(clojure.lang.PersistentArrayMap/create {:description "all configuration Relationships", :display-name "Configuration Links", :class-name "configuration_links"}), "license_contract" #=(clojure.lang.PersistentArrayMap/create {:description "License contracts are used to describe the terms and conditions negotiated with software providers and vendors.License contracts are not to be confused with the actual licenses themselves.", :display-name "LicenseContract", :class-name "license_contract"}), "change" #=(clojure.lang.PersistentArrayMap/create {:description " A Record containing the details of a Change. Each Change Record documents the Lifecycle of a single Change. A Change Record is created for every Request for Change that is received, even those that are subsequently rejected. Change Records should reference the Configuration Items that are affected by the Change. Change Records are stored in the Configuration Management System. This class corresponds to what ITILv3 calls a Change Record.", :display-name "Change", :class-name "change"}), "actioninvocationdata" #=(clojure.lang.PersistentArrayMap/create {:display-name "actioninvocationdata", :class-name "actioninvocationdata"}), "PackageDependency" #=(clojure.lang.PersistentArrayMap/create {:display-name "PackageDependency", :class-name "PackageDependency"}), "dbaobjects" #=(clojure.lang.PersistentArrayMap/create {:description "An object that representing the database procedure, function, package and package-body", :display-name "DBA Object", :class-name "dbaobjects"}), "sap_application_component" #=(clojure.lang.PersistentArrayMap/create {:description "A group of SAP transactions with some common denominator, or of a few Application Components", :display-name "SAP Application Component", :class-name "sap_application_component"}), "ms_exchange_resource" #=(clojure.lang.PersistentArrayMap/create {:description "This abstract class represents additional components of Exchange server.", :display-name "Microsoft Exchange Resource", :class-name "ms_exchange_resource"}), "avconferencingserver" #=(clojure.lang.PersistentArrayMap/create {:description "A/V Conferencing Server provides A/V conferencing functionality to your deployment. It can be collocated with Front End Server, or deployed separately as a single server or A/V Conferencing Server pool.", :display-name "AV Conferencing Server", :class-name "avconferencingserver"}), "siebel_web_app" #=(clojure.lang.PersistentArrayMap/create {:description "A Siebel application's location on the web server", :display-name "Siebel Web Application", :class-name "siebel_web_app"}), "mainframe_db2_database" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a DB2 database instance on a Mainframe", :display-name "MainframeDb2Database", :class-name "mainframe_db2_database"}), "tomcatservice" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a Apache Tomcat Service", :display-name "Apache Tomcat Service", :class-name "tomcatservice"}), "ldom_virtual_switch" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents LDOM Virtual Switch", :display-name "LDOM Virtual Switch", :class-name "ldom_virtual_switch"}), "ms_exchange_folder" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Public folders available on the Exchange system. Public folder may be organized in hierarchical structure, i.e. one Public folder may contain another Public folder.", :display-name "Exchange Folder", :class-name "ms_exchange_folder"}), "target" #=(clojure.lang.PersistentArrayMap/create {:display-name "target", :class-name "target"}), "receive_connector" #=(clojure.lang.PersistentArrayMap/create {:description "CIT represents Receive Connector - a logical gateway through which all inbound messages are received to the HUB.", :display-name "Receive Connector", :class-name "receive_connector"}), "mainframe_sysplex" #=(clojure.lang.PersistentArrayMap/create {:description "Represents an IBM Systems Complex", :display-name "MainframeSysplex", :class-name "mainframe_sysplex"}), "fcswitch" #=(clojure.lang.PersistentArrayMap/create {:display-name "Fibre Channel Switch", :class-name "fcswitch"}), "inheritance_f" #=(clojure.lang.PersistentArrayMap/create {:display-name "inheritance_f", :class-name "inheritance_f"}), "virtual_host_resource" #=(clojure.lang.PersistentArrayMap/create {:description "Virtual Host Resource  Key Attributes:  1. Name (data_name) - Name of Host Resource  2. Container (root_container) - Host Resource's container, usually a Host  ", :display-name "Virtual Host Resource", :class-name "virtual_host_resource"}), "join_f" #=(clojure.lang.PersistentArrayMap/create {:display-name "Virtual - Join", :class-name "join_f"}), "sqlserver" #=(clojure.lang.PersistentArrayMap/create {:description "SQL server", :display-name "SQL Server", :class-name "sqlserver"}), "physicalvolume" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the Physical Volume.", :display-name "Physical Volume", :class-name "physicalvolume"}), "outage" #=(clojure.lang.PersistentArrayMap/create {:description " The duration for which a Configuration Item or IT Service is not Available during its Agreed Service Time. The Availability of an IT Service is often calculated from Agreed Service Time and Downtime.", :display-name "Outage", :class-name "outage"}), "business_application" #=(clojure.lang.PersistentArrayMap/create {:description "A collection of software components that can be managed as an independent unit that supports a particular business function.  An application is a logical composition of the functionality required to manipulate the data and provide the functional requirements of underlying business processes. An application has a set of supporting infrastructure entities.Example: Call center application, trade application etc.", :display-name "BusinessApplication", :class-name "business_application"}), "tibcoprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "TIBCO Protocol", :display-name "TIBCO Protocol", :class-name "tibcoprotocol"}), "last_concrete_synch_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "last_concrete_synch_info", :class-name "last_concrete_synch_info"}), "time_bound_connection" #=(clojure.lang.PersistentArrayMap/create {:display-name "TimeBoundConnection", :class-name "time_bound_connection"}), "uddiregistry" #=(clojure.lang.PersistentArrayMap/create {:description "Represent a UDDI Registry", :display-name "UDDI Registry", :class-name "uddiregistry"}), "remote_power_panel" #=(clojure.lang.PersistentArrayMap/create {:description "An RPP is the same as a Power Distribution Unit with the difference that it does not contain a transformer. An RPP is usually powered by a PDU  Key attributes    1. data_name - Name of the PDU    2. root_container - Datacenter/Building/Floor/Space in which this PDU is housed    3. power_distribution_unit_serialnumber - Serial number (optional attribute)", :display-name "RemotePowerPanel", :class-name "remote_power_panel"}), "containment" #=(clojure.lang.PersistentArrayMap/create {:display-name "Containment", :class-name "containment"}), "kpi_of" #=(clojure.lang.PersistentArrayMap/create {:description "KPI Of", :display-name "KPI Of", :class-name "kpi_of"}), "mainframe_job" #=(clojure.lang.PersistentArrayMap/create {:description "This Class represents a Job or Started Task on the Mainframe", :display-name "MainframeJob", :class-name "mainframe_job"}), "mainframe_imsresource" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe IMS Resource", :display-name "IMS Resource", :class-name "mainframe_imsresource"}), "incident" #=(clojure.lang.PersistentArrayMap/create {:display-name "Incident", :class-name "incident"}), "hacmpgroup" #=(clojure.lang.PersistentArrayMap/create {:description "Collection of dependent or related resources to be managed as a single unit.", :display-name "HACMP Resource Group", :class-name "hacmpgroup"}), "application_server" #=(clojure.lang.PersistentArrayMap/create {:description "An application server, in an n-tier architecture, is a server that hosts an API to expose business logic and business processes for use by third-party applications. The term application server sometimes refers to a J2EE application server. These types of application servers mainly serve Web applications, but some application servers may target networks other than the web (e.g., telephony networks).", :display-name "ApplicationServer", :class-name "application_server"}), "contract" #=(clojure.lang.PersistentArrayMap/create {:description "A legally binding Agreement between two or more parties. A contract can be of different kind as lease, maintenance, SLA, etc. A contract may support multiple assets.", :display-name "Contract", :class-name "contract"}), "circularproperties" #=(clojure.lang.PersistentArrayMap/create {:description "manual node properties", :display-name "circular properties", :class-name "circularproperties"}), "oracleapplication" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite Application", :display-name "Oracle Application", :class-name "oracleapplication"}), "policy" #=(clojure.lang.PersistentArrayMap/create {:description "Policy is of a specific set of Categories. It contains the specification of a single policy related to it category(ies). It must have a unique name assigned by the creator of the policy.", :display-name "Policy", :class-name "policy"}), "j2eecluster" #=(clojure.lang.PersistentArrayMap/create {:description "Cluster of Java EE Servers that provides high availability, scalability and fault tolerance services", :display-name "J2EE Cluster", :class-name "j2eecluster"}), "oracleappservice" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite Application Service", :display-name "Oracle Application Service", :class-name "oracleappservice"}), "enclosure" #=(clojure.lang.PersistentArrayMap/create {:display-name "Enclosure", :class-name "enclosure"}), "mqresource" #=(clojure.lang.PersistentArrayMap/create {:description "Message Queue Resource", :display-name "Message Queue Resource", :class-name "mqresource"}), "work_unit" #=(clojure.lang.PersistentArrayMap/create {:description "Unit of Work in hours that is consumed by Project, and is assigned to a person.", :display-name "WorkUnit", :class-name "work_unit"}), "exchangesystem" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Exchange Organization.", :display-name "Exchange Organization", :class-name "exchangesystem"}), "sap_business_scenario" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Business Scenario", :display-name "SAP Business Scenario", :class-name "sap_business_scenario"}), "interaction" #=(clojure.lang.PersistentArrayMap/create {:description "An Interaction describes the converstion between the help desk and a user.An interaction does not live on its own, it is always registered in the context of another object (e.g. Problem, Incident, Request For Change).", :display-name "Interaction", :class-name "interaction"}), "messagecatalog" #=(clojure.lang.PersistentArrayMap/create {:display-name "messagecatalog", :class-name "messagecatalog"}), "adapter_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "adapter_config", :class-name "adapter_config"}), "file_system" #=(clojure.lang.PersistentArrayMap/create {:description "A file system mounted on a Node.A file system provides the means for storing and organizing computer files and the data they contain to make it easy to find and access them.  This class corresponds to the general notion of file system used by Unix, Windows, Linux, etc.", :display-name "FileSystem", :class-name "file_system"}), "compound_f" #=(clojure.lang.PersistentArrayMap/create {:display-name "Virtual - Compound", :class-name "compound_f"}), "amazon_account" #=(clojure.lang.PersistentArrayMap/create {:description "Application system for the Amazon Cloud Account", :display-name "Amazon Account", :class-name "amazon_account"}), "vmware_networking_policy" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Networking Policy", :display-name "VMware Networking Policy", :class-name "vmware_networking_policy"}), "rawevent" #=(clojure.lang.PersistentArrayMap/create {:description "raw evnet", :display-name "Raw Event", :class-name "rawevent"}), "sgpackage" #=(clojure.lang.PersistentArrayMap/create {:description "SG Package  Key Attributes:  1. Name (data_name) - Name of package  2. Container (root_container) - Parent container, i.e. clustered service ", :display-name "SG Package", :class-name "sgpackage"}), "uda" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a Universal Discovery Agent that is running on a remote machine and enables shell functionality", :display-name "UDA", :class-name "uda"}), "ipclient" #=(clojure.lang.PersistentArrayMap/create {:description "Client port is the a port  which the server port is connected to.", :display-name "Client Port", :class-name "ipclient"}), "db2_datasharing_group_member" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a member of the DB2 Data Sharing Group", :display-name "Db2DatasharingGroupMember", :class-name "db2_datasharing_group_member"}), "websphereas" #=(clojure.lang.PersistentArrayMap/create {:description "The Websphere Application Server", :display-name "Websphere AS", :class-name "websphereas"}), "chassisvlanmap" #=(clojure.lang.PersistentArrayMap/create {:display-name "Chassis VLAN Map", :class-name "chassisvlanmap"}), "project_issue" #=(clojure.lang.PersistentArrayMap/create {:description "ProjectIssue contains information about individual issues that arise during the execution of a project, and the disposition thereof.", :display-name "ProjectIssue", :class-name "project_issue"}), "wmi" #=(clojure.lang.PersistentArrayMap/create {:description "wmi agent", :display-name "WMI", :class-name "wmi"}), "destination_config" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "destination_config", :class-name "destination_config"}), "iseries_jobqueue" #=(clojure.lang.PersistentArrayMap/create {:description "This Class represents a Job Queue on the Iseries Node", :display-name "IseriesJobQueue", :class-name "iseries_jobqueue"}), "vmware_virtual_switch" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Virtual Switch", :display-name "VMware Virtual Switch", :class-name "vmware_virtual_switch"}), "fcmdb_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_config", :class-name "fcmdb_config"}), "organization" #=(clojure.lang.PersistentArrayMap/create {:description "This is a single node in a structure of groupings within a company that serve to collect people for pursuing a common goal or to serve a need of an administrative structure. The organization will be hierarchical and typically follow a sort of level 1 to level N structure with Persons being members of the leaf nodes of the organization.Different structures can be used to achieve different goals for the organizing entity.", :display-name "Organization", :class-name "organization"}), "mainframe_page_dataset" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a paged data set on a mainframe", :display-name "MainframePageDataset", :class-name "mainframe_page_dataset"}), "vcloud_organization" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Organization", :display-name "vCloud Organization", :class-name "vcloud_organization"}), "entitybean" #=(clojure.lang.PersistentArrayMap/create {:description "ejb entity", :display-name "Entity Bean", :class-name "entitybean"}), "netdevice" #=(clojure.lang.PersistentArrayMap/create {:description "The Net Device class represents a specific purpose machines such as Routers, Switches, Printers", :display-name "Net Device", :class-name "netdevice"}), "tailor" #=(clojure.lang.PersistentArrayMap/create {:display-name "tailor", :class-name "tailor"}), "vcloud_managed_organization" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Managed Organization", :display-name "vCloud Managed Organization", :class-name "vcloud_managed_organization"}), "mainframe_major_node" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a mainframe major node", :display-name "MainframeMajorNode", :class-name "mainframe_major_node"}), "jmsserver" #=(clojure.lang.PersistentArrayMap/create {:description "jms server", :display-name "JMS Server", :class-name "jmsserver"}), "fan" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a fan on a device such as a network device.", :display-name "Fan", :class-name "fan"}), "impact_link" #=(clojure.lang.PersistentArrayMap/create {:display-name "Impacted By", :class-name "impact_link"}), "iis" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of IIS web-server (Microsoft Internet Information Server).", :display-name "IIS Web Server", :class-name "iis"}), "socket" #=(clojure.lang.PersistentArrayMap/create {:display-name "Socket", :class-name "socket"}), "project_objective" #=(clojure.lang.PersistentArrayMap/create {:description "Typically a business unit will layout an number of objectives for a given time frame (1-5 years).During the investment qualification and selection process projects are tagged with the objective(s) the project contributes to fulfilling.Expand to Europe might be an objective. There will likely be a series of investments (programs, projects, ...) that are the means to the end \"expand to Europe\".", :display-name "ProjectObjective", :class-name "project_objective"}), "sap_smd_agent" #=(clojure.lang.PersistentArrayMap/create {:description "Solution Manager Diagnostics Agent", :display-name "SapSmdAgent", :class-name "sap_smd_agent"}), "ibm_hmc" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the IBM HMC management software.", :display-name "IBM HMC", :class-name "ibm_hmc"}), "cluster_resource_group" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a cluster resource group (\"Cluster Package\" in MC/ServiceGuard terminology) on a failover cluster. The CRG provides a runtime environment that is similar to a virtual node (network connectivity, storage), but does not provide the level of isolation of virtual machines running on a hypervisor. A CRG can move between a select set of members of a Failover Cluster, and at any given point in time will (if active) be running on exactly one cluster member. ", :display-name "ClusterResourceGroup", :class-name "cluster_resource_group"}), "routing_connector" #=(clojure.lang.PersistentArrayMap/create {:description "CIT represents a common super-type for Send and Receive Connectors in Exchange 2007.", :display-name "Exchange Routing Connector", :class-name "routing_connector"}), "rac" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle RAC allows multiple computers to run the Oracle RDBMS software simultaneously while accessing a single database", :display-name "Oracle RAC", :class-name "rac"}), "j2eemodule" #=(clojure.lang.PersistentArrayMap/create {:description "j2ee deployed CI", :display-name "J2EE Module", :class-name "j2eemodule"}), "iiswebservice" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Web Service", :display-name "IIS Web Service", :class-name "iiswebservice"}), "monitor_links" #=(clojure.lang.PersistentArrayMap/create {:display-name "Monitor Links", :class-name "monitor_links"}), "service_level_objective" #=(clojure.lang.PersistentArrayMap/create {:description "A commitment that is documented in a Service Level Agreement.  SLOs are based on a customer requirement for an aspect of an IT Service.  Objectives are usually based on KPIs.", :display-name "ServiceLevelObjective", :class-name "service_level_objective"}), "routing_group_connector" #=(clojure.lang.PersistentArrayMap/create {:description "CIT represents a Routing Group Connector a one-way communication link between two Routing Groups.  Although it is possible to use an X.400 connector or an SMTP connector to connect routing groups, the routing group connector is specifically designed for this purpose and is the preferred method of connecting routing groups in most cases. ", :display-name "Routing Group Connector", :class-name "routing_group_connector"}), "vcsresource" #=(clojure.lang.PersistentArrayMap/create {:description "Physical or logical entity managed by a cluster node. A resource provides a service to clients in a client/server environment.  Key Attributes:  1. Name (data_name) - Name of cluster resource  2. Container (root_container) - Parent cluster group ", :display-name "VCS resource", :class-name "vcsresource"}), "mscluster" #=(clojure.lang.PersistentArrayMap/create {:description "Microsoft cluster server provides a clustering technology that keeps server-based applications available, regardless of individual component failures", :display-name "MS Cluster", :class-name "mscluster"}), "fcmdb_configuration_link" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_configuration_link", :class-name "fcmdb_configuration_link"}), "ntcmd" #=(clojure.lang.PersistentArrayMap/create {:description "HPCmd or pstools", :display-name "NTCMD", :class-name "ntcmd"}), "vmware_virtual_center" #=(clojure.lang.PersistentArrayMap/create {:description "VMware VirtualCenter is the representation of the VirtualCenter application which runs on some host and is used to manage the Virtual Lab", :display-name "VMware VirtualCenter", :class-name "vmware_virtual_center"}), "deployedResource" #=(clojure.lang.PersistentArrayMap/create {:description "MAM's package's resource", :display-name "MAM resource", :class-name "deployedResource"}), "activity_log" #=(clojure.lang.PersistentArrayMap/create {:description "A description of a specific update in an ITIL Process, most often related to the completion of a process step", :display-name "ActivityLog", :class-name "activity_log"}), "synch_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "synch_config", :class-name "synch_config"}), "atmswitching" #=(clojure.lang.PersistentArrayMap/create {:description "ATM switching", :display-name "ATM Switching", :class-name "atmswitching"}), "elan" #=(clojure.lang.PersistentArrayMap/create {:description "a elan", :display-name "ELAN", :class-name "elan"}), "dbindex" #=(clojure.lang.PersistentArrayMap/create {:description "Syntax specified one or more indexes to use for a table hint.", :display-name "DB Index", :class-name "dbindex"}), "network_entity" #=(clojure.lang.PersistentArrayMap/create {:description "Base class for classes representing cross device network objects such as Vlan and Subnet. ", :display-name "NetworkEntity", :class-name "network_entity"}), "switch" #=(clojure.lang.PersistentArrayMap/create {:description "A switch is a device that sends incoming data from any of multiple input to specific output port.", :display-name "Switch", :class-name "switch"}), "mainframe" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents the physical Mainframe system. It is the physical collection of hardware that includes main storage, one or more central processors, timers, and channels.", :display-name "Mainframe CPC", :class-name "mainframe"}), "activeevent" #=(clojure.lang.PersistentArrayMap/create {:description "active event", :display-name "activeevent", :class-name "activeevent"}), "db2" #=(clojure.lang.PersistentArrayMap/create {:description "A database from IBM that serve a number of different operating system platforms.", :display-name "DB2", :class-name "db2"}), "abap_sap_central_services" #=(clojure.lang.PersistentArrayMap/create {:description "AS ABAP instance of an SAP system containing the enqueue server and the message server (AS = Application Server, ASCS = ABAP SAP Central Services). There can only be one such instance in the SAP system.", :display-name "ABAP SAP Central Services", :class-name "abap_sap_central_services"}), "tibco_resource" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Tibco application resources", :display-name "TibcoResource", :class-name "tibco_resource"}), "f5_ltm" #=(clojure.lang.PersistentArrayMap/create {:description "The F5 BIG-IP Local traffic manager software", :display-name "F5 BIG-IP LTM", :class-name "f5_ltm"}), "project_risk" #=(clojure.lang.PersistentArrayMap/create {:description "ProjectRisk Object contains information regarding the risk assessment of a project.", :display-name "ProjectRisk", :class-name "project_risk"}), "exchangeclientaccessserver" #=(clojure.lang.PersistentArrayMap/create {:description "The Client Access server is the server that users connect to with their mail client, mobile device, or web browser. The Client Access server handles all connections whether they come from an application such as Outlook, Outlook Express, or any other MAPI, POP3 or IMAP4 client. The Client Access server also handles connections made from mobile devices such as a Windows Mobile 5 Smartphone, or any other device using Exchange ActiveSync.  This role also provides Outlook Web Access (OWA).", :display-name "Exchange Client Access Server", :class-name "exchangeclientaccessserver"}), "dnszone" #=(clojure.lang.PersistentArrayMap/create {:display-name "DNS Zone", :class-name "dnszone"}), "awsprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Amazone Web Services Protocol", :display-name "AWS Protocol", :class-name "awsprotocol"}), "lpar" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe lpar", :display-name "Mainframe Logical Partition", :class-name "lpar"}), "dbsegment" #=(clojure.lang.PersistentArrayMap/create {:description "A database segment contains the component database and any utilities provided by the developers for the DBA's use in installing and filling that particular database.", :display-name "DB Segment", :class-name "dbsegment"}), "sybasedb" #=(clojure.lang.PersistentArrayMap/create {:description "Sybase Database", :display-name "Sybase DB", :class-name "sybasedb"}), "oc4jgroup" #=(clojure.lang.PersistentArrayMap/create {:description "Group of OC4J instances", :display-name "OC4J Group", :class-name "oc4jgroup"}), "iisvirtualdir" #=(clojure.lang.PersistentArrayMap/create {:description "IIS Virtual Dir", :display-name "IIS Virtual Dir", :class-name "iisvirtualdir"}), "directory_server" #=(clojure.lang.PersistentArrayMap/create {:description "A directory service is the software system that stores, organizes and provides access to information in a directory. A directory service is a shared information infrastructure for locating, managing, administering, and organizing common items and network resources, which can include volumes, folders, files, printers, users, groups, devices, telephone numbers and other objects.", :display-name "DirectoryServer", :class-name "directory_server"}), "maplayer" #=(clojure.lang.PersistentArrayMap/create {:description "map layer", :display-name "map layer", :class-name "maplayer"}), "ip_subnet" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an IP subnet in a network.  The network could be an IPv4 or an IPv6 network.  An instance of this class will exists for each IP subnet in a routing domain.", :display-name "IpSubnet", :class-name "ip_subnet"}), "it_process_record" #=(clojure.lang.PersistentArrayMap/create {:display-name "ItProcessRecord", :class-name "it_process_record"}), "exchangehubserver" #=(clojure.lang.PersistentArrayMap/create {:description "The Hub Transport role is responsible for all internal mail flow. This role is similar to the bridgehead server in an Exchange 2000/2003 organization.  The Hub Transport server is installed on member server(s) in an Active Directory domain. Because it is a member of an AD domain, all its configuration information is stored in AD and any other Hub Transport servers will get their configuration from AD.  ", :display-name "Exchange Hub Server", :class-name "exchangehubserver"}), "oracle_listener" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the Oracle TNS Listener", :display-name "Oracle TNS Listener", :class-name "oracle_listener"}), "BusinessService" #=(clojure.lang.PersistentArrayMap/create {:description "Obsolete class. Replaced by logical_application class", :display-name "Business Service View", :class-name "BusinessService"}), "service" #=(clojure.lang.PersistentArrayMap/create {:description "A Service is an abstract class which may represent an IT or Business Service, including Infrastructure Services which are delivered by IT in support of a Business Service.", :display-name "Service", :class-name "service"}), "vcloud_vdc" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Virtual Datacenter", :display-name "vCloud Virtual Datacenter", :class-name "vcloud_vdc"}), "person" #=(clojure.lang.PersistentArrayMap/create {:description "A person. Used as a contact, owner, etc.", :display-name "Person", :class-name "person"}), "cics_transaction" #=(clojure.lang.PersistentArrayMap/create {:description "A CICS transaction is a unit of application data processing (consisting of one or more application programs) that a single request initiates, often from a terminal.", :display-name "CICS Transaction", :class-name "cics_transaction"}), "location" #=(clojure.lang.PersistentArrayMap/create {:description "Location of devices and business organizations/people that support a function (i.e. data center, company/client site). Can vary from country to city or low level like building or room. It can be connected to devices and logical CIs representing end users or data center location. ", :display-name "Location", :class-name "location"}), "frontendserver" #=(clojure.lang.PersistentArrayMap/create {:description "The Front End Server is the core server role, and runs many basic Lync Server functions. The Front End Server, along with the Back End Servers that provide the database, is the only server role required to be in any Lync Server Enterprise Edition deployment.", :display-name "Front End Server", :class-name "frontendserver"}), "imsprogram" #=(clojure.lang.PersistentArrayMap/create {:description "CIT Represents a  Mainframe IMS Program. ", :display-name "IMS Program", :class-name "imsprogram"}), "tomcatcluster" #=(clojure.lang.PersistentArrayMap/create {:description "Apache Tomcat Cluster based on session replication", :display-name "Apache Tomcat Cluster", :class-name "tomcatcluster"}), "cics_group" #=(clojure.lang.PersistentArrayMap/create {:description "A CICS group is a set of related CICS resource definitions such as transactions, programs, map sets, and files.", :display-name "CICS Group", :class-name "cics_group"}), "send_connector" #=(clojure.lang.PersistentArrayMap/create {:description "CIT represents Send Connector - a logical gateway through which all outgoing messages are sent from the HUB.", :display-name "Send Connector", :class-name "send_connector"}), "ms_exchange_message_queue" #=(clojure.lang.PersistentArrayMap/create {:description "Provides properties for Microsoft Exchange queues", :display-name "Exchange Message queue", :class-name "ms_exchange_message_queue"}), "scsi_adapter" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the SCSI Adapter. If the isVirtual attribute set to true we assume it to be a Virtual SCSI Adapter.", :display-name "SCSI Adapter", :class-name "scsi_adapter"}), "sqlserverdistributor" #=(clojure.lang.PersistentArrayMap/create {:description "The Distributor is a database instance that acts as a store for replication specific data associated with one or more Publishers", :display-name "Sql Server Distributor", :class-name "sqlserverdistributor"}), "iisftpsite" #=(clojure.lang.PersistentArrayMap/create {:description "IIS FTP Site", :display-name "IIS FTP Site", :class-name "iisftpsite"}), "dbtablespace" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the amount of space required to store the data in a table", :display-name "DB Tablespace", :class-name "dbtablespace"}), "configuration" #=(clojure.lang.PersistentArrayMap/create {:description "all configuration types", :display-name "Configuration", :class-name "configuration"}), "j2eemanagedobject" #=(clojure.lang.PersistentArrayMap/create {:description "virtual class to all j2ee resources", :display-name "J2EE Managed Object", :class-name "j2eemanagedobject"}), "business_service" #=(clojure.lang.PersistentArrayMap/create {:description "Represents business or IT service. A business service is a service that a business provides to another business (B2B) or  that one organization provides to another within a business (e.g. payment processing).  An IT service is a business service that the IT organization provides to support business services or IT's own operations.", :display-name "BusinessService", :class-name "business_service"}), "lb" #=(clojure.lang.PersistentArrayMap/create {:description "Load Balancer device", :display-name "Load Balancer", :class-name "lb"}), "msmqroutinglink" #=(clojure.lang.PersistentArrayMap/create {:description "MSMQ Routing Link", :display-name "MSMQ Routing Link", :class-name "msmqroutinglink"}), "snmpprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "SNMP Protocol", :display-name "SNMP Protocol", :class-name "snmpprotocol"}), "action" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system action", :display-name "action", :class-name "action"}), "licenses_management_software" #=(clojure.lang.PersistentArrayMap/create {:description "License Management Software  Key Attributes:  1. Name (data_name) - Name of Licenses Management Software  2. Container (root_container) - Software's container, usually a Host  ", :display-name "Licenses Management Software", :class-name "licenses_management_software"}), "mainframe_ims_database" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe IMS Database", :display-name "IMS Database", :class-name "mainframe_ims_database"}), "activedirectorysystem" #=(clojure.lang.PersistentArrayMap/create {:description "Active Directory System collection of Forests, Domains and Domain Controllers.", :display-name "Active Directory System", :class-name "activedirectorysystem"}), "alteon_app_switch" #=(clojure.lang.PersistentArrayMap/create {:description "The Nortel Alteon application switch software", :display-name "Alteon application switch", :class-name "alteon_app_switch"}), "maplink" #=(clojure.lang.PersistentArrayMap/create {:description "map link", :display-name "map link", :class-name "maplink"}), "column" #=(clojure.lang.PersistentArrayMap/create {:display-name "column", :class-name "column"}), "vmware_das_config" #=(clojure.lang.PersistentArrayMap/create {:description "VMware DAS Config", :display-name "VMware DAS Config", :class-name "vmware_das_config"}), "management_processor" #=(clojure.lang.PersistentArrayMap/create {:description "Server management boards such as HP Remote Integrated Lights Out (RILO) boards", :display-name "Management Processor", :class-name "management_processor"}), "request_for_change" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "RequestForChange", :class-name "request_for_change"}), "membership" #=(clojure.lang.PersistentArrayMap/create {:display-name "Membership", :class-name "membership"}), "mqcluster" #=(clojure.lang.PersistentArrayMap/create {:description "An MQ Cluster provides a flexible approach to join multiple queue managers with minimal configuration. This allows multiple instances of the same service to be hosted through multiple queue managers which allows for higher performance, capacity and resiliency", :display-name "IBM MQ Cluster", :class-name "mqcluster"}), "domaincontrollerrole" #=(clojure.lang.PersistentArrayMap/create {:description "DomainController Role", :display-name "DomainControllerRole", :class-name "domaincontrollerrole"}), "ci_collection" #=(clojure.lang.PersistentArrayMap/create {:description "Generic logical collection of CIs.  One example usage for CiCollection would be to group business processes when no real sequencing is required between the processes.", :display-name "CiCollection", :class-name "ci_collection"}), "storageprocessor" #=(clojure.lang.PersistentArrayMap/create {:display-name "Storage Processor", :class-name "storageprocessor"}), "ldom_virtual_volume" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents LDOM Virtual Volume", :display-name "LDOM Virtual Volume", :class-name "ldom_virtual_volume"}), "ldom_resource" #=(clojure.lang.PersistentArrayMap/create {:description "Class is an abstract common parent for LDOM resources", :display-name "LDOM Resource", :class-name "ldom_resource"}), "rules" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system rule", :display-name "rules", :class-name "rules"}), "storagepool" #=(clojure.lang.PersistentArrayMap/create {:display-name "Storage Pool", :class-name "storagepool"}), "lease_contract" #=(clojure.lang.PersistentArrayMap/create {:description "Leasing has similarities and differences with long-term rental and hire-purchase agreements.Rent payments are used in all cases. though, there are differences between the three:", :display-name "LeaseContract", :class-name "lease_contract"}), "business_function" #=(clojure.lang.PersistentArrayMap/create {:description "A business function is composed of a logical set of ongoing activities or processes that sustain the organization's business objectives (i.e., producing a product, providing a service).  A business function can be managed but cannot be performed. Business functions, which describe what an organization does, can be decomposed into processes that describe how the work is accomplished.", :display-name "BusinessFunction", :class-name "business_function"}), "synch_unit_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "synch_unit_info", :class-name "synch_unit_info"}), "client_server" #=(clojure.lang.PersistentArrayMap/create {:description "The Client-Server relationship indicates the two CIs communicate with each other where one CI acts as a client while the other acts a server. ", :display-name "ClientServer", :class-name "client_server"}), "sybase" #=(clojure.lang.PersistentArrayMap/create {:description "Sybase", :display-name "Sybase", :class-name "sybase"}), "eum_links" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system CI Types ", :display-name "EUM Links", :class-name "eum_links"}), "cics_resource" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is an abstract class for all the CICS subsystem resources", :display-name "CICSResource", :class-name "cics_resource"}), "rack" #=(clojure.lang.PersistentArrayMap/create {:display-name "Rack", :class-name "rack"}), "hp_npar_config" #=(clojure.lang.PersistentArrayMap/create {:description "This class holds HP nPartition configuration parameters", :display-name "HP nPar Config", :class-name "hp_npar_config"}), "hypervisor" #=(clojure.lang.PersistentArrayMap/create {:description "Base class for different kinds of hypervisors (software that allows to host virtual machines)Represents the virtualization service provided by the Hypervisor, its properties and health. The Hypervisor is the link object between the virtual machine (a Node) and the physical host (a Node).", :display-name "Hypervisor", :class-name "hypervisor"}), "vcloudprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "VMware vCloud Protocol", :display-name "vCloud Protocol", :class-name "vcloudprotocol"}), "pnniconnection" #=(clojure.lang.PersistentArrayMap/create {:description "connect tow atm ports", :display-name "PNNI connection", :class-name "pnniconnection"}), "ip_service_endpoint" #=(clojure.lang.PersistentArrayMap/create {:description "Represents any kind of a network service end point based on a variety of protocols such as UDP or TCP or more specific ones such as SMTP, SNMP etc.  The class describes the IP address and network port a service end point is bound to and the type of protocol it uses to expose an end point.", :display-name "IpServiceEndpoint", :class-name "ip_service_endpoint"}), "callhome_event" #=(clojure.lang.PersistentArrayMap/create {:description "UD Agent call probe manager proactively, and probe manager generate an event CI", :display-name "CallHomeEvent", :class-name "callhome_event"}), "hp_nonstop" #=(clojure.lang.PersistentArrayMap/create {:description "HP NonStop system", :display-name "HP NonStop", :class-name "hp_nonstop"}), "ipfw" #=(clojure.lang.PersistentArrayMap/create {:description "fw in a trail", :display-name "IP Firewall", :class-name "ipfw"}), "siebel_component" #=(clojure.lang.PersistentArrayMap/create {:description "A process on the Siebel Application Server encapsulating some Siebel application functionality", :display-name "Siebel Component", :class-name "siebel_component"}), "mainframe_imsregion" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe IMS Region (address space)", :display-name "IMS Region", :class-name "mainframe_imsregion"}), "actioninstruction" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system dynamic instruction input, defines an action to be run in order to retrieve the available inputs (e.g. tql names)", :display-name "actioninstruction", :class-name "actioninstruction"}), "internalid" #=(clojure.lang.PersistentArrayMap/create {:display-name "internalid", :class-name "internalid"}), "eum_monitor" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system CI Types ", :display-name "EUM Monitor", :class-name "eum_monitor"}), "license_feature" #=(clojure.lang.PersistentArrayMap/create {:description "The Feature supplied by the license", :display-name "License Feature", :class-name "license_feature"}), "exchangeunifiedmessagingserver" #=(clojure.lang.PersistentArrayMap/create {:description "This server role enables Unified Messaging for an Exchange 2007 organization. Unified Messaging lets users access their Exchange 2007 mailbox over any telephone for e-mail, voice mail, fax messages, and calendaring and contact information.  The Unified Messaging role is responsible for merging VOIP infrastructure with Exchange organization. It provides the capability to:  - combined voice, fax, and mail in one inbox  - access to voice, fax and mail via multiple interfaces  ", :display-name "Exchange Unified Messaging Server", :class-name "exchangeunifiedmessagingserver"}), "ms_exchange_storage_group" #=(clojure.lang.PersistentArrayMap/create {:description "Exchange storage group - a logical container for Exchange databases and their associated system and transaction log files.", :display-name "Exchange Storage Group", :class-name "ms_exchange_storage_group"}), "sqlperformancemonitor" #=(clojure.lang.PersistentArrayMap/create {:description "Performance monitor constants describe Microsoft Windows NT Performance Monitor polling behavior", :display-name "SQL Performance Monitor", :class-name "sqlperformancemonitor"}), "dblink" #=(clojure.lang.PersistentArrayMap/create {:display-name "DB Link", :class-name "dblink"}), "db_controlfile" #=(clojure.lang.PersistentArrayMap/create {:description "db control file", :display-name "DB_Control-File", :class-name "db_controlfile"}), "sap_its_agate" #=(clojure.lang.PersistentArrayMap/create {:description "An SAP Internet Transaction Server component that establishes the connection to the R/3 system and performs processing of tasks that are required to move data between R/3 applications and the Internet ", :display-name "SAP ITS AGate", :class-name "sap_its_agate"}), "protocol" #=(clojure.lang.PersistentArrayMap/create {:description "An abstract class for all Protocol Dictionary classes", :display-name "protocol", :class-name "protocol"}), "fcmdb_conf_aggregation" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_conf_aggregation", :class-name "fcmdb_conf_aggregation"}), "managed_relationship" #=(clojure.lang.PersistentArrayMap/create {:description "All managed relationships", :display-name "Managed Relationship", :class-name "managed_relationship"}), "disk_device" #=(clojure.lang.PersistentArrayMap/create {:description "A DiskDevice is a peripheral device used to record and retrieve information. Main implementations are hard disks, floppy disks and optical discs. They are identified by device name on a given node e.g. /dev/sd0 in UNIX", :display-name "DiskDevice", :class-name "disk_device"}), "remedyprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Remedy Integration Protocol", :display-name "Remedy Protocol", :class-name "remedyprotocol"}), "function" #=(clojure.lang.PersistentArrayMap/create {:display-name "function", :class-name "function"}), "infrastructure_service" #=(clojure.lang.PersistentArrayMap/create {:description "An IT Service that is not directly used by the Business, but is required by the IT Service Provider so they can provide other IT Services. For example Directory Services, naming services, or communication services. Infrastructure service is a synonym for technical service in ITILv3.", :display-name "InfrastructureService", :class-name "infrastructure_service"}), "hp_complex" #=(clojure.lang.PersistentArrayMap/create {:description "Server complex is a union of all hardware within a cell-based server including all cells, I/O chassis, cables, cabinet hardware, fans, and power and utility components. In case of non-cellular system this CIT represents a server which runs vPars.", :display-name "HP Complex", :class-name "hp_complex"}), "mainframe_resource" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is an abstract class for all the Mainframe resources", :display-name "MainframeResource", :class-name "mainframe_resource"}), "windows_service" #=(clojure.lang.PersistentArrayMap/create {:description "Software that can be controlled by the Microsoft Management Console.", :display-name "WindowsService", :class-name "windows_service"}), "discoverysairesource" #=(clojure.lang.PersistentArrayMap/create {:description "Discovery Software Application Index File", :display-name "Discovery SAI File", :class-name "discoverysairesource"}), "interface" #=(clojure.lang.PersistentArrayMap/create {:description "Describes a logical interface (Note: This is NOT a physical interface card) that supports various data link layer and other higher layer protocols such as tunnels, mpls, frame, atm etc.", :display-name "Interface", :class-name "interface"}), "mqchinit" #=(clojure.lang.PersistentArrayMap/create {:description "MQ channel initiator on mainframe MQ subsystems", :display-name "IBM MQ Channel Initiator", :class-name "mqchinit"}), "websphereprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "WebSphere Protocol", :display-name "WebSphere Protocol", :class-name "websphereprotocol"}), "globalcatalogserver" #=(clojure.lang.PersistentArrayMap/create {:description "The global catalog is a distributed data repository that contains a searchable, partial representation of every object in every domain in a multidomain Active Directory forest.", :display-name "GlobalCatalogServer", :class-name "globalcatalogserver"}), "ms_exchange_role" #=(clojure.lang.PersistentArrayMap/create {:description "Role of exchange server in global scope. One exchange server can have several roles.  Server roles allow an administrator to split the functions of an Exchange server and place each role, or a combination of roles, on different servers in the organization.   This type is a common super-type for specific roles, which are:  - Edge Transport  - Hub Transport  - Client Access  - Mailbox  - Unified Messaging ", :display-name "Exchange role", :class-name "ms_exchange_role"}), "vmware_resource" #=(clojure.lang.PersistentArrayMap/create {:description "VMware Resource", :display-name "VMware Resource", :class-name "vmware_resource"}), "scheduler_job" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM scheduler job", :display-name "scheduler_job", :class-name "scheduler_job"}), "host_node" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a general purpose machine which has an IP address, such as Windows, Unix, Mainframe", :display-name "Computer", :class-name "host_node"}), "communicationserver" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT is an abstract CIT representing all communication servers of which Microsoft Lync Server is an example.", :display-name "Communication Server", :class-name "communicationserver"}), "impact_containment" #=(clojure.lang.PersistentArrayMap/create {:display-name "Impacted By (Directly)", :class-name "impact_containment"}), "cmdb_configuration_links" #=(clojure.lang.PersistentArrayMap/create {:description "cmdb configuration Relationships", :display-name "Cmdb Configuration Links", :class-name "cmdb_configuration_links"}), "database_instance" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the database schema", :display-name "Database Schema", :class-name "database_instance"}), "vcsgroup" #=(clojure.lang.PersistentArrayMap/create {:description "Collection of dependent or related resources to be managed as a single unit.  Key Attributes:  1. Name (data_name) - Name of cluster group  2. Container (root_container) - Parent container, i.e. clustered service ", :display-name "VCS Resource Group", :class-name "vcsgroup"}), "dns_server" #=(clojure.lang.PersistentArrayMap/create {:description "A DNS or a Domain Name Server is a registry system for electronic services and resources. The DNS translates domain names which human understand into the appropriate network or application address.      ", :display-name "DnsServer", :class-name "dns_server"}), "project" #=(clojure.lang.PersistentArrayMap/create {:description "Set of activities that are coordinated to produce a result.From ITILv3: A temporary Organization, with people and other Assets required to achieve an Objective or other Outcome. Each Project has a Lifecycle that typically includes initiation, Planning, execution, Closure etc. Projects are usually managed using a formal methodology such as PRINCE2.We do not model a project as a temporary organization. but the rest of the definition is relevant.", :display-name "Project", :class-name "project"}), "solaris_resource_pool" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Solaris Resource Pool which holds configuration information about the pool configured in Solaris Global Zone.  Resource pools enable separation of workloads so that workload consumption of certain resources does not overlap. This resource reservation helps to achieve predictable performance on systems with mixed workloads.", :display-name "Solaris Resource Pool", :class-name "solaris_resource_pool"}), "interfaceindex" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a unique number of an interface", :display-name "Interface Index", :class-name "interfaceindex"}), "vcloud_catalog" #=(clojure.lang.PersistentArrayMap/create {:description "vCloud Catalog", :display-name "vCloud Catalog", :class-name "vcloud_catalog"}), "folding_rules" #=(clojure.lang.PersistentArrayMap/create {:description "Amber folding rules", :display-name "Folding rules (Configuration Manager)", :class-name "folding_rules"}), "sap_process_step" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Process Step", :display-name "SAP Process Step", :class-name "sap_process_step"}), "product_model" #=(clojure.lang.PersistentArrayMap/create {:description "ProductModel holds all model information for all assets managed by AM, be that license or hardware. Each Asset is an instance of a specific ProductModel as documented by the relationship to Asset. The AssetModel also contains information about count of Licenses that are installed for use, and is documented via the relationship to SoftwareCountDefinition. A ProductModel may be aggregation of a number of ProductModels.", :display-name "ProductModel", :class-name "product_model"}), "printer" #=(clojure.lang.PersistentArrayMap/create {:description "Printer device", :display-name "Printer", :class-name "printer"}), "telnetprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Telnet Protocol", :display-name "Telnet Protocol", :class-name "telnetprotocol"}), "as400protocol" #=(clojure.lang.PersistentArrayMap/create {:description "AS400 Protocol", :display-name "AS400 Protocol", :class-name "as400protocol"}), "sapprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Protocol", :display-name "SAP Protocol", :class-name "sapprotocol"}), "statefulsessionbean" #=(clojure.lang.PersistentArrayMap/create {:description "EJB stateful", :display-name "Stateful Session Bean", :class-name "statefulsessionbean"}), "siebel_comp_grp" #=(clojure.lang.PersistentArrayMap/create {:description "An application running on the Siebel application server.", :display-name "Siebel Component Group", :class-name "siebel_comp_grp"}), "veritascluster" #=(clojure.lang.PersistentArrayMap/create {:description "Veritas cluster server provides a clustering technology that keeps server-based applications available, regardless of individual component failures", :display-name "Veritas Cluster", :class-name "veritascluster"}), "apachemodule" #=(clojure.lang.PersistentArrayMap/create {:description "Apache module", :display-name "Apache Module", :class-name "apachemodule"}), "monitor" #=(clojure.lang.PersistentArrayMap/create {:description "Monitoring CI Types.", :display-name "Monitor", :class-name "monitor"}), "vmware_host_resource" #=(clojure.lang.PersistentArrayMap/create {:description " VMware Host Resource represents a Virtual Kernel and Virtual Hardwar.   It includes the resources configuration for the Virtual Machine, such as memory limit, memory size, cpu reservation, cpu limit, VM uuid etc...    Key Attributes: 1. Name (data_name) - Name of Host Resource, would be the Guest Host name   2. Container (root_container) - Host Resource's container, usually a Host representing a Guest OS    ", :display-name "VMware Host Resource", :class-name "vmware_host_resource"}), "mainframe_system" #=(clojure.lang.PersistentArrayMap/create {:description "Abstract class representing all Mainframe Systems", :display-name "MainframeSystem", :class-name "mainframe_system"}), "cluster" #=(clojure.lang.PersistentArrayMap/create {:description "A Cluster is a system that is made up of two or more Nodes which operate together as an atomic, functional whole to increase the performance, resources, and/or reliability, availability, and serviceability. ", :display-name "Cluster", :class-name "cluster"}), "business_links" #=(clojure.lang.PersistentArrayMap/create {:description "business Relationships.", :display-name "Business Links", :class-name "business_links"}), "ldom_virtual_disk" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents LDOM Virtual Disk", :display-name "LDOM Virtual Disk", :class-name "ldom_virtual_disk"}), "ospf" #=(clojure.lang.PersistentArrayMap/create {:description "OSPF NETWORK ELEMENT", :display-name "OSPF", :class-name "ospf"}), "business_objective" #=(clojure.lang.PersistentArrayMap/create {:description "BusinessObjective contains information about the Business Objective, the satisfaction of which is monitored and ascertained through the associated KPIs.", :display-name "BusinessObjective", :class-name "business_objective"}), "supported_class_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "supported_class_config", :class-name "supported_class_config"}), "link" #=(clojure.lang.PersistentArrayMap/create {:display-name "Link", :class-name "link"}), "source" #=(clojure.lang.PersistentArrayMap/create {:display-name "source", :class-name "source"}), "replicated" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Replicated", :class-name "replicated"}), "server_automation_system" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a Server Automation System", :display-name "SASystem", :class-name "server_automation_system"}), "db2_ddf" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Distribute Data Facility, a mainframe DB2 component which provides the connectivity to and from other servers or clients over the network.", :display-name "Db2Ddf", :class-name "db2_ddf"}), "centralmanagementserver" #=(clojure.lang.PersistentArrayMap/create {:description "The Central Management Store is a centralized configuration database that is used to save configuration data for the entire Lync Server deployment. The job of the Central Management Server is to coordinate replication of configuration data to replica databases running on each machine in the topology as well as providing access to the master copy.", :display-name "Central Management Server", :class-name "centralmanagementserver"}), "hacmpresource" #=(clojure.lang.PersistentArrayMap/create {:description "Physical or logical entity managed by a cluster node. A resource provides a service to clients in a client/server environment", :display-name "HACMP Resource", :class-name "hacmpresource"}), "mainframe_startedtask" #=(clojure.lang.PersistentArrayMap/create {:description "This Class represents a Started Task on the Mainframe", :display-name "MainframeStartedTask", :class-name "mainframe_startedtask"}), "messagedrivenbean" #=(clojure.lang.PersistentArrayMap/create {:description "ejb messege driven", :display-name "Message Driven Bean", :class-name "messagedrivenbean"}), "condition" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system condition", :display-name "condition", :class-name "condition"}), "database" #=(clojure.lang.PersistentArrayMap/create {:description "A system that manages a collection of records arranged in a predefined structure and format allowing an efficient retrieval and search of data usually by key data items.", :display-name "Database", :class-name "database"}), "graphics_adapter" #=(clojure.lang.PersistentArrayMap/create {:description "Graphics adapter is an expansion card which generates a feed of output images to a display.", :display-name "GraphicsAdapter", :class-name "graphics_adapter"}), "environmental_sensor" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an environmental sensor on a network device.  Environmental sensors are components that measure environmental parameters such as temperature and voltage.", :display-name "EnvironmentalSensor", :class-name "environmental_sensor"}), "nfs" #=(clojure.lang.PersistentArrayMap/create {:display-name "NFS", :class-name "nfs"}), "sap_j2ee_app_server" #=(clojure.lang.PersistentArrayMap/create {:description "Represents an instance of the J2EE Application server", :display-name "SAP J2EE Application Server", :class-name "sap_j2ee_app_server"}), "triggers" #=(clojure.lang.PersistentArrayMap/create {:display-name "Triggers", :class-name "triggers"}), "netapp_filer" #=(clojure.lang.PersistentArrayMap/create {:display-name "NetApp Filer", :class-name "netapp_filer"}), "calculated_link" #=(clojure.lang.PersistentArrayMap/create {:display-name "Calculated Links", :class-name "calculated_link"}), "oracleappservicemanager" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite Service Manager", :display-name "Service Manager", :class-name "oracleappservicemanager"}), "inventory_scanner" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents the inventory scanner running software", :display-name "InventoryScanner", :class-name "inventory_scanner"}), "atmport" #=(clojure.lang.PersistentArrayMap/create {:description "atm port", :display-name "ATM Port", :class-name "atmport"}), "mediationserver" #=(clojure.lang.PersistentArrayMap/create {:description "Mediation Server is a necessary component for implementing Enterprise Voice and dial-in conferencing. Mediation Server translates signaling and, in some configurations, media between your internal Lync Server infrastructure and an Internet Protocol/Public Switched Telephone Network (IP-PSTN) gateway or a Session Initiation Protocol (SIP) trunk.", :display-name "Mediation Server", :class-name "mediationserver"}), "iseries_file" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an iSeries file.  A file is an object, of type *FILE, that contains data in the form of a database, device data, or a group of related records that are handled as a unit. For example :  database files.   ", :display-name "IseriesFile", :class-name "iseries_file"}), "maplinkmeta" #=(clojure.lang.PersistentArrayMap/create {:description "virtual map link", :display-name "map meta link", :class-name "maplinkmeta"}), "sqljobstep" #=(clojure.lang.PersistentArrayMap/create {:description "An action that the job takes on a database or a server. Every job must have at least one job step.", :display-name "SQL Job Step", :class-name "sqljobstep"}), "cics_program" #=(clojure.lang.PersistentArrayMap/create {:description "A CICS program is that portion of a run unit that is complete enough to be compiled separately. Typically, a program is one source file.", :display-name "CICS Program", :class-name "cics_program"}), "sqlserverpublication" #=(clojure.lang.PersistentArrayMap/create {:description "A publication is a collection of one or more articles from one database. An article identifies a database object that is included in a publication.", :display-name "SQL Server Publication", :class-name "sqlserverpublication"}), "discoverywizard" #=(clojure.lang.PersistentArrayMap/create {:description "Auto discovery entity that configure different discovery processes", :display-name "Auto Discovery Wizard", :class-name "discoverywizard"}), "db_redofile" #=(clojure.lang.PersistentArrayMap/create {:description "A transaction log that records data modifications made in the database.", :display-name "DB_Re-do File", :class-name "db_redofile"}), "layertwo" #=(clojure.lang.PersistentArrayMap/create {:description "the layertwo links are links discovered by the discover layer 2 service. the link represent a connection between switche to host (physical connection)", :display-name "Layer 2", :class-name "layertwo"}), "lyncserverrole" #=(clojure.lang.PersistentArrayMap/create {:description "Lync Server 2010 allows  role based deployment. During Lync Server 2010 installation user can select the components to be installed on a machine. The services installed on the Lync Server identify the role of the server.", :display-name "Lync Server Role", :class-name "lyncserverrole"}), "providerrepository" #=(clojure.lang.PersistentArrayMap/create {:display-name "providerrepository", :class-name "providerrepository"}), "dbtns" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the tnsnames on the local machine", :display-name "DB TNS names", :class-name "dbtns"}), "discoverymodule" #=(clojure.lang.PersistentArrayMap/create {:description "A discovery module that can contain several patterns that are needed for invocation", :display-name "Auto Discovery Module", :class-name "discoverymodule"}), "sunclusterresource" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents Sun Cluster Resource - physical or logical entity that is used by Data Services and managed by the cluster node.", :display-name "Sun Cluster Resource", :class-name "sunclusterresource"}), "configuration_item" #=(clojure.lang.PersistentArrayMap/create {:display-name "ConfigurationItem", :class-name "configuration_item"}), "layer2_connection" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a ISO Layer-2 connection between 2 or more interfaces.", :display-name "Layer2Connection", :class-name "layer2_connection"}), "ip_address" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the logical network identifier of a node on the network. An IP Address can represent either an IPv4 or an IPv6 address.", :display-name "IpAddress", :class-name "ip_address"}), "interface_aggregation" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the interface aggregation the way it is presented on the OS level.", :display-name "Interface Aggregation", :class-name "interface_aggregation"}), "ldom_vds" #=(clojure.lang.PersistentArrayMap/create {:description "Class represents LDOM Virtual Disk Service which allows sharing storage resources with other domains", :display-name "LDOM Virtual Disk Service", :class-name "ldom_vds"}), "webapplication" #=(clojure.lang.PersistentArrayMap/create {:description "Web application", :display-name "Web Application", :class-name "webapplication"}), "hierarchicalproperties" #=(clojure.lang.PersistentArrayMap/create {:description "node manual properties", :display-name "hierarchical properties", :class-name "hierarchicalproperties"}), "file" #=(clojure.lang.PersistentArrayMap/create {:description "An entity of data", :display-name "File", :class-name "file"}), "netappprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Protocol definition for connection to NetApp ONTAP (filers) and Managability (Operations Manager) APIs", :display-name "NetApp Protocol", :class-name "netappprotocol"}), "weblogicas" #=(clojure.lang.PersistentArrayMap/create {:description "The Weblogic Application Server", :display-name "Weblogic AS", :class-name "weblogicas"}), "executequeue" #=(clojure.lang.PersistentArrayMap/create {:description "executequeue", :display-name "J2EE Execute Queue", :class-name "executequeue"}), "j2ee_sap_central_services" #=(clojure.lang.PersistentArrayMap/create {:description "AS J2EE instance of an SAP system containing the enqueue server and the message server (AS = Application Server, ASCS = ABAP SAP Central Services). There can only be one such instance in the SAP system.", :display-name "J2EE SAP Central Services", :class-name "j2ee_sap_central_services"}), "sap_virus_scan" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Virus Scan Server", :display-name "SAP Virus Scan Server", :class-name "sap_virus_scan"}), "service_contract" #=(clojure.lang.PersistentArrayMap/create {:description "The service contract class represents all contracts that are service related in nature.  For example, service level agreement, operational level agreement, and underpinning contract are types of service contracts", :display-name "ServiceContract", :class-name "service_contract"}), "statelesssessionbean" #=(clojure.lang.PersistentArrayMap/create {:description "ejb stateless", :display-name "Stateless Session Bean", :class-name "statelesssessionbean"}), "iseries_library" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an iSeries library. Every iSeries object is contained in a library. A library is an object, of type *LIB, that contains a group of objects.   ", :display-name "IseriesLibrary", :class-name "iseries_library"}), "sysplex" #=(clojure.lang.PersistentArrayMap/create {:description "Mainframe sysplex", :display-name "Sysplex", :class-name "sysplex"}), "oracleias" #=(clojure.lang.PersistentArrayMap/create {:description "The Oracle IAS Application Server", :display-name "Oracle iAS", :class-name "oracleias"}), "sqlservermodule" #=(clojure.lang.PersistentArrayMap/create {:description "Represent the operating system services element that the SQL server is depend on. There are currently 4 modules in SQL server:MSSQLServer - the process that run the SQL Server, SQLServerAgent - Scheduling Agent, MSDTC - Distributed transaction engine, Microsoft Search - Full text indexing engine.", :display-name "SQL Server Module", :class-name "sqlservermodule"}), "source_query_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "source_query_config", :class-name "source_query_config"}), "ejb" #=(clojure.lang.PersistentArrayMap/create {:description "ejb component", :display-name "EJB", :class-name "ejb"}), "sunoneserver" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents an instance of Sun One Web Server", :display-name "SunOne", :class-name "sunoneserver"}), "business_unitlink" #=(clojure.lang.PersistentArrayMap/create {:description "link between related Business Entities", :display-name "Business Unit link", :class-name "business_unitlink"}), "mapgrouplink" #=(clojure.lang.PersistentArrayMap/create {:description "map group link", :display-name "map group link", :class-name "mapgrouplink"}), "mqtransmitqueue" #=(clojure.lang.PersistentArrayMap/create {:description "A Transmission Queue is a special purpose queue that transmits messages from one queue manager to another through MQ Channels. Remote queues use transmission queues to relay messages to the queue for which it is a remote", :display-name "IBM MQ Transmit Queue", :class-name "mqtransmitqueue"}), "business_element" #=(clojure.lang.PersistentArrayMap/create {:description "Business Element is a basic class for all components that support a particular business function, produce a product or provide a service that is visible to customers.", :display-name "BusinessElement", :class-name "business_element"}), "ms_exchange_link" #=(clojure.lang.PersistentArrayMap/create {:description "Contains properties about message-handling links between mail servers", :display-name "Exchange link", :class-name "ms_exchange_link"}), "traffic" #=(clojure.lang.PersistentArrayMap/create {:description "A traffic link represents all the traffic between two IP's (All protocols)", :display-name "Traffic", :class-name "traffic"}), "exchangemailserver" #=(clojure.lang.PersistentArrayMap/create {:description "Mailbox role holds the Exchange databases within which the user mailboxes are contained. It is also home to the Public Folder databases if you enabled Public Folders.", :display-name "Exchange Mail Server", :class-name "exchangemailserver"}), "eventrules" #=(clojure.lang.PersistentArrayMap/create {:description "A MAM event system rule", :display-name "eventrules", :class-name "eventrules"}), "cisco_css" #=(clojure.lang.PersistentArrayMap/create {:description "The Cisco Content service switch software", :display-name "Cisco CSS", :class-name "cisco_css"}), "display_monitor" #=(clojure.lang.PersistentArrayMap/create {:description "A monitor or display (also called screen or visual display unit) is an electronic visual display for computers", :display-name "DisplayMonitor", :class-name "display_monitor"}), "monitored_by" #=(clojure.lang.PersistentArrayMap/create {:description "Monitor system Relationships", :display-name "Monitored By", :class-name "monitored_by"}), "db_archivefile" #=(clojure.lang.PersistentArrayMap/create {:description "An archive-file object for a Microsoft SQL Server 2000 Analysis Services database contains the contents of the directory named the same as the database", :display-name "DB_Archive File", :class-name "db_archivefile"}), "mqsystemparameters" #=(clojure.lang.PersistentArrayMap/create {:description "Parameters for the MQ subsystem, as presented by the DISPLAY SYSTEM query.", :display-name "IBM MQ System Parameters", :class-name "mqsystemparameters"}), "tibco_ems_server" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a TIBCO EMS running software", :display-name "TibcoEmsServer", :class-name "tibco_ems_server"}), "switchrouter" #=(clojure.lang.PersistentArrayMap/create {:description "the switchrouter class represent a network element that his oid represent switch but have more then one ip addresses in diferent net addresses", :display-name "Switch Router", :class-name "switchrouter"}), "job" #=(clojure.lang.PersistentArrayMap/create {:description "An executable task at MAM scheduler", :display-name "job", :class-name "job"}), "netprinter" #=(clojure.lang.PersistentArrayMap/create {:description "A printer device, which serves the network's users", :display-name "Net Printer", :class-name "netprinter"}), "cics_region" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a mainframe CICS region", :display-name "CICSRegion", :class-name "cics_region"}), "cacmdbprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "CA CMDB Integration Protocol", :display-name "CA CMDB Protocol", :class-name "cacmdbprotocol"}), "sap_work_process" #=(clojure.lang.PersistentArrayMap/create {:description "A logical single-instance representation of a certain type of work process", :display-name "SAP Work Process", :class-name "sap_work_process"}), "storagearray" #=(clojure.lang.PersistentArrayMap/create {:display-name "Storage Array", :class-name "storagearray"}), "maintenance_contract" #=(clojure.lang.PersistentArrayMap/create {:description "Defines terms and conditions for the maintenance of hardware or software by commercial organizations (including prime contractors) on a one-time or continuing basis, without distinction as to the level of maintenance accomplished.", :display-name "MaintenanceContract", :class-name "maintenance_contract"}), "concentrator" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Concentrator", :class-name "concentrator"}), "messaging_server" #=(clojure.lang.PersistentArrayMap/create {:description "A client/server infrastructure that increases the interoperability, portability, and flexibility of an application by allowing the application to be distributed over multiple heterogeneous platforms. It reduces the complexity of developing applications that span multiple operating systems and network protocols by insulating the application developer from the details of the various operating system and network interfaces.", :display-name "MessagingServer", :class-name "messaging_server"}), "oracleappsresource" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle E-Business Suite Resource", :display-name "Oracle E-Business Suite Resource", :class-name "oracleappsresource"}), "snmp" #=(clojure.lang.PersistentArrayMap/create {:description "snmp agent", :display-name "SNMP", :class-name "snmp"}), "mapnode" #=(clojure.lang.PersistentArrayMap/create {:description "map node", :display-name "map node", :class-name "mapnode"}), "applicationresource" #=(clojure.lang.PersistentArrayMap/create {:description "An abstract class which refers to an application resource", :display-name "Application Resource", :class-name "applicationresource"}), "oracle" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle database", :display-name "Oracle", :class-name "oracle"}), "subchart" #=(clojure.lang.PersistentArrayMap/create {:display-name "subchart", :class-name "subchart"}), "discoveryresource" #=(clojure.lang.PersistentArrayMap/create {:description "Discovery Internal Configuration Resource", :display-name "Discovery Resource", :class-name "discoveryresource"}), "oracleasresource" #=(clojure.lang.PersistentArrayMap/create {:description "Oracle application server resource", :display-name "Oracle AS Resource", :class-name "oracleasresource"}), "kpi_objective" #=(clojure.lang.PersistentArrayMap/create {:description "A KPIObjective is a translation of business objectives into set of thresholds against which a particular KPI is measured. ", :display-name "KpiObjective", :class-name "kpi_objective"}), "jmsdestination" #=(clojure.lang.PersistentArrayMap/create {:description "jms destination", :display-name "JMS Destination", :class-name "jmsdestination"}), "fcport" #=(clojure.lang.PersistentArrayMap/create {:display-name "Fibre Channel Port", :class-name "fcport"}), "connection" #=(clojure.lang.PersistentArrayMap/create {:display-name "Connection", :class-name "connection"}), "iseries_job" #=(clojure.lang.PersistentArrayMap/create {:description "This Class represents a Job  on the Iseries Node", :display-name "IseriesJob", :class-name "iseries_job"}), "citrixclient" #=(clojure.lang.PersistentArrayMap/create {:display-name "CitrixClient", :class-name "citrixclient"}), "lyncpool" #=(clojure.lang.PersistentArrayMap/create {:description "A Lync Server pool is a collection of Lync Servers.  All Lync Servers in the pool run exactly the same services and one server in a pool of many can go down without detribalizing the pool. A pool is defined by a full qualified domain name.", :display-name "Lync Pool", :class-name "lyncpool"}), "user_software_utilization" #=(clojure.lang.PersistentArrayMap/create {:description "The user software utilization", :display-name "UserSoftwareUtilization", :class-name "user_software_utilization"}), "extended_property_link" #=(clojure.lang.PersistentArrayMap/create {:display-name "extended_property_link", :class-name "extended_property_link"}), "jmsresource" #=(clojure.lang.PersistentArrayMap/create {:description "virtual class to all j2ee resources", :display-name "JMS Resource", :class-name "jmsresource"}), "sap_app_server" #=(clojure.lang.PersistentArrayMap/create {:description "SAP Application Server", :display-name "SapApplicationServer", :class-name "sap_app_server"}), "federation_config" #=(clojure.lang.PersistentArrayMap/create {:display-name "federation_config", :class-name "federation_config"}), "zos" #=(clojure.lang.PersistentArrayMap/create {:description "This CIT represents a Mainframe zOS LPAR", :display-name "zOS", :class-name "zos"}), "chart" #=(clojure.lang.PersistentArrayMap/create {:display-name "chart", :class-name "chart"}), "communication_endpoint" #=(clojure.lang.PersistentArrayMap/create {:description "A communication point from which data can be sent/received or services can be consumed. Examples: TCP/UDP port, URL, IPAddress", :display-name "CommunicationEndpoint", :class-name "communication_endpoint"}), "application_system" #=(clojure.lang.PersistentArrayMap/create {:description "The super class of complex systems like ERP, CRM or a Call-Center. These systems usually encompass a lot of RunningSoftware and maybe also Nodes. The complex system and its components are discoverable: the user doesn't need to manually define the scope like in the case of Application. From a management perspective all the components are managed as a single system, e.g. the user can define an authorization rule and it is enforced by all the components of the complex system. ", :display-name "ApplicationSystem", :class-name "application_system"}), "siebel_gateway" #=(clojure.lang.PersistentArrayMap/create {:description "A coordinating server, which routes requests to the correct component", :display-name "Siebel Gateway", :class-name "siebel_gateway"}), "as400_node" #=(clojure.lang.PersistentArrayMap/create {:description "Represents an IBM Iseries ", :display-name "iSeries", :class-name "as400_node"}), "dblinkobj" #=(clojure.lang.PersistentArrayMap/create {:description "object represent the dblinkobj", :display-name "DB Link Object", :class-name "dblinkobj"}), "datacenter" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a Data center entity", :display-name "Datacenter", :class-name "datacenter"}), "terminalserver" #=(clojure.lang.PersistentArrayMap/create {:description "A terminal server device.", :display-name "Terminal Server", :class-name "terminalserver"}), "hp_vpar_config" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents HP virtual partition (vPar) configuration", :display-name "HP vPar Config", :class-name "hp_vpar_config"}), "business_transaction" #=(clojure.lang.PersistentArrayMap/create {:description "An end-to-end service provided to end-users or to other related applications (e.g. stock trade, account login, product purchase or billing inquiry), in the IT realm will be provided by an application. Each business transaction has a unique profile that contains a business context (i.e. activity type, user, time and location, etc.) and a technical profile.", :display-name "BusinessTransaction", :class-name "business_transaction"}), "sqlserverresource" #=(clojure.lang.PersistentArrayMap/create {:description "Different internal SQL Server issues regarding replication", :display-name "SQL Server Resource", :class-name "sqlserverresource"}), "node_element" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a logical or physical part of a Node. The element might be virtualized by a virtualization software. Examples: DiskDrive, CPU, Blade, PhysicalPort, FileSystem, Process, InstalledSoftware ", :display-name "NodeElement", :class-name "node_element"}), "tibco_administration_domain" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents a TIBCO BusinessWorks Administration Domain", :display-name "TibcoAdministrationDomain", :class-name "tibco_administration_domain"}), "discoverytql" #=(clojure.lang.PersistentArrayMap/create {:description "Represents a Discovery TQL deployed in the system", :display-name "Discovery TQL", :class-name "discoverytql"}), "key" #=(clojure.lang.PersistentArrayMap/create {:display-name "key", :class-name "key"}), "xen_domain_config" #=(clojure.lang.PersistentArrayMap/create {:description "This class represents the Xen domain configuration", :display-name "Xen domain config", :class-name "xen_domain_config"}), "fcmdb_info" #=(clojure.lang.PersistentArrayMap/create {:display-name "fcmdb_info", :class-name "fcmdb_info"}), "dbjob" #=(clojure.lang.PersistentArrayMap/create {:description "A job is a specified series of operations performed sequentially by the database manager.", :display-name "DB Job", :class-name "dbjob"}), "problem" #=(clojure.lang.PersistentArrayMap/create {:description "", :display-name "Problem", :class-name "problem"}), "mqchannel" #=(clojure.lang.PersistentArrayMap/create {:description "IBM MQ Channels are required by Queue Managers to communicate with other Queue Managers. Channels are uni-directional and bi-directional communication (such as a request-response system) would require a second channel to return data. A channel will send or receive data on a specific port on a TCP/IP network", :display-name "IBM MQ Channel", :class-name "mqchannel"}), "ldapprotocol" #=(clojure.lang.PersistentArrayMap/create {:description "Protocol for Active Directory or general LDAP", :display-name "LDAP Protocol", :class-name "ldapprotocol"}), "object" #=(clojure.lang.PersistentArrayMap/create {:display-name "Object", :class-name "object"}), "ibmhttpserver" #=(clojure.lang.PersistentArrayMap/create {:description "IBM HTTP Server (IHS) which is based on the Apache HTTP Server that runs on AIX, HP-UX, Linux, Solaris, Windows NT, and z/OS", :display-name "IBM HTTP Server", :class-name "ibmhttpserver"}), "webvirtualhost" #=(clojure.lang.PersistentArrayMap/create {:description "Web Server Virtual Host", :display-name "Web Server Virtual Host", :class-name "webvirtualhost"}), "sea_adapter" #=(clojure.lang.PersistentArrayMap/create {:description "Represents the IBM SEA", :display-name "SEA Adapter", :class-name "sea_adapter"}), "managed_object" #=(clojure.lang.PersistentArrayMap/create {:description "all managed object types", :display-name "Managed Object", :class-name "managed_object"})}, :job-by-id {"VMware ESX Topology by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Topology by VIM", :display-name nil, :description "", :parameters (), :pattern-id "VMware_ESX_Topology_by_VIM", :trigger "vmware_esx"}), "SQLDiscoveryTutorial" #=(clojure.lang.PersistentArrayMap/create {:id "SQLDiscoveryTutorial", :display-name nil, :description "", :parameters (), :pattern-id "SQLDiscoveryTutorial", :trigger "sqlServer"}), "JBoss Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "JBoss Connections by JMX", :display-name "JEE JBoss Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_JBoss_Connection", :trigger "rmi_ports"}), "Range IPs by NMAP" #=(clojure.lang.PersistentArrayMap/create {:id "Range IPs by NMAP", :display-name "Range IPs by nmap", :description "", :parameters (), :pattern-id "IpRange_by_nmap", :trigger "probe"}), "Oracle Applications by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Applications by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "OracleApps", :trigger "oracle_database"}), "SAP Java Topology by HTTP" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by HTTP", :display-name nil, :description "", :parameters (), :pattern-id "sap_java_topology_by_http", :trigger "sap_http_endpoints"}), "Siebel Gateway Connection" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Gateway Connection", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)", :trigger "siebel_ports_or_gtwy"}), "Sun Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Sun Cluster by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Sun_Cluster_by_Shell", :trigger "sun_cluster_node_shell"}), "SAP ITS by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ITS by NTCMD", :display-name "SAP ITS by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SAP_Dis_ITS", :trigger "sap_its_process"}), "Microsoft Exchange Connection by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Connection by WMI", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Connection_by_WMI", :trigger "ms_exchange_process_and_wmi"}), "Merge VLANs by Ports" #=(clojure.lang.PersistentArrayMap/create {:id "Merge VLANs by Ports", :display-name nil, :description "", :parameters (), :pattern-id "Merge VLANs", :trigger "MergeVLANs"}), "MS NLB by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "MS NLB by NTCMD", :display-name "MS NLB by NTCMD or UDA", :description "", :parameters (), :pattern-id "MS NLB by NTCMD", :trigger "ntcmd_with_2_IP"}), "Oracle LMS Data Collection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle LMS Data Collection by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "Oracle_LMS_Data_Collection", :trigger "oracle_database"}), "Red Hat Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Red Hat Cluster by Shell", :display-name nil, :description "Discovers Red Hat Cluster information", :parameters (), :pattern-id "red_hat_cluster_by_shell", :trigger "redhat_cluster_running_software"}), "Microsoft Exchange Connection by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Connection by NTCMD", :display-name "Microsoft Exchange Connection by NTCMD or UDA", :description "", :parameters (), :pattern-id "ms_exchange_connection_by_ntcmd", :trigger "ms_exchange2007_process_and_ntcmd"}), "Host Applications by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by SNMP", :display-name "Host Applications by SNMP", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "SNMP_HR_All", :trigger "snmp"}), "Microsoft Message Queue Topology by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Message Queue Topology by NTCMD", :display-name "Microsoft Message Queue Topology by NTCMD or UDA", :description "", :parameters (), :pattern-id "microsoft_mq_ntcmd", :trigger "ntcmd_msmq"}), "MSSQL Server Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MSSQL Server Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_MsSql", :trigger "sql_db_port_sa"}), "Mainframe topology by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe topology by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "Mainframe_topology_by_SNMP", :trigger "ip_of_mainframe_or_lpar"}), "Xen Topology by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Xen Topology by TTY", :display-name "Xen and KVM by Shell", :description "", :parameters (), :pattern-id "Xen_by_TTY", :trigger "xen_unix_with_shell"}), "TIBCO EMS by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TIBCO EMS by Shell", :display-name nil, :description "", :parameters (), :pattern-id "tibco_ems_by_shell", :trigger "tibco_ems"}), "MQ by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MQ by Shell", :display-name nil, :description "", :parameters (), :pattern-id "MQ_Topology", :trigger "shell_on_mq_host"}), "Oracle VM Server for SPARC Technology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle VM Server for SPARC Technology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "LDOM_by_shell", :trigger "ldom_control_domain_by_shell"}), "Cisco CSS by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Cisco CSS by SNMP", :display-name "Cisco CSS by SNMP", :description nil, :parameters (), :pattern-id "Cisco_CSS_by_SNMP", :trigger "snmp_of_cisco_css"}), "DB2 Universal Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "DB2 Universal Database Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_DB2", :trigger "db2_db_port_sa"}), "Layer2 by NNM" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 by NNM", :display-name nil, :description "", :parameters (), :pattern-id "NNM_Integration", :trigger "ip"}), "Import CIs from ARIS" #=(clojure.lang.PersistentArrayMap/create {:id "Import CIs from ARIS", :display-name nil, :description "", :parameters (), :pattern-id "ARIS_To_UCMDB", :trigger "probe"}), "Oracle Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Database Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_Oracle", :trigger "oracle_db_port_sa"}), "SAP Solution Manager Topology by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Solution Manager Topology by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_SolMan_Topology", :trigger "sap_solman_connected"}), "Vista Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Vista Integration by SQL", :display-name nil, :description "", :parameters (), :pattern-id "Aperture_Vista_by_SQL", :trigger "aperture_vista_db"}), "J2EE Weblogic by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic by Shell", :display-name "JEE Weblogic by Shell", :description "", :parameters (), :pattern-id "WebLogic_By_Shell", :trigger "weblogic_by_shell"}), "Command runner" #=(clojure.lang.PersistentArrayMap/create {:id "Command runner", :display-name nil, :description "", :parameters (), :pattern-id "command_runner", :trigger nil}), "iSeries Resources" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Resources", :display-name "IBM i Resources", :description "", :parameters (), :pattern-id "iSeries Resources by EView", :trigger "eview_iseries_agent"}), "MaxDb by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MaxDb by Shell", :display-name nil, :description "", :parameters (), :pattern-id "MaxDb by Shell", :trigger "maxdb"}), "MySQL by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MySQL by Shell", :display-name nil, :description "Discovers MySQL instances and replication topology", :parameters (), :pattern-id "MySQL by shell", :trigger "mysql"}), "Network Connectivity Data Analyzer" #=(clojure.lang.PersistentArrayMap/create {:id "Network Connectivity Data Analyzer", :display-name nil, :description "", :parameters (), :pattern-id "Network_Connectivity_Data_Analyzer", :trigger "local"}), "Blade Server by IBM Systems Director REST API" #=(clojure.lang.PersistentArrayMap/create {:id "Blade Server by IBM Systems Director REST API", :display-name nil, :description "", :parameters (), :pattern-id "blade_servers_by_ibm_director_api", :trigger "ibm_systems_director"}), "Host Resources and Applications by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by SNMP", :display-name "Host Resources by SNMP", :description nil, :parameters (), :pattern-id "SNMP_HR_All", :trigger "snmp"}), "Siebel DB by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel DB by NTCMD", :display-name "Siebel DB by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SIEBEL_DIS_DB_NT", :trigger "siebel_appserver_nt"}), "VMware VirtualCenter Connection by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Connection by VIM", :display-name "VMware vCenter Connection by VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Connection_by_VIM", :trigger "vmware_vcenter_connection"}), "IBM Systems Director TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Systems Director TCP Ports", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Host Connection to AS400" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection to AS400", :display-name nil, :description "", :parameters (), :pattern-id "AS400_NET_Dis_Connection", :trigger "ip_with_as400_or_without_host"}), "IBM LPAR And VIO Server Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IBM LPAR And VIO Server Topology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "IBM_LPAR_VIO_BY_SHELL", :trigger "ibm_lpar_or_vio_trigger_tql"}), "Storage Devices Topology by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage Devices Topology by CIM", :display-name "Storage Devices Topology by CIM", :description "", :parameters (), :pattern-id "Storage_Devices_Topology_by_CIM", :trigger "smis_topology"}), "Host Resources and Applications by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by Shell", :display-name "Host Resources by Shell", :description nil, :parameters (), :pattern-id "TTY_HR_All", :trigger "host_shell"}), "HP nPartitions by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP nPartitions by Shell", :display-name "HP nPars and vPars by Shell", :description "", :parameters (), :pattern-id "hp_npar_by_shell", :trigger "npartitions_host_shell"}), "J2EE JBoss by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE JBoss by Shell", :display-name "JEE JBoss by Shell", :description "", :parameters (), :pattern-id "JBoss_By_Shell", :trigger "jboss_by_shell"}), "Inventory Discovery by Scanner" #=(clojure.lang.PersistentArrayMap/create {:id "Inventory Discovery by Scanner", :display-name nil, :description "", :parameters (), :pattern-id "InventoryDiscoveryByScanner", :trigger "scanner_shell"}), "JEE Glassfish by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "JEE Glassfish by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Glassfish_By_Shell", :trigger "glassfish_by_shell_and_port"}), "MySQL Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MySQL Connection by SQL", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :pattern-id "SQL_NET_Dis_Connection_MySql", :trigger "mysql_db_port_sa"}), "IHS Websphere Plugin by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IHS Websphere Plugin by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "IHS_Dis_WebspherePlugin", :trigger "host_ihs_shell"}), "IP Traffic by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "IP Traffic by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_ServicesConnectivity", :trigger "local"}), "J2EE Weblogic by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic by JMX", :display-name "JEE Weblogic by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebLogic", :trigger "weblogic_admin_server"}), "DB2 Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "DB2 Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_Db2", :trigger "db2withuser"}), "IBM SVC by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "IBM SVC by CIM", :display-name nil, :description "", :parameters (), :pattern-id "ibm_svc_by_cim", :trigger "ibm_svc_ports"}), "Microsoft Exchange Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "ms_exchange_topology_by_ldap", :trigger "trigger_domainctl_ldap"}), "Oracle RAC Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle RAC Topology by Shell", :display-name nil, :description "Discovers Oracle RAC Topology by Shell", :parameters (), :pattern-id "Oracle_RAC_Topology_by_Shell", :trigger "oracle_with_full_listeners"}), "Host Connection by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by PowerShell", :display-name nil, :description "", :parameters (), :pattern-id "PowerShell_Host_Connection", :trigger "ip_with_powershell_or_without_host"}), "Webservice Connections by UDDI Registry" #=(clojure.lang.PersistentArrayMap/create {:id "Webservice Connections by UDDI Registry", :display-name "Web Service Connections by UDDI Registry", :description nil, :parameters (), :pattern-id "UDDI_Registry_Connection", :trigger "local"}), "Oracle Config Files by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Config Files by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "CF_Oracle", :trigger "oracle_database"}), "Oracle Listeners by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Listeners by Shell", :display-name nil, :description "Discovers Oracle TNS Listener by Shell", :parameters (), :pattern-id "Oracle_Listeners_by_Shell", :trigger "rac_oracledb_with_shell"}), "SANscreen Integration by WebService" #=(clojure.lang.PersistentArrayMap/create {:id "SANscreen Integration by WebService", :display-name nil, :description "", :parameters (), :pattern-id "SANscreen_Discovery", :trigger "sanscreen_server"}), "IP MAC Harvesting by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "IP MAC Harvesting by SNMP", :display-name nil, :description "", :parameters (), :pattern-id "IP_MAC_Harvesting_By_SNMP", :trigger "snmp_with_arp_cache"}), "Host Resources and Applications by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by WMI", :display-name "Host Resources by WMI", :description nil, :parameters (), :pattern-id "WMI_HR_All", :trigger "wmi"}), "DNS Zone by Nslookup" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Zone by Nslookup", :display-name "DNS Zone by nslookup", :description "", :parameters (), :pattern-id "DNS_Zone", :trigger "dns_server_shell"}), "Sybase Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Sybase Database Connection by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_NET_Dis_Connection_Sybase", :trigger "sybase_db_port_sa"}), "Databases TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "Databases TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :type "string", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "SAP Solution Manager by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Solution Manager by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_SolutionManager", :trigger "sap_solman_connected"}), "MS Cluster by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "MS Cluster by NTCMD", :display-name "MS Cluster by NTCMD or UDA", :description nil, :parameters (), :pattern-id "MS_Cluster_Topology", :trigger "ntcmd_on_mscs"}), "Update UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Update UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "UpdateUDAgent", :trigger "node_with_udagent"}), "Link DB Datafiles And Clustered FS" #=(clojure.lang.PersistentArrayMap/create {:id "Link DB Datafiles And Clustered FS", :display-name nil, :description "", :parameters (), :pattern-id "Link DB Datafiles With Clustered FS", :trigger "link_datafile_and_clustered_fs"}), "Siebel DB by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel DB by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_DB_UNIX", :trigger "siebel_appserver_shell"}), "Inventory Discovery by Manual Scanner Deployment" #=(clojure.lang.PersistentArrayMap/create {:id "Inventory Discovery by Manual Scanner Deployment", :display-name nil, :description "", :parameters (), :pattern-id "InventoryDiscoveryByManualScannerDeployment", :trigger "probe"}), "TIBCO BusinessWorks by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TIBCO BusinessWorks by Shell", :display-name nil, :description "", :parameters (), :pattern-id "tibco_bw_by_shell", :trigger "tibco_bw"}), "Microsoft SharePoint Topology" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft SharePoint Topology", :display-name nil, :description "", :parameters (), :pattern-id "ms_sharepoint_by_shell", :trigger "sharepoint_application_agents"}), "Class B IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Class B IPs by ICMP", :display-name nil, :description "Performs an IP ping sweep on class B networks", :parameters (), :pattern-id "ICMP_NET_Dis_IpNetwork", :trigger "network_B"}), "Host Applications by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by Shell", :display-name "Host Applications by Shell", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery. For Windows machines only Local Users are discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "TTY_HR_All", :trigger "host_shell"}), "ECC Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "ECC Integration by SQL", :display-name nil, :description "", :parameters (), :pattern-id "ECC_Discovery", :trigger "ECC_OracleDB"}), "Active Directory Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Active Directory Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "LDAP_Active_Directory_Topology", :trigger "trigger_domainctl_ldap"}), "HP Network Automation by Java" #=(clojure.lang.PersistentArrayMap/create {:id "HP Network Automation by Java", :display-name "HP Network Automation by Java", :description "", :parameters (), :pattern-id "HP_Network_Automation_by_Java", :trigger "ip"}), "Veritas Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Veritas Cluster by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "Veritas_Cluster_Topology", :trigger "shell_of_veritas_cs"}), "HACMP Application Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "HACMP Application Discovery", :display-name nil, :description "", :parameters (), :pattern-id "TTY_HACMP_Applications", :trigger "shell_in_HACMP_cluster"}), "VMware ESX Topology by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Topology by CIM", :display-name "VMware ESX Topology by CIM", :description "", :parameters (), :pattern-id "VMware_ESX_Topology_by_CIM", :trigger "esx_topology_by_cim"}), "Hyper-V Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Hyper-V Topology by Shell", :display-name "Hyper-V Topology by Shell", :description "", :parameters (), :pattern-id "hyperv_topology_by_shell", :trigger "ntcmd_on_hyperv_host"}), "Class C IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Class C IPs by ICMP", :display-name nil, :description "Performs an IP ping sweep on class C networks", :parameters (), :pattern-id "ICMP_NET_Dis_IpNetwork", :trigger "network_C"}), "Sybase Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Sybase Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_Sybase", :trigger "sybase_db"}), "Oracle VM for x86 by Manager Main CLI" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle VM for x86 by Manager Main CLI", :display-name "Oracle VM for x86 by Manager Main CLI", :description "", :parameters (), :pattern-id "oracle_vm_manager_by_maincli", :trigger "oracle_vm_manager_with_ssh_endpoint"}), "Import from Excel Sample" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Excel Sample", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "file_name", :type "string", :description "The location of Excel (xls, xlsx) file. The script does NOT handle multiple files at once so enter the full path to single file."})), :pattern-id "XLS_Parser", :trigger nil}), "J2EE WebSphere Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere Connections by JMX", :display-name "JEE WebSphere Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebSphere_Connection", :trigger "websphere_ports"}), "Import from Properties file" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Properties file", :display-name nil, :description "", :parameters (), :pattern-id "Import_Properties_file", :trigger nil}), "Webservices by UDDI Registry" #=(clojure.lang.PersistentArrayMap/create {:id "Webservices by UDDI Registry", :display-name "Web Services by UDDI Registry", :description nil, :parameters (), :pattern-id "UDDI_Registry", :trigger "uddiregistry"}), "SAP Applications by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Applications by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_Applications", :trigger "sap_as_connected"}), "SAP ABAP Topology by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ABAP Topology by SAP JCO", :display-name nil, :description "", :parameters (), :pattern-id "SAP_Dis_Site_AS", :trigger "sap_as_connected"}), "Microsoft Exchange Topology by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by PowerShell", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Topology_by_PowerShell", :trigger "ms_exchange_process_and_powershell"}), "Oracle TNS Names by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle TNS Names by LDAP", :display-name nil, :description nil, :parameters (), :pattern-id "oracle_tns_names_by_ldap", :trigger "trigger_domainctl_ldap"}), "Host Applications by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by WMI", :display-name "Host Applications by WMI", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "WMI_HR_All", :trigger "wmi"}), "HP NonStop Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP NonStop Topology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "hp_nonstop_topology_by_shell", :trigger "hp_nonstop_shell"}), "Host Applications by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by PowerShell", :display-name "Host Applications by PowerShell", :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "PowerShell_HR_All", :trigger "host_powershell"}), "vCloud Director by vCloud API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud Director by vCloud API", :display-name nil, :description "", :parameters (), :pattern-id "vCloud_Director_by_vCloud_API", :trigger "vcloud_director_on_host_with_ip"}), "Siebel Application Server Configuration" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Application Server Configuration", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_APP_SERVER_CONFIG", :trigger "siebel_as_shell"}), "SSL Certificate Discovery by HTTPS" #=(clojure.lang.PersistentArrayMap/create {:id "SSL Certificate Discovery by HTTPS", :display-name "SSL Certificate Discovery by HTTPS", :description "", :parameters (), :pattern-id "ssl_certificate_by_https", :trigger "ssl_certificate_discovery"}), "Layer2 Topology VLAN based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology VLAN based by SNMP", :display-name "Layer2 Topology VLAN-based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_Dis_L2_Vlan", :trigger "catalyst_vlan_with_bridge"}), "NetApp Filer by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "NetApp Filer by WebServices", :display-name nil, :description "", :parameters (), :pattern-id "NetApp_Filer_by_WebServices", :trigger "NetApp Filer"}), "Range IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Range IPs by ICMP", :display-name nil, :description "", :parameters (), :pattern-id "ICMP_NET_Dis_IpRange", :trigger "probe"}), "Layer 2 Topology by CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Layer 2 Topology by CiscoWorks LMS", :display-name nil, :description "", :parameters (), :pattern-id "CiscoWorks_Layer2", :trigger "CiscoWorks Campus DB Port"}), "Process Layer2 Saved Files" #=(clojure.lang.PersistentArrayMap/create {:id "Process Layer2 Saved Files", :display-name nil, :description "", :parameters (), :pattern-id "processLayer2Files", :trigger "local"}), "Collect Network Data by NetFlow" #=(clojure.lang.PersistentArrayMap/create {:id "Collect Network Data by NetFlow", :display-name nil, :description nil, :parameters (), :pattern-id "NetFlow_StartCollector", :trigger "local"}), "AWS by Web Services" #=(clojure.lang.PersistentArrayMap/create {:id "AWS by Web Services", :display-name nil, :description "", :parameters (), :pattern-id "AWS_by_WebServices", :trigger "probe"}), "Hyper-V Topology by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Hyper-V Topology by WMI", :display-name "Hyper-V Topology by WMI", :description "", :parameters (), :pattern-id "hyperv_topology_by_wmi", :trigger "wmi_on_hyperv_host"}), "Microsoft Exchange Topology by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by WMI", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Topology_by_WMI", :trigger "ms_exchange_server_and_host_and_wmi"}), "TCP data by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "TCP data by SNMP", :display-name "TCP Data by SNMP", :description "Collects network data by SNMP", :parameters (), :pattern-id "tcp_discovery_by_snmp", :trigger "host_snmp"}), "Webserver by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Webserver by Shell", :display-name "Web Server by Shell", :description nil, :parameters (), :pattern-id "Apache", :trigger "apache_shell"}), "Alteon application switch by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Alteon application switch by SNMP", :display-name "Alteon application switch by SNMP", :description nil, :parameters (), :pattern-id "Alteon_app_switch_by_SNMP", :trigger "snmp_of_alteon"}), "F5 BIG-IP LTM by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "F5 BIG-IP LTM by SNMP", :display-name "F5 BIG-IP LTM by SNMP", :description nil, :parameters (), :pattern-id "F5_BIGIP_LTM_by_SNMP", :trigger "snmp_of_f5"}), "Microsoft Exchange Topology by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by NTCMD", :display-name "Microsoft Exchange Topology by NTCMD or UDA", :description "", :parameters (), :pattern-id "ms_exchange_topology_by_ntcmd", :trigger "ms_exchange_server2007_and_host_and_ntcmd"}), "VMware ESX Connection by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Connection by VIM", :display-name nil, :description "", :parameters (), :pattern-id "VMware_ESX_Connection_by_VIM", :trigger "vmware_esx_process_on_host"}), "Apache Tomcat by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Apache Tomcat by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "ApacheTomcat_Topology", :trigger "tomcat_by_shell"}), "Host Connection by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Host_Connection_By_Shell", :trigger "ip_with_shell_or_without_host"}), "Import from CSV file" #=(clojure.lang.PersistentArrayMap/create {:id "Import from CSV file", :display-name nil, :description "", :parameters (), :pattern-id "Import_CSV", :trigger nil}), "VMware VirtualCenter Connection by WMI and VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Connection by WMI and VIM", :display-name "VMware vCenter Connection by WMI and VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Connection_by_WMI_and_VIM", :trigger "vmware_virtualcenter_process_with_wmi"}), "Update Ids in NNM" #=(clojure.lang.PersistentArrayMap/create {:id "Update Ids in NNM", :display-name nil, :description "", :parameters (), :pattern-id "NNM_Update_Ids", :trigger "ip"}), "File Monitor by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "File Monitor by Shell", :display-name nil, :description "", :parameters (), :pattern-id "FILE_Mon", :trigger nil}), "HACMP Topology Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "HACMP Topology Discovery", :display-name nil, :description "", :parameters (), :pattern-id "TTY_HACMP_Topology", :trigger "shell_not_ntcmd_HACMP"}), "Call Home Processing" #=(clojure.lang.PersistentArrayMap/create {:id "Call Home Processing", :display-name "Call Home Processing", :description "", :parameters (), :pattern-id "CallHomeProcessing", :trigger "Inventory_Discovery_Trigger"}), "Uninstall UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Uninstall UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "UninstallUDAgent", :trigger "node_with_udagent"}), "Dynamic Credential Sample" #=(clojure.lang.PersistentArrayMap/create {:id "Dynamic Credential Sample", :display-name nil, :description "", :parameters (), :pattern-id "DynamicCredentialSample", :trigger nil}), "Host Resources and Applications by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by PowerShell", :display-name "Host Resources by PowerShell", :description "", :parameters (), :pattern-id "PowerShell_HR_All", :trigger "host_powershell"}), "TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Potential Servers by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Potential Servers by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_Potential_Services", :trigger nil}), "WebServer Detection using TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "WebServer Detection using TCP Ports", :display-name "Web Server Detection using TCP Ports", :description nil, :parameters (), :pattern-id "TCP_Webserver_Detection", :trigger "http_ports"}), "Host Networking by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Networking by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_HostBase", :trigger "snmp"}), "Arp Table by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Arp Table by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Router_Arp", :trigger "snmp_router"}), "iSeries Objects" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Objects", :display-name "IBM i Objects", :description "", :parameters (), :pattern-id "iSeries Objects by EView", :trigger "eview_iseries_agent"}), "DB Connections by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "DB Connections by Shell", :display-name nil, :description "Database existence discovery by Shell", :parameters (), :pattern-id "DB_Connect_by_TTY", :trigger "host_shell"}), "WebServices by URL" #=(clojure.lang.PersistentArrayMap/create {:id "WebServices by URL", :display-name "Web Services by URL", :description "", :parameters (), :pattern-id "WebserviceByURL", :trigger "wsdl_url"}), "Oracle Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_Dis_Oracle", :trigger "oracle_database"}), "Host Connection by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by WMI", :display-name nil, :description nil, :parameters (), :pattern-id "WMI_NET_Dis_Connection", :trigger "ip_with_wmi_or_without_host"}), "J2EE Weblogic Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic Connections by JMX", :display-name "JEE Weblogic Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebLogic_Connection", :trigger "weblogic_ports"}), "Servers by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Servers by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_Services", :trigger "local"}), "IBM HMC by SHELL" #=(clojure.lang.PersistentArrayMap/create {:id "IBM HMC by SHELL", :display-name "IBM Virtualization by Shell", :description "Discovers topology of IBM Hardware Management Console and IVM", :parameters (), :pattern-id "IBM_HMC_SHELL_PATTERN", :trigger "ibm_hmc_by_shell"}), "JBoss by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "JBoss by JMX", :display-name "JEE JBoss by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_JBoss", :trigger "jboss_server"}), "Layer2 Topology Bridge based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology Bridge based by SNMP", :display-name "Layer2 Topology Bridge-based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_Dis_L2_Bridge", :trigger "catalyst_bridge_no_vlan"}), "Oracle Application Server" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Application Server", :display-name "Oracle Application Server by Shell", :description "", :parameters (), :pattern-id "Oracle Application Server", :trigger "ntcmd_and_opmn"}), "Service Guard Cluster Topology by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Service Guard Cluster Topology by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "Service_Guard_Cluster_Topology", :trigger "shell_of_serviceguard_cs"}), "IBM Tivoli Network Manager by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Tivoli Network Manager by Shell", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dla_config_file_name", :description "Configuration file which is used to export IdML", :type "string"})), :pattern-id "ibm_tivoli_network_manager_by_shell", :trigger "ibm_tnm_shell"}), "MS Domains" #=(clojure.lang.PersistentArrayMap/create {:id "MS Domains", :display-name "Microsoft Windows Domains", :description nil, :parameters (), :pattern-id "MS_NET_Dis_Domain", :trigger "probe"}), "SAP TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "SAP TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all known ports"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Import from Database" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Database", :display-name nil, :description "", :parameters (), :pattern-id "Import_DB", :trigger nil}), "VMware VirtualCenter Topology by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Topology by VIM", :display-name "VMware vCenter Topology by VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Topology_by_VIM", :trigger "vmware_virtual_center"}), "Layer2 Topology CDP-LLDP based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology CDP-LLDP based by SNMP", :display-name "Layer2 Topology CDP-LLDP based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_CDP_LLDP_neighbors", :trigger "snmp_of_network_device"}), "Migrate DDMI Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Migrate DDMI Agent", :display-name "Migrate DDMI Agent", :description "", :parameters (), :pattern-id "MigrateDDMItoUDAgentAdapter", :trigger "ip"}), "Manual VMware VIM Connection" #=(clojure.lang.PersistentArrayMap/create {:id "Manual VMware VIM Connection", :display-name "Manual VMware VIM Connection", :description "", :parameters (), :pattern-id "VMware_VIM_Connection_Manual", :trigger "ip"}), "Merge Clustered Software" #=(clojure.lang.PersistentArrayMap/create {:id "Merge Clustered Software", :display-name nil, :description "", :parameters (), :pattern-id "Merge_Clustered_Software", :trigger "mergeDiscClusteredSoft"}), "Siebel Web Applications by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Web Applications by NTCMD", :display-name "Siebel Web Applications by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SIEBEL_DIS_WEBAPPS_NT", :trigger "siebel_webserver_nt"}), "DB Connections by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "DB Connections by WMI", :display-name nil, :description "Database existence discovery by WMI", :parameters (), :pattern-id "DB_Connect_by_Agent", :trigger "wmi_no_shell"}), "VMware VMotion Monitor by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VMotion Monitor by VIM", :display-name "VMware vMotion Monitor by VIM", :description "", :parameters (), :pattern-id "VMware_VMotion_discovery_by_VIM", :trigger "vmware_virtual_center"}), "Cisco HSRP by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Cisco HSRP by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "HSRP_by_SNMP", :trigger "snmp_of_HSRP"}), "VLANs by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "VLANs by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Catalyst_Vlans", :trigger "snmp_of_catalyst_switch"}), "Storage Devices Connection by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage Devices Connection by CIM", :display-name "Storage Devices Connection by CIM", :description "", :parameters (), :pattern-id "Storage_Devices_Connection_by_CIM", :trigger "smi_connection"}), "Layer2 Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology by Shell", :display-name "Layer2 Topology by Shell", :description "", :parameters (), :pattern-id "Layer2_Topology_by_Shell", :trigger "switch_with_shell"}), "EMC AutoStart by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "EMC AutoStart by Shell", :display-name nil, :description "", :parameters (), :pattern-id "EMC_AutoStart_by_Shell", :trigger "emc_autostart_with_shell"}), "Microsoft Message Queue Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Message Queue Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "MICROSOFT_MQ", :trigger "trigger_domainctl_ldap"}), "Install UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Install UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "InstallUDAgent", :trigger "shell_no_udagent"}), "J2EE WebSphere by Shell or JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere by Shell or JMX", :display-name "JEE WebSphere by Shell or JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebSphere", :trigger "websphere"}), "WebSphere to Webserver Dependency" #=(clojure.lang.PersistentArrayMap/create {:id "WebSphere to Webserver Dependency", :display-name "WebSphere to Web Server Dependency", :description "", :parameters (), :pattern-id "WebSphere_Webserver_Dependency", :trigger "websphere_webserver_dependencies"}), "Client Connection by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Client Connection by SNMP", :display-name "Client Connection by SNMP", :description "This job could collect ARP cache availabitly attribute by SNMP", :parameters (), :pattern-id "SNMP_NET_Dis_Connection_Client", :trigger "probe"}), "Server Ports by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Server Ports by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_ListenPorts", :trigger "local"}), "MS Domains Topology" #=(clojure.lang.PersistentArrayMap/create {:id "MS Domains Topology", :display-name "Microsoft Windows Domains Topology", :description "", :parameters (), :pattern-id "MS_Domain_Topogy", :trigger "ms_domain"}), "SAP Java Topology by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by WebServices", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :pattern-id "SAP_Dis_J2EE_Site", :trigger "sap_http_ports"}), "Siebel Application Servers" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Application Servers", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_APP_SERVERS", :trigger "siebel_gtwy_connected"}), "Hosts by Shell using NSLOOKUP on DNS Server" #=(clojure.lang.PersistentArrayMap/create {:id "Hosts by Shell using NSLOOKUP on DNS Server", :display-name "Hosts by Shell using nslookup on DNS Server", :description nil, :parameters (), :pattern-id "NSLOOKUP_on_DNS_Server", :trigger "dns_server_shell"}), "SAP System By Shell" #=(clojure.lang.PersistentArrayMap/create {:id "SAP System By Shell", :display-name "SAP System by Shell", :description "", :parameters (), :pattern-id "Sap_System_By_Shell", :trigger "sap_system_with_shell"}), "Siebel Web Applications by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Web Applications by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_WEBAPPS_UNIX", :trigger "siebel_webserver_shell"}), "J2EE TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE TCP Ports", :display-name "JEE TCP Ports", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all known ports"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "IIS Applications by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "IIS Applications by NTCMD", :display-name "IIS Applications by NTCMD or UDA", :description nil, :parameters (), :pattern-id "NTCMD_APP_Dis_IIS", :trigger "host_ntcmd_iis"}), "Active Directory Connection by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Active Directory Connection by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "LDAP_Active_Directory_Connection", :trigger "trigger_host_ldap"}), "IBM Systems Director Connection by HTTP" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Systems Director Connection by HTTP", :display-name nil, :description "", :parameters (), :pattern-id "ibm_systems_director_connection", :trigger "ibm_systems_director_port"}), "VLAN ports by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "VLAN ports by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_VMS_catalyst", :trigger "catalyst_vlan"}), "Mainframe TCP by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe TCP by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "Mainframe_TCP_by_SNMP", :trigger "snmp_of_lpar"}), "Network Devices from CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Network Devices from CiscoWorks LMS", :display-name nil, :description "This job populates network devices and layer two infrastructure from the Cisco Works Resource Manager Essentials database", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"})), :pattern-id "CiscoWorks_NetDevices", :trigger "CiscoWorks RME DB Port"}), "DNS Resolver" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Resolver", :display-name nil, :description nil, :parameters (), :pattern-id "DNS_Discovery", :trigger "host"}), "Host Connection by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Connection", :trigger "ip_with_snmp_or_without_host"}), "Layer 2 Topology from CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Layer 2 Topology from CiscoWorks LMS", :display-name nil, :description "This job populates nodes layer two infrastructure from the Cisco Works Campus Manager database", :parameters (), :pattern-id "CiscoWorks_Layer2", :trigger "CiscoWorks Campus DB Port"}), "HanaDb by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HanaDb by Shell", :display-name nil, :description "", :parameters (), :pattern-id "HanaDb_by_Shell", :trigger "hanadb"}), "Import data from Atrium" #=(clojure.lang.PersistentArrayMap/create {:id "Import data from Atrium", :display-name nil, :description "Import CIs and Relationships from BMC Atrium into UCMDB", :parameters (), :pattern-id "Atrium to UCMDB", :trigger "probe"}), "DNS Zone by DNS" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Zone by DNS", :display-name nil, :description "", :parameters (), :pattern-id "DNS_Zone_by_DNS", :trigger "dns_service"}), "J2EE WebSphere by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere by Shell", :display-name "JEE WebSphere by Shell", :description "", :parameters (), :pattern-id "WebSphere_By_Shell", :trigger "websphere_by_shell"}), "vCloud Director URL by vCloud API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud Director URL by vCloud API", :display-name nil, :description "", :parameters (), :pattern-id "vCloud_Director_URL_by_vCloud_API", :trigger nil}), "Solaris Zones by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Solaris Zones by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SolarisZone_Disc_By_TTY", :trigger "shell_solariszone"}), "VMware ESX Connection by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Connection by CIM", :display-name "VMware ESX Connection by CIM", :description "", :parameters (), :pattern-id "VMware_ESX_Connection_by_CIM", :trigger "esx_connection_by_cim"}), "SIM Integration by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "SIM Integration by WebServices", :display-name nil, :description "", :parameters (), :pattern-id "SIM_Discovery", :trigger "sim_server"}), "Host Fingerprint using nmap" #=(clojure.lang.PersistentArrayMap/create {:id "Host Fingerprint using nmap", :display-name nil, :description nil, :parameters (), :pattern-id "OS_Fingerprint", :trigger "ip"}), "TCP data by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TCP data by Shell", :display-name "TCP Data by Shell", :description "Collects TCP data by Shell", :parameters (), :pattern-id "tcp_discovery_by_shell", :trigger "host_shell"}), "iSeries Connection" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Connection", :display-name "IBM i Connection", :description "", :parameters (), :pattern-id "EView iSeries Connection", :trigger "probe"}), "MSSQL Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MSSQL Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_SqlServer", :trigger "sqlServer"}), "Import from Excel Workbook" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Excel Workbook", :display-name nil, :description "", :parameters (), :pattern-id "XLS_Parser", :trigger nil}), "HP IVM by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP IVM by Shell", :display-name "HP IVM by Shell", :description "", :parameters (), :pattern-id "hp_ivm", :trigger "host_shell_ivm"}), "Import from CSV sample" #=(clojure.lang.PersistentArrayMap/create {:id "Import from CSV sample", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "csvFile", :type "string", :description "Absolute path to the CSV file on the remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column number : attribute name,"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping file located in \"Configuration Files\" folder of this package"})), :pattern-id "Import_CSV", :trigger nil}), "SAP Java Topology by SAP JMX" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by SAP JMX", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_J2EE_Site", :trigger "sap_jmx_ports"}), "SE Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "SE Integration by SQL", :display-name nil, :description "This discovery job retrieves Storage and SAN information from the HP Storage Essentials SRM database", :parameters (), :pattern-id "SE_Discovery", :trigger "HPSE_OracleDB"}), "Hosts using NSLookup on Probe" #=(clojure.lang.PersistentArrayMap/create {:id "Hosts using NSLookup on Probe", :display-name "Hosts using nslookup on Probe", :description nil, :parameters (), :pattern-id "NSLOOKUP_on_Probe", :trigger "probe"}), "SAP Profiles by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Profiles by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Sap_Profile_By_Shell", :trigger "sap_app_servers"}), "SAP ABAP Connection by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ABAP Connection by SAP JCO", :display-name nil, :description "", :parameters (), :pattern-id "SAP_Sys_Dis", :trigger "sap_server_or_port"})}, :pattern-by-id {"SQLDiscoveryTutorial" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SqlServerConnection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "Queries.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ClusterConfiguration.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "SqlDatabase.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "DatabaseProps.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "SqlServerConfig.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "SqlServer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "SQLDiscoveryTutorial.py"})), :display-name "SQL Discovery Tutorial", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "tablename", :description "name of the table from which to retrieve the data", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:}"})), :input-cit "sqlserver", :discovered-classes ("location" "membership" "person"), :id "SQLDiscoveryTutorial", :description "Getting Started Guide SQL Discovery Tutorial"}, "VMware_ESX_Connection_by_CIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "vmware_cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "vmware_cim_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "vmware_esx_connection_by_cim.py"})), :display-name "VMware ESX Connection by CIM", :global-configuration-files [], :protocols ("cimprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("cim" "composition" "containment" "ip_address" "interface" "virtualization_layer" "vmware_esx_server"), :id "VMware_ESX_Connection_by_CIM", :description "VMware ESX Connection by CIM adapter"}, "sap_java_topology_by_http" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "16", :name "sap_jee_topology_by_http.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "sap_jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "sap_jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "iteratortools.py"})), :display-name "SAP J2EE Topology by HTTP", :global-configuration-files [], :protocols ("sapjmxprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_port_pair", :description "", :value "${SOURCE.ipserver_address}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_service_name", :description "", :value "${SOURCE.ip_service_name}"})), :input-cit "ip_service_endpoint", :discovered-classes ("database" "ip_address" "ip_service_endpoint" "j2eecluster" "j2ee_sap_central_services" "sap_j2ee_app_server" "sap_j2ee_dispatcher" "sap_j2ee_server_process" "sap_system" "sap_java_software_component"), :id "sap_java_topology_by_http", :description "Discover SAP J2EE environment based on XML queried by HTTP"}, "SQL_Dis_Oracle" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SQL_Dis_Oracle.py"})), :display-name "Oracle database topology by SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "comprehensiveDiscovery", :type "string", :description "False (the default): DBA Object, DB Job and DB User are not retrieved. If the parameter set to false changing of other parameters have no affect to discovery process (DBA Objects will not be brought)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverFunctions", :type "string", :description "False (the default): functions are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPackageBody", :type "string", :description "False (the default): package bodies are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPackages", :type "string", :description "False (the default): packages are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcedures", :type "string", :description "False (the default): procedures are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverTables", :type "string", :description "False (the default): tables are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverReportPageSize", :type "integer", :description "Maximum amount of query result objects that will be sent in one bulk"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name:NA}"})), :input-cit "oracle", :discovered-classes ("dbtablespace" "dbjob" "db_controlfile" "membership" "dblinkobj" "oracle" "oracle_schema" "containment" "dependency" "dbaobjects" "composition" "dbschedulerjob" "dbclient" "dbdatafile" "resource" "db_redofile" "dbuser" "process" "node" "db_archivefile" "ip_address" "db_redofilegroup" "ownership" "dbsnapshot" "rac"), :id "SQL_Dis_Oracle", :description "This adapter discovers Oracle database topology by SQL."}, "Sun_Cluster_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "solaris_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "sun_cluster_by_shell.py"})), :display-name nil, :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("sunresourcegroup" "suncluster" "membership" "execution_environment" "interface" "configuration_document" "containment" "sunclusterresource" "layer2_connection" "node" "ip_address" "composition" "cluster_software"), :id "Sun_Cluster_by_Shell", :description "adapter discovers Sun Cluster topology via shell including cluster nodes, resource groups and resources, quorum configuration, cluster interconnect."}, "DynamicCredentialSample" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "DynamicCredentialSample.py"})), :display-name "Dynamic Credential Sample", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (), :input-cit "node", :discovered-classes (), :id "DynamicCredentialSample", :description "This Discovery adapter serves as a sample how to dynamically create and use credentials for connecting to remote machines."}, "nnm_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "NNM_Integration_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "nnm_check_credential.py"})), :display-name "Check credential for NNM protocol", :global-configuration-files [], :protocols ("nnmprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "nnm_check_credential", :description nil}, "PowerShell_HR_All" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "34", :name "hostresource_dis_powershell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "33", :name "TTY_HR_Software_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "32", :name "TTY_HR_Share_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "31", :name "TTY_HR_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "30", :name "TTY_HR_Memory_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "29", :name "TTY_HR_Disk_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "28", :name "TTY_HR_CPU_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "27", :name "NTCMD_HR_Dis_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "26", :name "NTCMD_HR_Dis_Memory_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "25", :name "NTCMD_HR_Dis_Disk_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "24", :name "NTCMD_HR_REG_Service_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "23", :name "NTCMD_HR_REG_Software_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "22", :name "Dis_TCP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "21", :name "process_to_process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "20", :name "hostresource_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "19", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "hostresource_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "hostresource.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "memory.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "applications.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "distinguished_name.py"})), :display-name "Host Resources by PowerShell", :global-configuration-files [], :protocols ("powershellprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery.In case this value is true, all installed softwares are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "All the IP addresses connected to discovered machine", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "powershell", :discovered-classes ("osuser" "file_system_export" "cpu" "windows_service" "containment" "dependency" "process" "client_server" "node" "ip_address" "running_software" "iisapppool" "composition" "realization" "usage" "ip_service_endpoint" "installed_software" "file_system"), :id "PowerShell_HR_All", :description "Discovers host resources, process connectivity and software elements on Windows machines using PowerShell protocol."}, "Mainframe_topology_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Mainframe_topology_by_SNMP.py"})), :display-name "Mainframe topology by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_id", :description nil, :value "${SOURCE.root_id}"})), :input-cit "ip_address", :discovered-classes ("snmp" "ip_address" "lpar" "mainframe" "membership" "sysplex" "composition" "containment"), :id "Mainframe_topology_by_SNMP", :description "This adapter discovers IBM mainframe topology."}, "ICMP_NET_Dis_IpRange" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "IP_by_range.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "icmp_utils.py"})), :display-name "IP ping sweep", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :type "string", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character)."}) #=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :type "string", :description "Ping time out (Ms)"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :type "string", :description "Ping retry"}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :type "string", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)"}) #=(clojure.lang.PersistentArrayMap/create {:name "virtualModeDiscover", :type "string", :description "Flag that indicates if we want to discover the virtual ips"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :type "string", :description "Ping protocol: ICMP (1), ECHO PORT (2) or both (3)"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :type "string", :description "Number of threads in pool that performs port 7 echoing"}) #=(clojure.lang.PersistentArrayMap/create {:name "isIPv4PingEnabled", :type "string", :description "Ping all IPv4 addresses within the defined ranges"}) #=(clojure.lang.PersistentArrayMap/create {:name "isIPv6PingEnabled", :type "string", :description "Ping all IPv6 addresses within the defined ranges"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("dependency" "ip_address"), :id "ICMP_NET_Dis_IpRange", :description "This adapter performs an IP ping sweep on probe range(s)."}, "PowerShell_Host_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "9", :name "Host_Connection_by_powershell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "networking_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"})), :display-name "Host Connection by PowerShell", :global-configuration-files [], :protocols ("powershellprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_cmdbid", :description "", :value "${HOST.root_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_key", :description "", :value "${HOST.host_key:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_addrs", :description "", :value "${NA}"})), :input-cit "ip_address", :discovered-classes ("nt" "terminalserver" "membership" "parent" "interface" "ip_subnet" "containment" "ip_address" "node" "running_software" "composition" "dns_server" "powershell"), :id "PowerShell_Host_Connection", :description "This adapter discovers PowerShell agents by trying to connect to a Windows machine using the PowerShell protocol."}, "MS NLB by NTCMD" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ms_nlb_ntcmd.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ms_nlb_report_utils.py"})), :display-name "MS NLB by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"})), :input-cit "nt", :discovered-classes ("node" "ip_address" "membership" "nlb_clustersoftware" "composition" "ms_nlb_cluster" "configuration_document" "containment"), :id "MS NLB by NTCMD", :description "Discovers MS Network Load Balancing topology by NTCMD or UDA"}, "SQL_NET_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SQL_Net_Dis_Connection.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostname", :description nil, :value "${HOST.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("composition" "sqlserver" "oracle"), :id "SQL_NET_Dis_Connection", :description "This adapter discovers databases using SQL protocol."}, "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "siebel_discover_gateway.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "siebel_common.py"})), :display-name "Siebel Gateway Connection Discovery", :global-configuration-files [], :protocols ("siebelgtwyprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${PORT.network_port_number:NA}"})), :input-cit "ip_address", :discovered-classes ("membership" "siebel_site" "composition" "siebel_gateway"), :id "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)", :description "This adapter discovers Siebel Gateway Naming Server and related components by Siebel-Web protocol."}, "DNS_Zone" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "dns_zone_by_remote_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "dns_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "dns.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"})), :display-name "DNS Zone Topology", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeIPs", :type "string", :description "If IP is out of range of probe and parameter set to false IP is not reported. The default value is \"false\"."}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBrokenAliases", :type "string", :description "If parameter set to true aliases which canonical resource does not exists will be reported"}) #=(clojure.lang.PersistentArrayMap/create {:name "zoneList", :type "string", :description "Comma separated list of zones is an optional attribute. It provides names of zones to transfer. By default zone list is not specified so it is guessed"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("ip_address" "dnszone" "composition" "realization" "dns_record"), :id "DNS_Zone", :description "Discovers the DNS Resource Record topology of DNS Zone by querying name server using remote shell"}, "powershell_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "powershell_check_credential.py"})), :display-name "Check credential for Powershell protocol", :global-configuration-files [], :protocols ("powershellprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "powershell_check_credential", :description nil}, "tibco_ems_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco_ems_by_shell.py"})), :display-name "TIBCO EMS By Shell", :global-configuration-files [], :protocols ("sshprotocol" "tibcoprotocol" "telnetprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_queues", :description "To discover TIBCO EMS queues, set this to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_topics", :description "To discover TIBCO EMS topics, set this to true", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processCmdLine", :description "", :value "${SOURCE.process_cmdline}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processPath", :description "", :value "${SOURCE.process_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processRootId", :description "", :value "${SOURCE.root_id}"})), :input-cit "process", :discovered-classes ("composition" "ip_service_endpoint" "jmsdestination" "jmsserver" "node" "process" "tibco_ems_server" "usage" "containment" "ip_address"), :id "tibco_ems_by_shell", :description "Discover TIBCO EMS and its resources"}, "ms_exchange_topology_by_ldap" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "ms_exchange_topology_by_ldap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ms_exchange_ad_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "active_directory_utils.py"})), :display-name "Microsoft Exchange Topology by LDAP", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportMDBUsers", :description "", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SERVICE_ADDRESS.network_port_number}"})), :input-cit "domaincontroller", :discovered-classes ("activedirectorysite" "ms_exchange_folder" "activedirectorysystem" "exchange_administrative_group" "routing_group" "membership" "routing_group_connector" "smtp_connector" "routing_connector" "ms_exchange_folder_tree" "containment" "node" "ip_address" "activedirectoryforest" "exchangesystem" "ms_exchange_role" "composition" "ms_exchange_server" "ownership" "ms_exchange_mailbox_database" "ms_exchange_dag" "execution_environment"), :id "ms_exchange_topology_by_ldap", :description "adapter discovers Microsoft Exchange topology using information stored in Active Directory."}, "NNM_Integration" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "5", :name "NNM_Integration.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "nnmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "nnmi_api.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "nnmi_filters.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "nnm_netutils.py"})), :display-name "Population from NNMi", :global-configuration-files [], :protocols ("nnmprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisabledIp", :description "Whether to discover Disabled Ips (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverLayer2", :description "Whether to discover Layer2connection related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNodes", :description "Whether to discover Node related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNonManagedInterface", :description "Whether to discover Non Managed Interfaces (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNonManagedNode", :description "Whether to discover Non Managed Nodes (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPhysicalPorts", :description "Whether to discover Physical Ports", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverVlans", :description "Whether to discover Vlan related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeLayer2", :description "Page size for Layer2 discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeNodes", :description "Page size for Nodes discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeVlans", :description "Page size for VLANs discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP Address of the NNMi Server", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("composition" "containment" "hardware_board" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :id "NNM_Integration", :description "Connects to the NNMi web service and populates NNMi discovered nodes, IPs, networks, interfaces and layer two connection information to create a Layer 2 topology in UCMDB. Note that it is recommended NOT to run the UCMDB Layer 2 discoveries if using NNMi Layer 2 integration discovery."}, "LDAP_Active_Directory_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "LDAP_Active_Directory_Discovery.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "active_directory_utils.py"})), :display-name "LDAP Active Directory Topology", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "globalCatalogPort", :type "string", :description "Port number of domain controller that serves as Global Catalog for full topology discovery enabled by parameter \"tryToDiscoverGlobalCatalog\""}) #=(clojure.lang.PersistentArrayMap/create {:name "reportOUAsConfigurationDocument", :type "string", :description "If flag is set to \"true\" - report tree of Organizational Unit as configuration document, otherwise as tree of CIs"}) #=(clojure.lang.PersistentArrayMap/create {:name "tryToDiscoverGlobalCatalog", :type "string", :description "If this flag parameter is set to \"true\", attempt will be made to discover whole topology connecting to domain controller as to Global Catalog by specified port in parameter \"globalCatalogPort\""}) #=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description "Value referes to the DN under which records about domain controller servers are stored. Default value is OU=Domain Controllers"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SERVICE_ADDRESS.network_port_number}"})), :input-cit "domaincontroller", :discovered-classes ("activedirectorysite" "activedirectorysystem" "activedirectorysitelink" "domaincontrollerrole" "membership" "activedirectorydomain" "configuration_document" "ip_subnet" "containment" "ip_address" "node" "activedirectoryforest" "domaincontroller" "composition"), :id "LDAP_Active_Directory_Topology", :description "Discovers Active Directory via LDAP"}, "VMware_ESX_Topology_by_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "vmware_esx_topology_by_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware ESX Topology by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVMs", :type "string", :description "Whether we should report Virtual Machines that are powered-off:  - if the value is false, powered-off VMs will not be reported  - if the value is true, powered-off VMs will be reported unless there is a powered-on machine with the same host key (powered-on machine has priority)"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "server_url", :description "", :value "${SOURCE.connection_url}"})), :input-cit "virtualization_layer", :discovered-classes ("license_feature" "vmware_resource_pool" "license_server" "virtualization_layer" "vmware_networking_policy" "vmware_host_resource" "execution_environment" "file_system_export" "cpu" "vmware_virtual_switch" "interface" "containment" "vmware_port_group" "license_reservation" "node" "ip_address" "composition" "usage" "dependency" "vmware_esx_server" "vmware_datastore"), :id "VMware_ESX_Topology_by_VIM", :description "This adapter discovers VMware ESX Servers using VIM protocol."}, "hyperv_topology_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "hyperv_topology_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "hyperv.py"})), :display-name "Hyper-V Topology by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("layer2_connection" "node" "virtualization_layer" "membership" "execution_environment" "composition" "switch" "interface" "hyperv_partition_config"), :id "hyperv_topology_by_shell", :description "adapter discovers Microsoft Hyper-V virtualization topology using shell protocol."}, "weblogic_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx_check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "weblogic_check_credential.py"})), :display-name "Check credential for the Weblogic JMX protocol", :global-configuration-files [], :protocols ("weblogicprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "weblogic_check_credential", :description nil}, "SE_Discovery" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SE_Discovery.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "Storage Essentials", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignorePortsWithoutWWN", :description "If this is set to true, CIs for Fiber Channel Ports without WWN will be ignored", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name}"})), :input-cit "oracle", :discovered-classes ("composition" "containment" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "memory" "netapp_filer" "node" "realization" "storagearray" "storagefabric" "storagepool" "storageprocessor" "unix" "nt"), :id "SE_Discovery", :description "Populates storage devices and SAN infrastructure from the HP Storage Essentials SRM database"}, "ntadmin_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ntadmin_check_credential.py"})), :display-name "Check credential for Ntadmin protocol", :global-configuration-files [], :protocols ("ntadminprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "ntadmin_check_credential", :description nil}, "Cisco_CSS_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Cisco_CSS_by_SNMP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "snmputils.py"})), :display-name "Cisco CSS by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP address of SNMP destination", :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "lb" "ip_service_endpoint" "cisco_css" "containment"), :id "Cisco_CSS_by_SNMP", :description "Discovers Cisco CSS (Content Services Switch) using the SNMP protocol"}, "siebelgtwy_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "siebel_gtwy_check_credential.py"})), :display-name "Check credential for Siebel protocol", :global-configuration-files [], :protocols ("siebelgtwyprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "siebelgtwy_check_credential", :description nil}, "blade_servers_by_ibm_director_api" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ibm_director_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "blade_servers_by_ibm_systems_director_api.py"})), :display-name "Blade Servers by IBM Systems Director REST API", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${ENDPOINT.bound_to_ip_address}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${ENDPOINT.network_port_number}"})), :input-cit "ibm_systems_director", :discovered-classes (), :id "blade_servers_by_ibm_director_api", :description "This adapter brings chassis and blade servers topology using connection to IBM Systems Director REST API"}, "Network_Connectivity_Data_Analyzer" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "tcp.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ip_ranges.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "tcp_approach_plugin.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "tcp_acceptor_plugin.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "tcp_reporter_plugin.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "tcp_descriptor.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "Network_Connectivity_Data_Analyzer.py"})), :display-name "Network Connectivity Data Analyzer", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportIpTrafficLink", :description "enables/disables reporting of traffic link if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportNodeDependencyLink", :description "enables/disables reporting of dependency link if value is 'true'/'false'.  Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportServerRunningSoftware", :description "enables/disables reporting of server running software if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "acceptedServices", :description "list of service to report(ssh, oracle,  mysql, etc, '*' means report all found services). Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :description "enables/disables reporting of outscope servers if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :description "enables/disables reporting of outscope clients if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoveryDescriptorFile", :description "Full path to a job configuration file used to define analysis and reporting approach per ip range scope(forward slashes should be used to specify the path).", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.discoveryprobemanager_probeName}"}) #=(clojure.lang.PersistentArrayMap/create {:name "probeIp", :description "", :value "${SOURCE.discoveryprobemanager_ip}"})), :input-cit "discoveryprobemanager", :discovered-classes ("dependency" "traffic" "client_server" "containment" "composition" "node" "ip_address" "ip_service_endpoint" "usage"), :id "Network_Connectivity_Data_Analyzer", :description "Discover client server connections on the network according to the chosen parameters. Brings data from DFM database"}, "command_runner" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "command_runner.py"})), :display-name "Command runner", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "agent", :discovered-classes (), :id "command_runner", :description "This adapter is used to create communication logs"}, "F5_BIGIP_LTM_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "F5_BIGIP_LTM_by_SNMP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "snmputils.py"})), :display-name "F5 BIGIP by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP address of SNMP destination", :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("f5_ltm" "ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "ip_service_endpoint" "lb" "configuration_document" "containment"), :id "F5_BIGIP_LTM_by_SNMP", :description "This adapter discovers F5 BIG-IP Local Traffic Manager using SNMP protocol"}, "ssh_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ssh_check_credential.py"})), :display-name "Check credential for SSH protocol", :global-configuration-files [], :protocols ("sshprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "ssh_check_credential", :description nil}, "MaxDb by Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "8", :name "maxdb_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "maxdb_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "maxdb.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "fptools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"})), :display-name "MaxDb by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbDataPath", :description "", :value "${SOURCE.data_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbPort", :description "", :value "${SOURCE.application_port:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbProgramPath", :description "", :value "${SOURCE.program_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbSid", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbVersion", :description "", :value "${SOURCE.application_version}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processParams", :description "", :value "${PROCESS.process_parameters:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processPath", :description "", :value "${PROCESS.process_path:}"})), :input-cit "maxdb", :discovered-classes ("composition" "configuration_document" "containment" "dbdatafile" "dbuser" "database_instance" "ip_address" "ip_service_endpoint" "maxdb" "node" "sqlbackup"), :id "MaxDb by Shell", :description "Discovers MaxDB instances and topology"}, "SQL_NET_Dis_Connection_MySql" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SQL_Connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "MySql Connection By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_ip", :description "", :value "${DB.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${DB.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_ip", :description "", :value "${SA.bound_to_ip_address:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_port", :description "", :value "${SA.network_port_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${DB.name:NA}"})), :input-cit "node", :discovered-classes ("composition" "mysql" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :id "SQL_NET_Dis_Connection_MySql", :description "This adapter discovers databases using SQL protocol."}, "Oracle_LMS_Data_Collection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "8", :name "Oracle_LMS.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "OracleLMSOptions.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "OracleLMSDbaUsers.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "OracleLMSDetail.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "OracleLMSOverview.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "OracleLMSVSession.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "OracleLMSVLicense.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "OracleLMSUtils.py"})), :display-name "Oracle LMS data collection by SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "group", :description "Grouping as defined by the customer(e.g. regions, department, etc)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "aggregationLevel", :description "Different levels of aggregations that are used to calculate a value: e.g. database level, server level, network level, etc.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "oracleCSI", :description "Oracle Customer Support identifier (CSI) that is used to interact with Oracle Support-Services.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "applicationName", :description "Name of the application running in conjunction with the Oracle product.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "applicationStatus", :description "Status of the Application (e.g. productive, test environment, development, training, etc.)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "userCountForApplication", :description "If the DBA_USERS table contains generic Usernames/Schemas to connect to the application/database, the customer should provide the User Count at Application - Level.", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "serverNameInTheCluster", :description "Typical question would be: Are the servers clustered? If yes which servers make the cluster?", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "measurementComment", :description "Additional comments out of the measurement or comments from the customer.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "size", :description "Default size of compressed LMS data. (bytes)", :type "integer"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "core_number", :description "", :value "${Cpu.core_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "cpu_clock_speed", :description "", :value "${Cpu.cpu_clock_speed:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "cpu_specifier", :description "", :value "${Cpu.cpu_specifier:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "discovered_host_name", :description "", :value "${HOST.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "discovered_model", :description "", :value "${HOST.discovered_model:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "discovered_os_name", :description "", :value "${HOST.discovered_os_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "discovered_vendor", :description "", :value "${HOST.discovered_vendor:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_isvirtual", :description "", :value "${HOST.host_isvirtual:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "document_content", :description "", :value "${AuditDocument.document_content:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "logical_cpu_count", :description "", :value "${Cpu.logical_cpu_count:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_amazon_ec2_config", :description "", :value "${Amazon EC2 Config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_hp_npar_config", :description "", :value "${HP nPar Config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_hp_vpar_config", :description "", :value "${HP vPar Config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_hyper-v_partition_config", :description "", :value "${HyperV Partition Config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_ibm_lpar_profile", :description "", :value "${IBM LPar Profile.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_solaris_zone_config", :description "", :value "${Solaris Zone Config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_vmware_host_resource", :description "", :value "${VMware Host Resource.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "partitioning_xen domain config", :description "", :value "${Xen domain config.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${SOURCE.name:NA}"})), :input-cit "oracle", :discovered-classes ("composition" "audit_document" "oracle"), :id "Oracle_LMS_Data_Collection", :description "This adapter collects data related to Oracle software usage, which can then be sent to Oracle LMS organization for Oracle License Review or Audit."}, "MySQL by shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "6", :name "mysql_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "MySqlDiscoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "mysql_version_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "iniparser.py"})), :display-name "MySQL by shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbport", :description "", :value "${SOURCE.application_port:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbsid", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processParams", :description "", :value "${PROCESS.process_parameters:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processPath", :description "", :value "${PROCESS.process_path:}"})), :input-cit "mysql", :discovered-classes ("client_server" "ip_address" "node" "composition" "ip_service_endpoint" "configuration_document" "mysql_replication" "containment" "mysql"), :id "MySQL by shell", :description "Discovers MySQL instances and replication topology"}, "cim_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "cim_check_credential.py"})), :display-name "Check credential for CIM protocol", :global-configuration-files [], :protocols ("cimprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "cim_check_credential", :description nil}, "JMX_J2EE_WebLogic_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "weblogic.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "weblogic_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_WebLogic_Connection.py"})), :display-name "Weblogic Server Discovery", :global-configuration-files [], :protocols ("weblogicprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "", :value "${SERVICE_ADDRESS.network_port_number:NA}"})), :input-cit "ip_address", :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "containment" "membership" "usage" "jvm" "ip_service_endpoint" "ip_address" "weblogicas"), :id "JMX_J2EE_WebLogic_Connection", :description "Discovers WebLogic Server based on JMX protocol. Supported versions: 6.0, 6.1, 7.0, 8.1, 9.0, 9.1, 9.2, 10"}, "hyperv_topology_by_wmi" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "hyperv_topology_by_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "hyperv.py"})), :display-name "Hyper-V Topology by WMI", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "wmi", :discovered-classes ("layer2_connection" "node" "virtualization_layer" "membership" "execution_environment" "composition" "switch" "interface" "hyperv_partition_config"), :id "hyperv_topology_by_wmi", :description "adapter discovers Microsoft Hyper-V virtualization topology using WMI protocol."}, "ldap_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ldap_check_credential.py"})), :display-name "Check credential for LDAP protocol", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "ldap_check_credential", :description nil}, "SAP_Dis_SolutionManager" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "saputils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_solman_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_solution_manager.py"})), :display-name "SAP Business Layer Discovery", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverScenarioProcesses", :description "If set to true processes of scenarios will be discovered. Default value is false", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "getProcessSteps", :type "string", :description "Get processes steps information"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "SITE_ID", :description "", :value "${SAP_SYSTEM.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "instance_number", :description "", :value "${SOURCE.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connection_client", :description "", :value "${SOURCE.connection_client:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "sap_r3_server", :discovered-classes ("ip_address" "node" "sap_r3_server" "sap_business_process" "membership" "sap_transaction" "sap_bp_project" "sap_process_step" "composition" "sap_system" "sap_business_scenario" "containment"), :id "SAP_Dis_SolutionManager", :description "Discover SAP business layer based on Solution Manager system management suite."}, "MS_Exchange_Topology_by_PowerShell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "7", :name "ms_exchange_topology_by_powershell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "msexchange_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "msexchange.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"})), :display-name "MS Exchange Topology by Powershell", :global-configuration-files [], :protocols ("powershellprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "powershell", :discovered-classes ("exchange_administrative_group" "composition" "exchangeclientaccessserver" "exchangeedgeserver" "exchangehubserver" "exchangemailserver" "exchangesystem" "exchangeunifiedmessagingserver" "membership" "ms_exchange_server" "ms_exchange_clustered_mailbox" "ms_exchange_dag" "node" "containment" "ms_exchange_mailbox_database" "execution_environment" "ip_address" "ownership"), :id "MS_Exchange_Topology_by_PowerShell", :description "This adapter discovers Microsoft Exchange by PowerShell protocol. It is based on executing Exchange native cmdlets."}, "WebSphere_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "fptools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "websphere.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "websphere_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "websphere_by_shell.py"})), :display-name "Websphere J2EE Topology Discovery by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "containment" "database_instance" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :id "WebSphere_By_Shell", :description "This adapter discovers WebSphere J2EE environment and components by shell."}, "Aperture_Vista_by_SQL" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Aperture_Vista_by_SQL.py"})), :display-name "Aperture VISTA by SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port}"})), :input-cit "sqlserver", :discovered-classes ("chassis" "usage" "node" "power_distribution_unit" "remote_power_panel" "composition" "datacenter" "datacenter_resource" "rack" "unix" "containment"), :id "Aperture_Vista_by_SQL", :description "Discovers Aperture VISTA data centers and power infrastructure using the Aperture VISTA Database"}, "processLayer2Files" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "processL2Files.py"})), :display-name "Process Layer2 Collected Files", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes ("composition" "interface" "layer2_connection" "membership" "node"), :id "processLayer2Files", :description "Adapter Description"}, "TTY_HACMP_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "storage_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "TTY_HACMP_Topology.py"})), :display-name nil, :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "AIX_ClusterPackageName", :type "string", :description "The command to get the cluster license on AIX"}) #=(clojure.lang.PersistentArrayMap/create {:name "cldisp_command", :type "string", :description "Actual command to use for cldisp. Can use full path or even root /path/cldisp"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_os", :description "The OS for the host", :value "${Node.discovered_os_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "The CMDB Id of the triggered Host", :value "${Node.root_id}"})), :input-cit "shell", :discovered-classes ("volumegroup" "ip_address" "node" "membership" "composition" "logical_volume" "cluster_software" "physicalvolume" "interface" "containment" "hacmpcluster"), :id "TTY_HACMP_Topology", :description "Discovers IBM HACMP node Topology on servers via SSH, Telnet or UDA"}, "DB_Connect_by_TTY" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "13", :name "DB_Connect_by_TTY.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "dbconnect_unix_shellutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "TTY_HR_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "dbconnect_win_shellutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "dbconnect_oracle.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "dbconnect_mssql.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "NTCMD_HR_REG_Service_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "NTCMD_HR_Dis_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "NTCMD_HR_REG_Software_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "dbconnect_utils.py"})), :display-name "Database Connections by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_oracle", :type "string", :description "Set to \"true\" for Oracle identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_mssql", :type "string", :description "Set to \"true\" for Microsoft SQL Server  identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "use_lsof", :type "string", :description "Set to \"true\" if lsof is available on AIX and/or Solaris. HPUX discovery will use LSOF regardless of this flag."}) #=(clojure.lang.PersistentArrayMap/create {:name "use_sudo", :type "string", :description "Set to \"true\" if sudo should be used for commands on UNIX"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterByDiscoveredProcesses", :type "string", :description "** Do not set to TRUE ** Out-of-the-box process filters do not include database processes, and this dicsovery will not work effectively unless we receive an unfiltered list of processes"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "shell", :discovered-classes ("nt" "ip_address" "node" "composition" "sqlserver" "ip_service_endpoint" "oracle" "unix" "containment"), :id "DB_Connect_by_TTY", :description "Identifies databases on  hosts by host credentials, using the Shell protocols"}, "sql_generic_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "sql_generic_check_credential.py"})), :display-name "Check credential for Generic SQL protocol", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sql_generic_check_credential", :description nil}, "SAP_SolMan_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "saputils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_solman_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_solman_topology.py"})), :display-name "SAP Topology by Solution Manager", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "instance_number", :description "", :value "${SOURCE.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connection_client", :description "", :value "${SOURCE.connection_client:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "sap_r3_server", :discovered-classes ("sap_r3_server" "j2ee_sap_central_services" "sap_j2ee_app_server" "membership" "sap_system" "j2eecluster" "sap_client" "node" "ip_address" "configuration_document" "database" "containment" "dependency" "composition" "usage"), :id "SAP_SolMan_Topology", :description "Discover SAP Topology based on Solution Manager."}, "SIM_Discovery" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "Push_To_UCMDB_from_SIM.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "exportTQL_for_SIM_to_UCMDB.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SIM_Discovery.py"})), :display-name "Systems Insight Manager", :global-configuration-files [], :protocols ("simprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dbIP", :type "string", :description "IP Address of the SIM CMS Database"}) #=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :type "string", :description "Number of nodes to pull from HP SIM per web service call. Changing this value may affect performance and is not recommended"}) #=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierAttributes", :type "string", :description "** DON'T FORGET TO SINGLE QUOTE YOUR ENTRY **  Comma separated list of source attributes used to identify the CI Type of a HOST as UNIX, Windows, etc."}) #=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierMap", :type "string", :description "** DON'T FORGET TO SINGLE QUOTE YOUR ENTRY ** Case-sensitive map of <IdentifierAttributeValue>:<UCMDB CI Type>"}) #=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :type "string", :description "If set to true, the integration will only create the result XML file and not push data into UCMDB"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierAttributes", :description "", :value "${PARAMETERS.HostCitIdentifierAttributes}"}) #=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierMap", :description "", :value "${PARAMETERS.HostCitIdentifierMap}"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "", :value "${PARAMETERS.DebugMode}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP Address of the HP SIM Server", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("nt" "host_node" "enclosure" "membership" "netprinter" "management_processor" "cpu" "switch" "rack" "interface" "containment" "process" "chassis" "dependency" "node" "ip_address" "hp_complex" "composition" "logical_volume" "unix"), :id "SIM_Discovery", :description "Populates servers and other devices from an HP SIM (Systems Insight Manager) server"}, "UDDI_Registry" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "UDDI_Registry.py"})), :display-name "UDDI Registry Discovery", :global-configuration-files [], :protocols ("uddiregistryprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "organization", :type "string", :description "Organization"}) #=(clojure.lang.PersistentArrayMap/create {:name "query_chunk_size", :type "string", :description "Integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "name", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.ip_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "version", :description nil, :value "${SOURCE.version}"})), :input-cit "uddiregistry", :discovered-classes ("dependency" "ip_address" "organization" "uri_endpoint" "composition" "webservice" "containment"), :id "UDDI_Registry", :description "Discovers a UDDI Registry and published services using a given URL"}, "IP_MAC_Harvesting_By_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "clientdiscoveryutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "IPMAC_Harvesting.py"})), :display-name "IP MAC Harvesting By SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DelayTimePerSNMPRequest", :description "Delay time for every snmp get next request, unit:ms", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsCollectDataCenterIP", :description "Whether to collect data center IP", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_ip", :description nil, :value "${SOURCE.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description nil, :value "${SOURCE.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_on_agent", :description nil, :value "${SOURCE.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${IP.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_on_ip", :description nil, :value "${IP.arp_mac:NA}"})), :input-cit "snmp", :discovered-classes ("ip_address"), :id "IP_MAC_Harvesting_By_SNMP", :description "This adapter collects IP MAC mapping by SNMP and reports delta information to UCMDB."}, "Merge VLANs" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "merge_vlans_by_ports.py"})), :display-name "Merge VLANs", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "memberId", :description "", :value "${MEMBERPORT.root_id::1}"}) #=(clojure.lang.PersistentArrayMap/create {:name "portId", :description "", :value "${PHYSICALPORT.root_id::1}"}) #=(clojure.lang.PersistentArrayMap/create {:name "vlanId", :description "", :value "${SOURCE.vlan_id}"})), :input-cit "vlan", :discovered-classes ("membership" "physical_port" "vlan"), :id "Merge VLANs", :description "Used to create links between VLAN and physical ports across different switches in case the corresponding interfaces have connectivity.  Connectivity between interfaces is determined based on the Layer2Connection CI presence."}, "networkautomation_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "network_automation.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "na_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "na_check_credential.py"})), :display-name "Check credential for Network Automation Java protocol", :global-configuration-files [], :protocols ("networkautomationprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "networkautomation_check_credential", :description nil}, "SQL_Server_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "SQL_Server_Connection.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name}"})), :input-cit "sqlserver", :discovered-classes ("composition" "sqlserver"), :id "SQL_Server_Connection", :description "This adapter discovers the credentials of SQL Server database discovered by adapters which do not use SQL credentials."}, "hp_ivm" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "ivm_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ivm_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ivm.py"})), :display-name "HP Integrity Virtual Machine by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportHostNameAsVmName", :description "Set Host Name to the value of VM name", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("composition" "execution_environment" "hp_ivm_config" "node" "virtualization_layer"), :id "hp_ivm", :description "This adapter discovers HPIntegrity Virtual Machine topology by connecting to the physical or virtual server"}, "FILE_Mon" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "file_mon.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "File Monitor by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "binary_file_extensions", :type "string", :description "Binary files extensions"}) #=(clojure.lang.PersistentArrayMap/create {:name "extensions", :type "string", :description "All files extensions"}) #=(clojure.lang.PersistentArrayMap/create {:name "folders", :type "string", :description "List of folders to gather files from"}) #=(clojure.lang.PersistentArrayMap/create {:name "recursively", :type "string", :description "Scan folder recursively."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnixHiddenFiles", :type "string", :description "Whether to discover hidden files on Unix like system.If True then all hidden files will be discovered.(Parameter doesn't depend extentions parameter)."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "shell", :discovered-classes ("composition" "configuration_document"), :id "FILE_Mon", :description "Discovers Document files and Directories"}, "JMX_J2EE_WebSphere_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "websphere.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "websphere_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_WebSphere_Connection.py"})), :display-name "Websphere Server Discovery", :global-configuration-files [], :protocols ("websphereprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_dnsname", :description nil, :value "${SOURCE.authoritative_dns_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "", :value "${SERVICE_ADDRESS.network_port_number:NA}"})), :input-cit "ip_address", :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "usage" "ip_service_endpoint" "ip_address" "websphereas"), :id "JMX_J2EE_WebSphere_Connection", :description "This adapter discovers WebSphere servers based on either SOAP or RMI authentication."}, "Oracle_Listeners_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "oracle_listeners_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "oracle_shell_utils.py"})), :display-name "Oracle Listeners by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "OracleHomes", :description "Used when no ORACLE_HOME environment variable is defined. Value must coincide with the same parameter in Oracle RAC topology by Shell Job", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "listener_names", :description "The name of the running listener", :value "${LISTENER.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "listener_process_path", :description "", :value "${PROCESS.process_path}"})), :input-cit "shell", :discovered-classes ("composition" "containment" "ip_address" "node" "oracle_listener"), :id "Oracle_Listeners_by_Shell", :description "Discovers Oracle listeners. Is required for Oracle RAC deep discovery"}, "VMware_VirtualCenter_Connection_by_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "vmware_virtualcenter_connection_by_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware vCenter Connection by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "connection_url", :description "", :value "${VC.connection_url:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${VC.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_addresses", :description "", :value "${IP.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "rs_id", :description "", :value "${RS.root_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "vc_id", :description "", :value "${VC.root_id:NA}"})), :input-cit "node", :discovered-classes ("composition" "containment" "ip_address" "node" "vmware_virtual_center"), :id "VMware_VirtualCenter_Connection_by_VIM", :description "Adapter discovers connection to VMware vCenter server using Virtual Infrastructure Management protocol."}, "OS_Fingerprint" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "WMI_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "nmap_osfingerprint.py"})), :display-name "OS Fingerprint", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "Create_Application_CI", :type "string", :description "Create an application CI based on the port fingerprint information"}) #=(clojure.lang.PersistentArrayMap/create {:name "Perform_Port_Fingerprints", :type "string", :description "Try to discover the application behind the port. (this operation will open the port)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_os_name", :type "string", :description "Discover Host OS, which may have some inaccuracy"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_host_timeout", :type "string", :description "The amount of time Nmap is allowed to spend scanning a single host (in seconds)"}) #=(clojure.lang.PersistentArrayMap/create {:name "scan_known_ports_only", :type "string", :description "Scan for ports listed in the portNumberToPortName.xml file"}) #=(clojure.lang.PersistentArrayMap/create {:name "scan_these_ports_only", :type "string", :description "Limit the range of ports to scan.  Example range: T:1-10,42,U:1-30 discover (TCP ports 1 to 10 and 42)  and (UDP ports 1-30),(empty means using nmap default)"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_location", :type "string", :description "Location of nmap executable tool. If empty nmap is looked in system path"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("node" "ip_address" "running_software" "composition" "parent" "ip_service_endpoint" "interface" "containment"), :id "OS_Fingerprint", :description "This adapter discovers hosts, IPs, open TCP and UDP ports and host operating systems using nmap.exe."}, "Storage_Devices_Topology_by_CIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "6", :name "smis_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "smis_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "smis.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"})), :display-name "Storage Devices Topology by CIM", :global-configuration-files [], :protocols ("cimprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Id of the used credentials", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "Destination Ip", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "IP Probe domain", :value "${SOURCE.application_ip_domain}"})), :input-cit "cim", :discovered-classes ("composition" "fcconnect" "fcport" "ip_address" "logical_volume" "node" "storagearray" "storagepool"), :id "Storage_Devices_Topology_by_CIM", :description "Adapter used for discovery of storage topology via CIM protocol"}, "netapp_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "netapp_webservice_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "netapp_check_credential.py"})), :display-name "Check credentials for the Netapp Filer", :global-configuration-files [], :protocols ("netappprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "netapp_check_credential", :description nil}, "MS_Exchange_Connection_by_WMI" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ms_exchange_connection_by_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ms_exchange_utils.py"})), :display-name "Microsoft Exchange Connection by WMI", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostName", :description "", :value "${HOST.name:N/A}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "wmi", :discovered-classes ("host_node" "composition" "ms_exchange_server"), :id "MS_Exchange_Connection_by_WMI", :description "Connects to the remote host by WMI and discovers Exchange Server CI"}, "SNMP_Dis_L2_Vlan" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "bridgePortDisc.py"})), :display-name "L2 Vlan by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "bridgeId", :description nil, :value "${SOURCE.vlan_bridgemac}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SNMP.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "smpDescription", :description nil, :value "${SNMP.snmp_description:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostOs", :description "", :value "${HOST.discovered_os_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostModel", :description "", :value "${HOST.discovered_model:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SNMP.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpCommunityPostfix", :description nil, :value "${SOURCE.vlan_id}"})), :input-cit "vlan", :discovered-classes ("layer2_connection" "node" "physical_port" "membership" "composition" "realization" "bridge" "interface"), :id "SNMP_Dis_L2_Vlan", :description "This adapter discovers the Layer 2 topology of a specific VLAN by SNMP."}, "HP_Network_Automation_by_Java" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "network_automation.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "na_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "na_integration_by_java.py"})), :display-name "HP Network Automation by Java", :global-configuration-files [], :protocols ("networkautomationprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryTopologyPerDevice", :description "Whether to perform separate queries per device (true), or retrieve topology with queries for all devices at once (false, default).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportDeviceConfigs", :description "Whether to report configuration as config files for devices", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("composition" "configuration_document" "containment" "hardware_board" "interface" "ip_address" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :id "HP_Network_Automation_by_Java", :description "HP Network Automation by Java"}, "JMX_J2EE_JBoss" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "jboss.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "jboss_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_JBoss.py"})), :display-name "Jboss J2EE Topology Discovery by JMX", :global-configuration-files [], :protocols ("jbossprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "servername", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "userName", :description nil, :value "${SOURCE.application_username:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "version", :description nil, :value "${SOURCE.application_version:}"})), :input-cit "jbossas", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "containment" "webservice" "jbossas"), :id "JMX_J2EE_JBoss", :description "This adapter discovers JBoss J2EE environment and components based on the JMX protocol."}, "MQ_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "mq_topology.py"})), :display-name "Websphere MQ Topology by shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_dynamic_queues", :type "string", :description "Enable discovery of permanent and temporary dynamic queues"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_remote_hosts", :type "string", :description "Enables resolution and discovery of remote servers and MQ objects referenced by the server being discovered. If set to false, relationships between MQ objects on different servers will not be discovered"}) #=(clojure.lang.PersistentArrayMap/create {:name "mq_cmd_timeout", :type "string", :description "Sets the command timeout for MQ commands"}) #=(clojure.lang.PersistentArrayMap/create {:name "mqver_path", :type "string", :description "Path to 'mqver' or 'dspmqver' executables. Separate multiple entries by \";\""}) #=(clojure.lang.PersistentArrayMap/create {:name "sudo_command", :type "string", :description "Use the MQ username here"}) #=(clojure.lang.PersistentArrayMap/create {:name "use_sudo", :type "string", :description "Should SUDO be used?"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${Node.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("membership" "mqnamelist" "mqreceiverchannel" "mqchannel" "containment" "mqsenderchannel" "dependency" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "webspheremq" "mqqueuemanager" "mqcluster" "mqqueue"), :id "MQ_Topology", :description "Discover Websphere MQ topology by using SSH, TELNET, NTCMD or UDA"}, "sql_db2_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "db2_check_credential.py"})), :display-name "Check credential for DB2 SQL protocol", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sql_db2_check_credential", :description nil}, "IBM_LPAR_VIO_BY_SHELL" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "13", :name "ibm_lpar_or_vio_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "storage_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "ibm_hmc_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "TTY_HR_CPU_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "hostresource.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "hostresource_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "hostresource_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "host_win_wmi.py"})), :display-name "IBM LPar And VIO Server by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "The Protocol Name", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "The ID of the used connection credentials.", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "The CMDB ID of the remote Host", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "The destination IP", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "managedSystemId", :description "The CMDB ID of the Managed System the destination Virtual Host belongs to", :value "${MANAGED_SYSTEM.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "osType", :description "OS type. E.G. Linux/AIX...", :value "${HOST.discovered_os_name}"})), :input-cit "shell", :discovered-classes ("sea_adapter" "membership" "scsi_adapter" "parent" "ioslot" "physicalvolume" "interface" "interface_aggregation" "containment" "interfaceindex" "dependency" "node" "volumegroup" "ip_address" "fchba" "composition" "realization" "logical_volume" "usage" "file_system"), :id "IBM_LPAR_VIO_BY_SHELL", :description "Adapter for Discovery of IBM VIO Server or any IBM LPar running system"}, "SIEBEL_DIS_APP_SERVER_CONFIG" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "siebel_discover_appserver_config.py"})), :display-name "Siebel Application Server Configuration File by shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelInstallDir", :description nil, :value "${SOURCE.install_dir}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelVersion", :description nil, :value "${SOURCE.version:NA}"})), :input-cit "siebel_app_server", :discovered-classes ("composition" "siebel_app_server" "configuration_document"), :id "SIEBEL_DIS_APP_SERVER_CONFIG", :description "Discover configuration file of Siebel application server"}, "microsoft_mq_ntcmd" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ntcmd_msmq.py"})), :display-name "Microsoft MQ by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "Protocol name", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credentials Id", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostname", :description "", :value "${HOST.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "msmq_id", :description "MSMQ Manager ID", :value "${MSMQ_MANAGER.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "Destination Ip Address", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("ip_address" "node" "msmqmanager" "msmqqueue" "composition" "msmqtrigger" "usage" "msmqrule" "containment"), :id "microsoft_mq_ntcmd", :description "Discovery adapter for Microsoft MQ server side. Uses NTCMD or UDA protocol in order to retrieve queues, triggers and rules related data"}, "ms_exchange_connection_by_ntcmd" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "9", :name "ms_exchange_connection_by_NTCMD.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "ms_exchange_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "powershellutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "msexchange_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "msexchange.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "host_win.py"})), :display-name "Microsoft Exchange Connection by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "composition" "ms_exchange_server"), :id "ms_exchange_connection_by_ntcmd", :description "This adapter discovers Microsoft Exchange by NTCMD or UDA protocol. It is based on executing of PowerShell scenario on the remote machine."}, "SQL_NET_Dis_Connection_MsSql" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SQL_Connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "MsSql Connection By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_ip", :description "", :value "${DB.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${DB.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_ip", :description "", :value "${SA.bound_to_ip_address:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_port", :description "", :value "${SA.network_port_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${DB.name:NA}"})), :input-cit "node", :discovered-classes ("composition" "sqlserver" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :id "SQL_NET_Dis_Connection_MsSql", :description "This adapter discovers databases using SQL protocol."}, "ibm_systems_director_connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ibm_systems_director_connection_by_http.py"})), :display-name "IBM Director", :global-configuration-files [], :protocols ("httpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "endpointId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.bound_to_ip_address}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.network_port_number}"})), :input-cit "ip_service_endpoint", :discovered-classes ("ibm_systems_director" "ip_service_endpoint" "node"), :id "ibm_systems_director_connection", :description "Thsi pattern discovers IBM Director using REST API"}, "sap_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "sap_check_credential.py"})), :display-name "Check credential for SAP protocol", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sap_check_credential", :description nil}, "as400_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "as400_check_credential.py"})), :display-name "Check credential for the AS400 protocol", :global-configuration-files [], :protocols ("as400protocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "as400_check_credential", :description nil}, "telnet_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "telnet_check_credential.py"})), :display-name "Check credential for Telnet protocol", :global-configuration-files [], :protocols ("telnetprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "telnet_check_credential", :description nil}, "db2_topology_by_sql" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_pyarg_validator.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_host.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_base_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_base_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_model.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_v9x_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_topology_by_sql.py"})), :display-name "DB2 Topology By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "report_system_tables", :description "Flag indicating whether job should report system tables", :type "boolean"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id:!NA!}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db2_id", :description "", :value "${DB2.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db_name", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${DB2.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${IPSE.network_port_number}"})), :input-cit "db2_database", :discovered-classes ("db2" "db2_database" "db2_buffer_pool" "dbdatafile" "dbtablespace" "db2_partition_group" "db2_partition" "db2_schema" "ip_address" "node" "process" "resource"), :id "db2_topology_by_sql", :description "Discover the physical elements within DB2 database."}, "websphere_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "websphere_check_credential.py"})), :display-name "Check credentials for the Webshpere JMX protocol", :global-configuration-files [], :protocols ("websphereprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "websphere_check_credential", :description nil}, "Oracle_RAC_Topology_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "oracle_rac_topology_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "oracle_shell_utils.py"})), :display-name "Oracle RAC Topology by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "OracleHomes", :description "Used when no ORACLE_HOME environment variable is defined. Value must coincide with the same parameter in Oracle Listeners by Shell Job", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "listened_ips", :description "", :value "${LISTENER.listened_ips:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "listenerName", :description "The name of the running listener", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "listener_process_path", :description "", :value "${PROCESS.process_path}"})), :input-cit "oracle_listener", :discovered-classes ("composition" "containment" "ip_address" "membership" "node" "oracle" "rac" "oracle_listener" "running_software"), :id "Oracle_RAC_Topology_by_Shell", :description "Discovers Oracle RAC topology"}, "AWS_by_WebServices" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "aws.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "aws_store.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "aws_rds.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ec2.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "AWS_by_WebServices.py"})), :display-name "AWS by Web Services", :global-configuration-files [], :protocols ("awsprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("amazon_account" "amazon_ec2_config" "composition" "containment" "membership" "ip_address" "location" "logicalvolume_snapshot" "logical_volume" "uri_endpoint" "configuration_document" "dbsnapshot" "database" "node" "usage"), :id "AWS_by_WebServices", :description "Discovers AWS topologies of the EC2 and RDS services using Web Services"}, "Import_CSV" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "import_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "import_converters.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "csvParser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "file_import.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "csv_import.py"})), :display-name "Import from CSV", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "csvFile", :type "string", :description "Absolute path to the CSV file on the remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "delimiter", :type "string", :description "Delimiter used in CSV file"}) #=(clojure.lang.PersistentArrayMap/create {:name "quoteSymbol", :type "string", :description "Quoting symbol used in CSV file"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping file located in \"Configuration Files\" folder of this package"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column-number : attribute-name (e.g: 0:ip_address, 1:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "rowToStartIndex", :type "string", :description "Index of row to start with. Set this parameter to 2 in order to skip header row"}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."}) #=(clojure.lang.PersistentArrayMap/create {:name "skipEmptyValues", :type "string", :description "Whether to skip empty values. If set to true, empty column values will not be sent."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("configuration_item"), :id "Import_CSV", :description " Imports data from a CSV file into CMDB using mapping of the CSV file columns to CIT attributes. Mapping is defined by the following parameters: ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the CIT attributes to the CSV file columns. Mapping file is used for more complex mapping definitions. Mapping file name is specified by 'mappingFile' parameter."}, "tibco_bw_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tibco_businessworks_by_shell.py"})), :display-name "TIBCO BusinessWorks By Shell", :global-configuration-files [], :protocols ("sshprotocol" "tibcoprotocol" "telnetprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_jms_topology", :description "To discover JMS topology set this to true.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "temp_directory", :description "Temporary directory on the TIBCO Business Works server with read-write access", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "bwId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "bwPath", :description "", :value "${SOURCE.application_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"})), :input-cit "tibco_business_works", :discovered-classes ("composition" "connection" "ip_address" "jmsdestination" "jmsserver" "membership" "node" "tibco_administration_domain" "tibco_application" "tibco_business_works" "tibco_adapter" "usage" "containment" "tibco_ems_server" "ip_service_endpoint"), :id "tibco_bw_by_shell", :description "Discover TIBCO BusinessWorks and its resources"}, "UpdateUDAgent" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Init", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InitUpgrade.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Connect", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ShellOrAgentConnect.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["10"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["210"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["7200000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Ensure remote OS Version is supported", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckRemoteOSVersion.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Lock Scanner Node", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["LockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Agent Basic Resources", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgentBasicResources.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install UD Agent", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgent.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent Install Error Code", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckInstallErrorCode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["90000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["7"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent Installed", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckAgentInstalled.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["120000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["5"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Unlock Scanner Node", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnlockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Upgrade Status", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckUpgradeStatus.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Update UD Agent", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RunUDAgentUnderRootAccount", :description "Install UD Agent to run under root account on Unix machines, otherwise use installing user account (true/false, default true).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "UdAgentInstallCredentialId", :description "UD Agent credential id to be used to install/upgrade UD Agent. Try all if empty.", :type "string", :display-type "UDACredential"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ProtocolList", :description "", :value "${UDA.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "agentId", :description "", :value "${UDA.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "architecture", :description "", :value "${UDA.architecture:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${UDA.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description "", :value "${UDA.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${UDA.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ipTaggingList", :description "", :value "${IP.ip_lease_time:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${UDA.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "macList", :description "", :value "${UDA.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeIpList", :description "", :value "${IP.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeMacList", :description "", :value "${IP.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "platform", :description "", :value "${UDA.platform:NA}"})), :input-cit "node", :discovered-classes ("composition" "uda" "node"), :id "UpdateUDAgent", :description "This adapter updates UD Agent."}, "MS_Cluster_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ms_cluster.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ms_cluster_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "MS_Cluster_Topology.py"})), :display-name "MS Cluster Topology", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol" "powershellprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "agent", :discovered-classes ("cluster_resource_group" "cluster_software" "composition" "configuration_document" "containment" "dependency" "execution_environment" "ip_address" "mscluster" "mscsgroup" "mscsresource" "membership" "node" "ownership" "virtual"), :id "MS_Cluster_Topology", :description "This adapter discovers Microsoft Cluster architecture by NTCMD."}, "iSeries Objects by EView" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "eview400_objects.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "eview400_lib.py"})), :display-name "", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "commandTimeout", :description "Timeout value (in seconds) after which the command issued against the EView agent with timeout", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "Set to true to enable detailed logging in probe debug log", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Jobs", :description "Discover the Active Jobs on the Iseries lpar", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Library", :description " Discover Iseries Library Objects", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Program", :description "Discover Iseries Program Objects", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Queue", :description "Discover the Queues (Job, Output)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ApplicationPath", :description "", :value "${SOURCE.application_path:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "LparName", :description "", :value "${HOST.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "NodeName", :description "", :value "${SOURCE.discovered_product_name}"})), :input-cit "eview", :discovered-classes ("composition" "iseries_file" "iseries_job" "iseries_jobqueue" "iseries_library" "iseries_outqueue" "iseries_program" "membership" "as400_node" "iseriessubsystem"), :id "iSeries Objects by EView", :description "This adapter discovers the IBM ISeries Objects such as Job Queues , Output Queues, Libraries, Files, Programs"}, "SNMP_NET_Dis_HostBase" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SNMP_Networking.py"})), :display-name "Host Networking by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverRoute", :type "string", :description "Indicates if we want to discover the route table"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostIsComplete", :description nil, :value "${HOST.host_iscomplete}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "netAddress", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.snmp_port}"}) #=(clojure.lang.PersistentArrayMap/create {:name "retry", :description nil, :value "${SOURCE.snmp_retry}"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpSupportMultiOid", :description nil, :value "${SOURCE.snmp_supportmultioid}"}) #=(clojure.lang.PersistentArrayMap/create {:name "timeOut", :description nil, :value "${SOURCE.snmp_timeout}"})), :input-cit "snmp", :discovered-classes ("nt" "terminalserver" "membership" "switch" "ras" "vax" "containment" "ip_subnet" "composition" "snmp" "firewall" "netprinter" "netdevice" "parent" "interface" "interfaceindex" "node" "ip_address" "router" "route" "atmswitch" "unnumbered" "lb" "bridge" "unix"), :id "SNMP_NET_Dis_HostBase", :description "Discovers host networking topology using SNMP route and system tables"}, "IpRange_by_nmap" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "IP_range_by_nmap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "nmap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "icmp_utils.py"})), :display-name "IP ping scan by NMAP tool", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :type "string", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character)."}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :type "string", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_location", :type "string", :description "Location of nmap executable tool. If empty nmap is looked in system path"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("ip_address"), :id "IpRange_by_nmap", :description "This adapter performs an IP ping scan on probe range(s) by NMAP tool."}, "TCP_ListenPorts" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Service.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_ListenPorts.py"})), :display-name "TCP Listen Ports", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "services", :type "string", :description "Services to discover, can include number or known name and can be separated by comma (* for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "boolean", :description "Report ports for IPs that not in scope"})), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes ("ip_address" "node" "composition" "ip_service_endpoint" "containment"), :id "TCP_ListenPorts", :description "Discover listening ports on the network according to portNumberToPortName.xml configuration file. Brings data from Universal Discovery database."}, "SNMP_HR_All" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "14", :name "snmp_dis_all.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "Dis_TCP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "snmp_dis_process_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "snmp_dis_user_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "snmp_dis_software_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "snmp_dis_service_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "snmp_dis_disk_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "applications.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "cmdlineutils.py"})), :display-name "Host Resources by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "snmp", :discovered-classes ("winosuser" "windows_service" "containment" "process" "dependency" "ip_address" "node" "running_software" "composition" "usage" "installed_software" "file_system"), :id "SNMP_HR_All", :description "Discovers host resources and software elements"}, "Import_Properties_file" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "properties_file_import.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "file_import.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "import_utils.py"})), :display-name "Import from properties file", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping XML file located in \"Configuration files\" folder of this package"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: key name : attribute-name (e.g: address:ip_address, defaultDomain:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "propertyFile", :type "string", :description "Absolute path to the '.properties' file on remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("configuration_item"), :id "Import_Properties_file", :description " Imports data from a Properties file into CMDB, using mapping of the CSV file columns to CIT attributes   This mapping is usually defined by the setting adapter parameters: ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the Properties attributes to the CSV file columns   In cases you need more complex mapping abilities, such as  conversion of the strings contained in Properties file to the appropriate type of CMDB object's attribute,   you should use the mapping XML configuration file specified by the mappingFile parameter.   "}, "vcloud_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "vcloud_check_credential.py"})), :display-name "Check credential for the vCloud Director", :global-configuration-files [], :protocols ("vcloudprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "vcloud_check_credential", :description nil}, "MS_Domain_Topogy" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ms_domain_topology.py"})), :display-name "MS_Domain_Topogy", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ms_domain_name", :description nil, :value "${SOURCE.name}"})), :input-cit "msdomain", :discovered-classes ("node" "ip_address" "membership" "containment"), :id "MS_Domain_Topogy", :description "Discovers hosts on Microsoft Domain."}, "Apache" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "websphere_plugin_config.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "Apache.py"})), :display-name "Apache Web Servers by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "ntadminprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "configFiles", :type "string", :description "Full path to Apache configuration files, including file names. Multiple files should be separated by ';'"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "serverProcPath", :description nil, :value "${PROCESS.process_path:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "serverProcCmdLine", :description nil, :value "${PROCESS.process_cmdline:NA}"})), :input-cit "shell", :discovered-classes ("apache" "apachemodule" "composition" "configuration_document" "containment" "dependency" "deployed" "httpcontext" "ibmhttpserver" "ip_address" "ip_service_endpoint" "node" "running_software" "usage" "webvirtualhost" "web_server"), :id "Apache", :description "Discovers Apache web servers using the Shell protocols"}, "AS400_NET_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "AS400_Connection.py"})), :display-name "AS400_NET_Dis_Connection", :global-configuration-files [], :protocols ("as400protocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id:NA}"})), :input-cit "ip_address", :discovered-classes ("as400" "composition" "containment" "interface" "ip_address" "ip_subnet" "membership" "node" "parent"), :id "AS400_NET_Dis_Connection", :description "Connects to the AS400 Server using the JT400 Toolbox"}, "SQL_NET_Dis_db2_from_db2" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_net_dis.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "name", :description nil, :value "${SOURCE.discovered_product_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "db2", :discovered-classes ("node" "composition" "db2"), :id "SQL_NET_Dis_db2_from_db2", :description "This package discover the existnace of the db2 database"}, "TNSNamesParser" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "TNSNamesParser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "TNSNamesParsingLib.py"})), :display-name nil, :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "fileName", :description nil, :value "${CONFIGURATION_FILE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "path", :description nil, :value "${CONFIGURATION_FILE.content_location}"})), :input-cit "shell", :discovered-classes ("ip_address" "node" "composition" "oracle" "configuration_document" "containment"), :id "TNSNamesParser", :description "This adapter discovers Oracle databases using tnsnames.ora parsing."}, "NetApp_Filer_by_WebServices" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "NetApp_Filer_by_WebServices.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "netapp_webservice_utils.py"})), :display-name nil, :global-configuration-files [], :protocols ("netappprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "filerOptions", :type "string", :description "This is a comma separated list of options that shoud be retrieved from the Filer"}) #=(clojure.lang.PersistentArrayMap/create {:name "chunkSize", :type "string", :description "Maximum number of objects pulled from NetApp Operations Manager per SOAP call"}) #=(clojure.lang.PersistentArrayMap/create {:name "getSnapShotInfo", :type "string", :description "Set to 'true' to get snapshot details on volumes"}) #=(clojure.lang.PersistentArrayMap/create {:name "getNetworkShareInfo", :type "string", :description "Set to 'true' to get CIFS and NFS share details (requires appropriate ONTAP licenses)"}) #=(clojure.lang.PersistentArrayMap/create {:name "getSnapVaultInfo", :type "string", :description "Set to 'true' to get SnapVault information (requires appropriate ONTAP licenses)"})), :triggered-ci-data (), :input-cit "ip_address", :discovered-classes ("file_system_export" "membership" "cpu" "interface" "memory" "containment" "logicalvolume_snapshot" "dependency" "node" "ip_address" "composition" "logical_volume" "realization" "file_system"), :id "NetApp_Filer_by_WebServices", :description "This adapter discovers volumes, shares and other details on a NetApp filer"}, "SQL_Oracle_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "SQL_Oracle_Connection.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name}"})), :input-cit "oracle", :discovered-classes ("composition" "oracle"), :id "SQL_Oracle_Connection", :description "This adapter discovers the credentials of Oracle database discovered by TNS parser using an Oracle protocol."}, "VMware_ESX_Topology_by_CIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "7", :name "vmware_esx_topology_by_cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "vmware_cim_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "vmware_cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware ESX Topology by CIM", :global-configuration-files [], :protocols ("cimprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${CIM.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "esx_bios_uuid", :description "", :value "${SOURCE.bios_uuid}"}) #=(clojure.lang.PersistentArrayMap/create {:name "esx_cmdb_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hypervisor_cmdb_id", :description "", :value "${HYPERVISOR.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IP.name}"})), :input-cit "vmware_esx_server", :discovered-classes ("composition" "containment" "cpu" "execution_environment" "ip_address" "node" "vmware_esx_server" "vmware_host_resource" "virtualization_layer"), :id "VMware_ESX_Topology_by_CIM", :description "VMware ESX Topology by CIM"}, "snmp_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "snmp_check_credential.py"})), :display-name "Check credential for SNMP protocol", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "snmp_check_credential", :description nil}, "Xen_by_TTY" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "xen_by_tty.py"})), :display-name "Xen and KVM by Shell Adapter", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "virsh_path", :type "string", :description "Path to the virsh management utility"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "Used Protocol", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credentials for the destination host", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "UCMDB ID of the Host", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "Destination IP", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("physical_port" "virtualization_layer" "file_system_export" "execution_environment" "interface" "xen_domain_config" "containment" "layer2_connection" "node" "composition" "realization" "bridge" "file_system" "kvm_domain_config"), :id "Xen_by_TTY", :description "KVM and Xen discovery adapter based on libvirt cli"}, "vCloud_Director_by_vCloud_API" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "vcloud_director_by_vcloud_api.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "vcloud_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "vcloud_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "vcloud.py"})), :display-name "vCloud Director by vCloud API", :global-configuration-files [], :protocols ("vcloudprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVms", :description "Set this parameter to true to report powered off VMs", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_addresses", :description "", :value "${IP.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "vCloudDirectorId", :description "", :value "${VCLOUD_DIRECTOR.root_id}"})), :input-cit "node", :discovered-classes ("ip_address" "node" "interface" "vmware_vcloud" "vmware_vcloud_director" "vcloud_organization" "vcloud_vdc" "vcloud_vapp" "vcloud_vapp_template" "vcloud_media" "vcloud_catalog" "uri_endpoint" "usage" "manage" "composition" "containment" "aggregation"), :id "vCloud_Director_by_vCloud_API", :description "Adapter discovers VMware vCloud Director using vCloud API"}, "JBoss_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jboss.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jboss_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jboss_by_shell.py"})), :display-name "Jboss J2EE Topology Discovery by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address_list", :description nil, :value "${IpAddress.name}"})), :input-cit "shell", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "containment" "membership" "usage" "webservice" "jbossas"), :id "JBoss_By_Shell", :description "This adapter discovers JBoss J2EE environment and components using shell."}, "SNMP_Dis_L2_Bridge" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "bridgePortDisc.py"})), :display-name "L2 Bridge by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "bridgeId", :description nil, :value "${SOURCE.bridge_basemacaddr}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SNMP.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SNMP.application_ip}"})), :input-cit "bridge", :discovered-classes ("layer2_connection" "node" "physical_port" "membership" "composition" "realization" "bridge" "interface"), :id "SNMP_Dis_L2_Bridge", :description "This adapter discovers the Layer 2 topology of a switch by SNMP."}, "aws_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "aws_check_credential.py"})), :display-name "Check credential for the Amazon Web Services", :global-configuration-files [], :protocols ("awsprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "aws_check_credential", :description nil}, "OracleApps" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "OracleApps.py"})), :display-name "Oracle E-Business Suite components", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "schemaName", :type "string", :description "If schema name is specified it will be used to query general system and applications information from database tables"}) #=(clojure.lang.PersistentArrayMap/create {:name "viewSchemaName", :type "string", :description "If schema name is specified it will be used to query general system and applications information from database views"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name:NA}"})), :input-cit "oracle", :discovered-classes ("dbtablespace" "membership" "resource" "deployed" "oracle" "containment" "dependency" "process" "node" "ip_address" "oracleias" "oracleappservice" "composition" "usage" "oracleapplication" "oraclesystem" "oracleappservicemanager" "oraclewebcomponent"), :id "OracleApps", :description "This adapter discovers Oracle E-Business Suite components."}, "SAP_Dis_J2EE_Site" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_jee_topology_by_jmx.py"})), :display-name "SAP J2EE Topology by JMX", :global-configuration-files [], :protocols ("sapjmxprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportComponentsAsConfigFile", :type "string", :description "When set to 'true' report java system components as registry (configuration file). When set to 'false' - report separate CI per component. Default value is 'true'"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sap_jmx_port", :description "", :value "${ServiceAddress.network_port_number:NA}"})), :input-cit "ip_address", :discovered-classes ("webmodule" "messagedrivenbean" "j2ee_sap_central_services" "membership" "deployed" "sap_j2ee_server_process" "containment" "j2eeapplication" "dependency" "ejb" "running_software" "composition" "sap_j2ee_app_server" "ip_service_endpoint" "ejbmodule" "statelesssessionbean" "entitybean" "sap_system" "jdbcdatasource" "sap_j2ee_dispatcher" "configuration_document" "database" "statefulsessionbean" "servlet" "j2eecluster" "ip_address" "node" "usage" "j2eedomain" "sap_java_system_component"), :id "SAP_Dis_J2EE_Site", :description "Discover SAP J2EE environment based on JMX."}, "MS_NET_Dis_Domain" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ms_domains.py"})), :display-name "Discover Microsoft Domains", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "MsDomainsList", :description "MS Domains to be discovered", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probe_name", :description nil, :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("msdomain"), :id "MS_NET_Dis_Domain", :description "Discovers Microsoft Domains, same as: My Network Places->Entire Network."}, "SNMP_NET_Dis_VMS_catalyst" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SNMP_Net_Dis_VMS_catalyst.py"})), :display-name "VMS Catalyst by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpCommunityPostfix", :description "", :value "${VLAN.vlan_id}"})), :input-cit "snmp", :discovered-classes ("bridge" "composition" "containment" "dependency" "membership" "physical_port" "vlan"), :id "SNMP_NET_Dis_VMS_catalyst", :description "Discovers the physical ports on a VLAN"}, "NSLOOKUP_on_Probe" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "NSLOOKUP.py"})), :display-name "NSLOOKUP on Probe", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DNSServerName", :type "string", :description "DNS Server Name"}) #=(clojure.lang.PersistentArrayMap/create {:name "DNSServerDomain", :type "string", :description "DNS Server Domain"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"})), :input-cit "discoveryprobegateway", :discovered-classes ("nt" "ip_address" "node" "netprinter" "unix" "containment"), :id "NSLOOKUP_on_Probe", :description "Discover hosts executing NSLOOKUP command on probe machine's shell"}, "HSRP_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "HSRP_By_SNMP.py"})), :display-name "Cisco HSRP routers by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("node" "ip_address" "membership" "containment"), :id "HSRP_by_SNMP", :description "Discovers Cisco HSRP routers using SNMP protocol."}, "SQL_NET_Dis_sybase_Conn" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sybase_net_dis.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("ip_address" "node" "sybase" "composition" "containment"), :id "SQL_NET_Dis_sybase_Conn", :description "This adapter discovers Sybase database by SQL."}, "CallHomeProcessing" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "CallHomeProcessing.py"})), :display-name "Call Home Processing", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "domain_name", :description "", :value "${SOURCE.domain_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.ip_address}"})), :input-cit "callhome_event", :discovered-classes (), :id "CallHomeProcessing", :description "Call Home Processing"}, "SAP_Dis_Applications" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "sap_applications.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "sapappsutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "saputils.py"})), :display-name "SAP Application Components Discovery", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "getActiveTransactions", :type "string", :description "Get all active transactions and aggregated statistics if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getAllTransactions", :type "string", :description "Get all transactions if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getAppComponents", :type "string", :description "Get all the SAP application components if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getTransChanges", :type "string", :description "Get transaction changes using Change and Transport System"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesDaysInterval", :type "string", :description "Get transaction changes by given number of days back from today"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesFromDate", :type "string", :description "Get transaction changes from this date"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesFromTime", :type "string", :description "Get changes from this time"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesToDate", :type "string", :description "Get transaction changes till this date"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesToTime", :type "string", :description "Get transaction changes till this time"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "instance_number", :description "", :value "${SOURCE.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connection_client", :description "", :value "${SOURCE.connection_client:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "system_name", :description "", :value "${SAP_SYSTEM.name}"})), :input-cit "sap_r3_server", :discovered-classes ("sap_transport" "sap_transport_change" "sap_application_component" "sap_transaction" "composition" "sap_system" "usage" "containment"), :id "SAP_Dis_Applications", :description "Discovers SAP environment based on Computer Center Management System (CCMS). Discovery process can take up to several hours in case long period of time is defined for transaction changes (the 'from' date to the 'to' date)."}, "LDOM_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "15", :name "ldom_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "ldom_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "ldom_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "ldom.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "solaris_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "hostresource.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "hostresource_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "hostresource_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "TTY_HR_CPU_Lib.py"})), :display-name "Oracle VM Server for SPARC Technology by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "match_domain_names_to_hostnames", :description "When enabled guest LDOMs will be reported with their hostnames set to domain names, which may aid in hosts reconciliation.", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "ldom_resource" "hypervisor" "interface" "ip_address" "logical_volume" "layer2_connection" "composition" "containment" "dependency" "realization" "execution_environment" "membership"), :id "LDOM_by_shell", :description "Adapter discovers LDOM topology via control domain."}, "SIEBEL_DIS_DB_NT" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "siebel_discover_odbc.py"})), :display-name "Siebel Database by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "oracle_name", :type "string", :description "Can include several ORACLE_NAME paths (for different machines) comma separated. If empty, uses hard-coded (in the script) registry locations"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_odbcdsn", :description nil, :value "${SOURCE.odbc_dsn}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_svrdsconnstr", :description nil, :value "${SOURCE.srv_ds_conn_str}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_svrdstype", :description nil, :value "${SOURCE.svr_ds_type}"})), :input-cit "siebel_app_server", :discovered-classes ("dependency" "ip_address" "node" "composition" "containment" "database"), :id "SIEBEL_DIS_DB_NT", :description "Discover DB of odbc connection"}, "SQL_APP_Dis_SqlServer" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "9", :name "MSSqlScript.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "SqlServer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "ClusterConfiguration.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "DatabaseProps.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "SqlDatabase.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "SqlServerConfig.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "SqlServerConnection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Queries.py"})), :display-name "MS SQL Server topology by SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigs", :description "True (the default): server configuration ('mssql database configuration.txt') is retrieved.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDbUser", :description "True: database users are discovered; false (the default): database users are not discovered.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSqlFile", :description "True: sql/data files are discovered; false (the default): sql/data files are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSqlJob", :description "True: SQL Jobs are discovered; false (the default): SQL Jobs are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverStoredProcedures", :description "True: SQL Stored Procedure are discovered; false (the default): SQL Stored Procedure are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInternalProcedures", :description "True: Report Internal SQL Stored Procedures from master and msdb databases; false (the default): Internal SQL Stored Procedure from master and msdb are not reported.\\nNote: Internal system procedure begins from such strings 'sp_', 'xp_', 'ms_' and 'sysmail_'", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:}"})), :input-cit "sqlserver", :discovered-classes ("replicated" "sqlfile" "sqldatabase" "sqlserverpublication" "sqlservermaintenanceplan" "sqlbackup" "sqlserversubscription" "configuration_document" "dbuser" "containment" "dblink" "dependency" "process" "ip_address" "node" "ownership" "composition" "sqlserverdistributor" "usage" "sqljob" "sqlserver" "dbclient" "sqlserverpublisher" "file_system" "dbaobjects"), :id "SQL_APP_Dis_SqlServer", :description "The job discovers MS SQL Server topology."}, "WebSphere_Webserver_Dependency" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "websphere_webserver_dependency.py"})), :display-name "Web server to WebSphere Dependency", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "http_context_context_root", :description "", :value "${HTTP_CONTEXT.httpcontext_webapplicationcontext}"}) #=(clojure.lang.PersistentArrayMap/create {:name "http_context_id", :description "", :value "${HTTP_CONTEXT.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "http_context_root_container", :description "", :value "${HTTP_CONTEXT.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "http_context_server", :description "", :value "${HTTP_CONTEXT.httpcontext_webapplicationserver}"}) #=(clojure.lang.PersistentArrayMap/create {:name "web_module_context_root", :description "", :value "${SOURCE.j2eemanagedobject_contextroot}"}) #=(clojure.lang.PersistentArrayMap/create {:name "web_module_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "websphere_full_name", :description "", :value "${WEBSPHERE.j2eeserver_fullname}"})), :input-cit "webmodule", :discovered-classes ("dependency" "httpcontext" "j2eedeployedobject" "running_software"), :id "WebSphere_Webserver_Dependency", :description "Pattern discovers dependencies between web servers and WebSphere application servers."}, "LDAP_Active_Directory_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "LDAP_Active_Directory_Connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "active_directory_utils.py"})), :display-name "LDAP Active Directory Connection", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description "Value referes to the DN under which records about domain controller servers are stored. Default value is OU=Domain Controllers"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_number", :description "", :value "${Service_Address.network_port_number}"})), :input-cit "ip_address", :discovered-classes ("node" "ip_address" "domaincontroller" "composition" "containment"), :id "LDAP_Active_Directory_Connection", :description "Discover the existence of Active Directory Domain Controlers via LDAP"}, "oracle_tns_names_by_ldap" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "active_directory_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "oracle_ldap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "oracle_by_ldap.py"})), :display-name "Oracle TNS Names by LDAP", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDN", :description "LDAP root node from which will be search orclContext objects"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SERVICE_ADDRESS.network_port_number}"})), :input-cit "domaincontroller", :discovered-classes ("composition" "containment" "ip_service_endpoint" "usage" "realization" "ip_address" "node" "oracle" "oracle_servicename" "oracle_listener"), :id "oracle_tns_names_by_ldap", :description "This adapter discovers Oracle database topology by SQL."}, "hp_nonstop_topology_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "hpnonstop_topology_by_shell.py"})), :display-name nil, :global-configuration-files [], :protocols ("sshprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeName", :description "", :value "${HOST.name:NA}"})), :input-cit "shell", :discovered-classes ("hp_nonstop" "nonstop_sql_mx" "composition" "database_instance" "database"), :id "hp_nonstop_topology_by_shell", :description "HP NonStop topology discovery."}, "InventoryDiscoveryByManualScannerDeployment" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Parse Manually Enriched Scan File", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ParseManuallyEnrichedScanFile.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Inventory Discovery by Manual Scanner Deployment", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:display-type "MappingConfiguration", :name "MappingConfiguration", :description "Specifies scan file model mapping configuration.", :type "xml"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("composition" "containment" "installed_software" "ip_address" "node" "cpu" "hardware_board" "graphics_adapter" "disk_device" "display_monitor" "inventory_scanner" "file_system" "file_system_export"), :id "InventoryDiscoveryByManualScannerDeployment", :description "This adapter executed hardware and installed software inventory discovery by manually deployed scanfile."}, "ICMP_NET_Dis_IpNetwork" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "IP_by_Network.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "icmp_utils.py"})), :display-name "IP ping sweep", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :description "Ping time out (Ms)", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :description "Ping retry", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "virtualModeDiscover", :description "Flag that indicates if we want to discover the virtual ips", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :type "string", :description "Ping protocol: ICMP (1), ECHO PORT (2) or both (3)"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :type "string", :description "Number of threads in pool that performs port 7 echoing"}) #=(clojure.lang.PersistentArrayMap/create {:name "byScopeDiscover", :description "Flag that indicates if we ping ips out of scope", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "netAddress", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "netMask", :description nil, :value "${SOURCE.network_netmask}"}) #=(clojure.lang.PersistentArrayMap/create {:name "domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description nil, :value "${SOURCE.network_probename}"})), :input-cit "ip_subnet", :discovered-classes ("dependency" "ip_address" "ip_subnet" "membership"), :id "ICMP_NET_Dis_IpNetwork", :description "Performs IP ping sweep"}, "TTY_HR_All" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "31", :name "TTY_HR_Main.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "30", :name "TTY_HR_Share_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "29", :name "TTY_HR_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "28", :name "TTY_HR_CPU_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "27", :name "TTY_HR_Software_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "26", :name "TTY_HR_User_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "25", :name "TTY_HR_Memory_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "24", :name "TTY_HR_Disk_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "23", :name "NTCMD_HR_REG_Service_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "22", :name "NTCMD_HR_Dis_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "21", :name "NTCMD_HR_REG_Software_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "20", :name "NTCMD_HR_Dis_Memory_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "19", :name "NTCMD_HR_Dis_Disk_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "memory.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "Dis_TCP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "applications.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "process_to_process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "hostresource_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "hostresource_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "hostresource.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "distinguished_name.py"})), :display-name "Host Resources by TTY", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery.In case this value is true, all installed softwares are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery. For Windows machines only Local Users are discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "lsofPath", :type "string", :description "Path where lsof command can be found for process communication discovery on UNIX machines."}) #=(clojure.lang.PersistentArrayMap/create {:name "useLSOF", :type "string", :description "When the parameter is set to true, discovery tries to use LSOF utility to discover process-to-port information on Unix machines."}) #=(clojure.lang.PersistentArrayMap/create {:name "useNetstatOnly", :type "string", :description "Use only netstat command during discovery TCP data. All lsof parameters will be ignored."}) #=(clojure.lang.PersistentArrayMap/create {:name "wmicPath", :type "string", :description "Default wmic path"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "shell", :discovered-classes ("osuser" "file_system_export" "cpu" "windows_service" "containment" "process" "dependency" "client_server" "ip_address" "node" "running_software" "iisapppool" "composition" "usage" "realization" "ip_service_endpoint" "installed_software" "file_system"), :id "TTY_HR_All", :description "Discovers host resources, process connectivity and software elements on UNIX and Windows machines using SSH, Telnet, NTCMD or UDA protocols."}, "TCP_NET_Dis_Port" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "TcpPortScanner.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "nmap.py"})), :display-name "TCP Ports Discovery", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "checkIfIpIsReachable", :description "Flag that indicates if we want to check if the discovered IP is reachable before we ping its ports (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "checkOnlyKnownPorts", :description "Discover only known ports. This flag does not cancel 'ports' parameter - overriding this flag to false is applicable only with real ports range in 'ports' parameter", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "connectTimeOut", :description "The timeout when connecting to IP and port", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmapPath", :description "Full path to nmap executable file. (e.g. C:\\Program Files (x86)\\Nmap\\nmap.exe)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingTimeOut", :description "ICMP ping timeout Ms", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of TCP ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "scanUDP", :description "Flag indicating to scan UDP ports. Note: UDP scan support only if nmap is used", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "UDPports", :description "List of UDP ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("composition" "containment" "ip_address" "ip_service_endpoint" "node"), :id "TCP_NET_Dis_Port", :description "Discover open tcp\\udp ports on a host of known server ports."}, "SNMP_NET_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "SNMP_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "SNMP_Connection.py"})), :display-name "Host Connection by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_cmdbid", :description "", :value "${NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_key", :description "", :value "${HOST.host_key:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_addrs", :description "", :value "${NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_mac", :description "", :value "${SOURCE.arp_mac:NA}"})), :input-cit "ip_address", :discovered-classes ("atmswitch" "composition" "containment" "fcswitch" "firewall" "interface" "ip_address" "ip_subnet" "ldom_virtual_switch" "lb" "mainframe" "marconiatmswitch" "membership" "netdevice" "netprinter" "node" "parent" "ras" "router" "snmp" "switch" "terminalserver" "unix" "vax" "vmware_virtual_switch" "nt"), :id "SNMP_NET_Dis_Connection", :description "Discovers SNMP agents by trying to connect to a data center machine using the SNMP protocol, updates the node class (Windows, UNIX, router, and so on) according to the relevant OID"}, "Host_Connection_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ConnectedOSCredentialFinder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "clientdiscoveryutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "aix_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "hpux_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "hpnonstop_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "linux_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "networking_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "NTCMD_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "solaris_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "ibm_hmc_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "ibm_hmc_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "19", :name "TTY_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "20", :name "HostConnectionByShell.py"})), :display-name "Host Connection by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :type "string", :description "Discovered machine language"}) #=(clojure.lang.PersistentArrayMap/create {:name "udaConnectionOrder", :description "When should be the position of UD Protocol in the protocol connections order. Possible values: first, last, none", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useAIXhwId", :type "string", :description "Identify IBM AIX machines using hardware Id. Note: when set as true and used along with SNMP discovery, duplicate hosts might be created. When set as false no AIX LPAR will be discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "enableStamping", :type "string", :description "Whether to enable stamping ud_unique_id to the managed computer"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyStampingClient", :type "string", :description "Whether to only stamp on client IP. If turned off, it will be set in any case (both data centre and client)."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description "", :value "${SHELL.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_cmdbid", :description "", :value "${NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_key", :description "", :value "${HOST.host_key:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_addrs", :description "", :value "${NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_mac_address", :description "", :value "${SOURCE.arp_mac:NA}"})), :input-cit "ip_address", :discovered-classes ("hp_nonstop" "snmp" "nt" "terminalserver" "membership" "parent" "switch" "ras" "vax" "interface" "ssh" "ip_subnet" "containment" "telnet" "ntcmd" "uda" "ip_address" "usage" "realization" "sea_adapter" "node" "running_software" "router" "atmswitch" "dns_server" "composition" "unix" "ipmp_group"), :id "Host_Connection_By_Shell", :description "Establishes a Shell connection to the remote machines. Discovery tries to connect to remote machines through the SSH, Telnet, NTCMD or UDA protocols until the first valid connection is found."}, "InventoryDiscoveryByScanner" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Scanner Connect", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ScannerConnect.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["10"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["210"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["7200000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Lock Scanner Node", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["LockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "UD Unique ID check", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UDUniqueIDCheck.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Scan File Existence", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckScanFileExistence.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Upgrade Scanner", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UpgradeScanner.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Run Scanner", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["RunScanner.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Scanner Finished", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckScannerFinished.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["10"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["210"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["7200000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Download Scan File", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["DownloadScanFile.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Remove Scan Data", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["RemoveScanData.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Unlock Scanner Node", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnlockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Wait XML Enricher Process", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["WaitEnricherProcess.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :eventParking, :attrs #=(clojure.lang.PersistentArrayMap/create {:timeout "43200000", :eventName "enrichedFileFound"}), :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Parse Enriched Scan File", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ParseEnrichedScanFile.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Inventory Discovery By Scanner Adapter", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "IsScannerDowngradeAllowed", :description "Specifies if scanner downgrade is allowed", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsScannerUpgradeAllowed", :description "Specifies if scanner upgrade is allowed", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsPrePostScriptAllowed", :description "Specifies if allow scanner run pre-scan/post-scan scripts", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrePostScriptExecTimeout", :description "Pre-scan/post-scan script maximum runtime(min)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RemoveScanData", :description "Remove Scan data on remote host after it was downloaded on probe machine.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DownloadScanFileBeforeExecution", :description "Download Scan File from remote machine (if exists) before execution.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ScannerConfigurationFile", :description "Specifies configuration file name which should be uploaded with scanner and used for scanner execution.", :type "xml", :display-type "ScannerConfigurationPerPlatform"}) #=(clojure.lang.PersistentArrayMap/create {:display-type "MappingConfiguration", :name "MappingConfiguration", :description "Specifies scan file model mapping configuration.", :type "xml"}) #=(clojure.lang.PersistentArrayMap/create {:name "enableStamping", :type "string", :description "Whether to enable stamping ud_unique_id to the managed computer"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyStampingClient", :type "string", :description "Whether to only stamp on client IP. If turned off, it will be set in any case (both data centre and client)."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."}) #=(clojure.lang.PersistentArrayMap/create {:name "collectIPv6Connectivity", :type "string", :description "If collect IPv6 related connectivity"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ProtocolList", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${SHELL.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "macList", :description "", :value "${SHELL.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ipTaggingList", :description "", :value "${IP.ip_lease_time:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeGUID", :description "", :value "${SOURCE.ud_unique_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeIpList", :description "", :value "${IP.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeMacList", :description "", :value "${IP.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "scannerVersion", :description "", :value "${SCANNER.version:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "scanFileLastDownloadedTime", :description "", :value "${SCANNER.scan_file_last_downloaded_time:NA}"})), :input-cit "node", :discovered-classes ("composition" "containment" "installed_software" "ip_address" "node" "cpu" "hardware_board" "graphics_adapter" "disk_device" "display_monitor" "inventory_scanner" "file_system" "file_system_export" "process" "running_software" "ip_service_endpoint" "realization" "usage" "dependency"), :id "InventoryDiscoveryByScanner", :description "This adapter executed hardware and installed software inventory discovery by scanners."}, "Glassfish_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "glassfish.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "glassfish_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "glassfish_by_shell.py"})), :display-name "Glassfish JEE Topology Discovery by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportAdminApps", :description "enables/disables reporting of administrator applications if value is 'true'/'false'.", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "ip_address" "j2eedomain" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "composition" "dependency" "deployed" "membership" "usage" "webservice" "glassfishas"), :id "Glassfish_By_Shell", :description "This adapter discovers Glassfish JEE environment and components using shell."}, "SolarisZone_Disc_By_TTY" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "solaris_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "SolarisZone_Disc_By_TTY.py"})), :display-name "Solaris Zone by TTY", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "zloginWithConnectedUser", :description "If true zlogin will be done with connected to global zone user account. If false then zlogin will use root account", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_manufacturer", :description nil, :value "${HOST.discovered_vendor:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_model", :description nil, :value "${HOST.discovered_model:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_vendor", :description nil, :value "${HOST.discovered_os_vendor:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("file_system_export" "membership" "cpu" "parent" "interface" "ip_subnet" "containment" "solaris_resource_pool" "node" "ip_address" "fchba" "realization" "composition" "usage" "solaris_zone_config" "ipmp_group" "file_system" "execution_environment" "hypervisor"), :id "SolarisZone_Disc_By_TTY", :description "This adapter discovers Solaris Zones by shell protocols (SSH, Telnet or UDA) including non-global zones, resource pools, netwroking CPU and their dependencies."}, "VMware_ESX_Connection_by_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "vmware_esx_connection_by_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware ESX Connection by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"})), :input-cit "node", :discovered-classes ("virtualization_layer" "composition" "vmware_esx_server"), :id "VMware_ESX_Connection_by_VIM", :description "adapter discovers VMware ESX Servers running on Unix hosts."}, "Veritas_Cluster_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Veritas_Cluster_Topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "Veritas Cluster Topology", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"}) #=(clojure.lang.PersistentArrayMap/create {:name "main_cf_path", :type "string", :description "Veritas Main.cf folder. Default: /etc/VRTSvcs/conf/config/"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("membership" "veritascluster" "configuration_document" "containment" "vcsresource" "dependency" "vcsgroup" "node" "ip_address" "ownership" "running_software" "composition" "usage" "cluster_software" "ip_service_endpoint"), :id "Veritas_Cluster_Topology", :description "Discover Veritas cluster server architecture by Shell"}, "JMX_Only_J2EE_WebSphere" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "websphere.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "websphere_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_WebSphere.py"})), :display-name "Websphere J2EE Topology Discovery by JMX", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "websphereprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "applications", :description "List of applications to discover (comma separated)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigFile", :description "Discover additional configuration files for cell, server, and application, if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverEAR", :description "Discover J2ee application EAR files if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJDBCResources", :description "Discover jdbc providers and datasources if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "servers", :description "List of servers to discover (comma separated)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description "", :value "${SOURCE.j2eeserver_protocol}"}) #=(clojure.lang.PersistentArrayMap/create {:name "version", :description nil, :value "${SOURCE.application_version}"})), :input-cit "websphereas", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :id "JMX_Only_J2EE_WebSphere", :description "This adapter discovers WebSphere J2EE environment and components."}, "DB_Connect_by_Agent" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "5", :name "DB_Connect_by_Agent.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "dbconnect_oracle.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "dbconnect_agentutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "dbconnect_mssql.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "dbconnect_utils.py"})), :display-name "Database Connections by Agent", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_oracle", :type "string", :description "Set to \"true\" for Oracle identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_mssql", :type "string", :description "Set to \"true\" for Microsoft SQL Server  identification"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "wmi", :discovered-classes ("nt" "ip_address" "node" "composition" "ip_service_endpoint" "sqlserver" "oracle" "containment"), :id "DB_Connect_by_Agent", :description "Identifies databases on hosts using host credentials using the WMI protocol"}, "SIEBEL_DIS_DB_UNIX" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "siebel_discover_odbc.py"})), :display-name "Siebel Database by Unix shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelRootDir", :description nil, :value "${SOURCE.install_dir}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_odbcdsn", :description nil, :value "${SOURCE.odbc_dsn:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_svrdsconnstr", :description nil, :value "${SOURCE.srv_ds_conn_str}"}) #=(clojure.lang.PersistentArrayMap/create {:name "siebelappserver_svrdstype", :description nil, :value "${SOURCE.svr_ds_type}"})), :input-cit "siebel_app_server", :discovered-classes ("dependency" "ip_address" "node" "composition" "database" "containment"), :id "SIEBEL_DIS_DB_UNIX", :description "Discover DB of odbc connection"}, "TCP_ServicesConnectivity" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Service.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Services_Connectivity.py"})), :display-name "TCP Services Connectivity", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "maxPorts", :type "string", :description "Number of most important ports reported for each traffic link"}) #=(clojure.lang.PersistentArrayMap/create {:name "tcpOnly", :type "boolean", :description "Should discover only tcp traffic"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "boolean", :description "Report traffic from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "boolean", :description "Report traffic from client found in flows but not in scope"})), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes ("ip_address" "node" "traffic" "containment"), :id "TCP_ServicesConnectivity", :description "Discovers the IP Communication adapters - which IPs communicte and the top interesting ports for these communication channels. Brings data from Universal Discovery database."}, "JMX_J2EE_JBoss_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "jboss.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "jboss_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_JBoss_Connection.py"})), :display-name "Jboss Server Discovery", :global-configuration-files [], :protocols ("jbossprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "", :value "${SERVICE_ADDRESS.network_port_number:NA}"})), :input-cit "ip_address", :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "usage" "ip_service_endpoint" "containment" "membership" "ip_address" "jbossas"), :id "JMX_J2EE_JBoss_Connection", :description "This adapter discovers JBoss servers instances based on the JMX protocol."}, "ServiceNowPushAdapter" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "com.hp.ucmdb.adapters.push.PushAdapter"})), :display-name "Service-Now Push", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ServiceNowDomain", :description "The Service-Now Instance Domain Name (Default: service-now.com)", :type "string", :display-name "Service-Now Domain", :mandatory "true", :order-index "10"}) #=(clojure.lang.PersistentArrayMap/create {:name "ServiceNowInstance", :description "The Service-Now Instance Name (Default: demo)", :type "string", :display-name "Service-Now Instance", :mandatory "true", :order-index "10"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "The Service-Now connection port (Default: 443))", :type "integer", :display-name "Port", :mandatory "true", :order-index "11"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description "The Service-Now connection protocol (Can be http or https, Default: https))", :type "string", :display-name "Protocol", :mandatory "true", :order-index "11"}) #=(clojure.lang.PersistentArrayMap/create {:name "ProxyServer", :description "Proxy server name/IP (if required for outgoing Internet connections)", :type "string", :display-name "Proxy Server Name/IP", :mandatory "false", :order-index "12"}) #=(clojure.lang.PersistentArrayMap/create {:name "ProxyPort", :description "Proxy server port (if required for outgoing Internet connections)", :type "integer", :display-name "Proxy Server Port", :mandatory "false", :order-index "12"}) #=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "The values will be automaticly replaced by the UCMDB UI", :type "string", :mandatory "true", :display-name "Probe", :order-index "13"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "The credentials to be used", :type "integer", :display-name "Credentials ID", :mandatory "true", :order-index "13"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "adapterId", :description "", :value "${ADAPTER.adapter_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "attributeValues", :description "", :value "${SOURCE.attribute_values}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "destinationId", :description "", :value "${SOURCE.destination_id}"})), :input-cit "destination_config", :discovered-classes ("link" "object"), :id "ServiceNowPushAdapter", :description "Adapter to push data from uCMDB to Service-Now.com"}, "ibm_tivoli_network_manager_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ibm_tnm_via_shell.py"})), :display-name "IBM Tivoli Network Manager", :global-configuration-files [], :protocols ("sshprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dla_config_file_name", :description "Configuration file which is used to export IdML", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ncp_dla_executable_path", :description "Filesystem path to ncp_dla.sh", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes (), :id "ibm_tivoli_network_manager_by_shell", :description "This adapter populates network topology using the XML file generated by IBM Tivoli Network Manager Discovery Library Adapter (DLA)"}, "SQL_NET_Dis_Connection_Sybase" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SQL_Connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "Sybase Connection By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_ip", :description "", :value "${DB.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${DB.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_ip", :description "", :value "${SA.bound_to_ip_address:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_port", :description "", :value "${SA.network_port_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${DB.name:NA}"})), :input-cit "node", :discovered-classes ("sybase" "composition" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :id "SQL_NET_Dis_Connection_Sybase", :description "This adapter discovers databases using SQL protocol."}, "EView iSeries Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "eview400_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "eview400_connection.py"})), :display-name "", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "EViewInstallationFolder", :description "Installation root directory of the EView client on the probe server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "This flag (True/False) provides additional debug information in the debug logs.", :type "string"})), :triggered-ci-data (), :input-cit "discoveryprobegateway", :discovered-classes ("as400_node" "composition" "containment" "eview" "ip_address"), :id "EView iSeries Connection", :description "This discovery adapterconnects to the Eview iSeries Agent "}, "JMX_J2EE_WebSphere" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "websphere.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "websphere_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_WebSphere.py"})), :display-name "Websphere J2EE Topology Discovery by JMX", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "websphereprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "applications", :type "string", :description "List of applications to discover (comma separated)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :type "string", :description "Discover modules, ejbs and servlets if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigFile", :type "string", :description "Discover additional configuration files for cell, server, and application, if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverEAR", :type "string", :description "Discover J2ee application EAR files if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJDBCResources", :type "string", :description "Discover jdbc providers and datasources if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :type "string", :description "Discover jms providers and jms servers if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "servers", :type "string", :description "List of servers to discover (comma separated)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip", :description nil, :value "${SHELL.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description nil, :value "${SHELL.root_class:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "shellCredentialsId", :description nil, :value "${SHELL.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "version", :description nil, :value "${SOURCE.application_version}"})), :input-cit "websphereas", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :id "JMX_J2EE_WebSphere", :description "This adapter discovers WebSphere J2EE environment and components."}, "UninstallUDAgent" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Init", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InitUninstallAgent.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Connect", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ShellOrAgentConnect.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["10"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["210"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["7200000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Lock Scanner Node", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["LockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Uninstall Agent Basic Resources", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgentBasicResources.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Uninstall Agent", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnInstallAgent.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["300000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent UnInstalled", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckAgentUnInstalled.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["120000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["5"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Unlock Scanner Node", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnlockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Remove Agent Data", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["RemoveAgentData.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Delete And Report Shell", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["DeleteAndReportShell.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Uninstall UD Agent", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "RemoveAgentData", :description "Remove Agent data on remote host after the Agent itself was uninstalled. (e.g. log file, utilization data, etc.", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ProtocolList", :description "", :value "${UDA.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "agentId", :description "", :value "${UDA.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${UDA.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description "", :value "${UDA.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${UDA.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ipTaggingList", :description "", :value "${IP.ip_lease_time:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${UDA.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "macList", :description "", :value "${UDA.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeIpList", :description "", :value "${IP.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeMacList", :description "", :value "${IP.arp_mac:NA}"})), :input-cit "node", :discovered-classes ("composition" "node" "ntcmd" "ssh" "telnet"), :id "UninstallUDAgent", :description "This adapter uninstalls UD Agent."}, "SQL_APP_Dis_Db2" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_pyarg_validator.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_host.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_base_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_base_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_model.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_v9x_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_sql_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db2_topology_by_sql.py"})), :display-name "DB2 Topology By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "report_system_tables", :description "Flag indicating whether job should report system tables", :type "boolean"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db2_id", :description "", :value "${DB2.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "db_name", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${DB2.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${IPSE.network_port_number}"})), :input-cit "db2_database", :discovered-classes ("db2" "db2_database" "db2_buffer_pool" "dbtable" "dbdatafile" "dbtablespace" "db2_partition_group" "db2_partition" "db2_schema" "ip_address" "ip_service_endpoint" "node" "process" "resource" "composition" "containment" "usage" "membership"), :id "SQL_APP_Dis_Db2", :description "Discover the physical elements within DB2 database."}, "Merge_Clustered_Software" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "mergeClusteredSoftware.py"})), :display-name "Merge Clustered Software", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "className", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "clusteredContainer", :description "", :value "${ClusterResourceGroup.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "clusteredUcmdbIds", :description "", :value "${CLUSTEREDSOFTWARE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "discProdName", :description "", :value "${SOURCE.discovered_product_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "localHostId", :description "", :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "localSoftwareId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "productName", :description "", :value "${SOURCE.product_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteSoftwareName", :description "", :value "${CLUSTEREDSOFTWARE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "softwareName", :description "", :value "${SOURCE.name}"})), :input-cit "running_software", :discovered-classes ("node" "running_software"), :id "Merge_Clustered_Software", :description "Adapter used by the Merging topologies of the Clustered Software Elements"}, "NNM_Update_Ids" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "nnmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "NNM_Update_Ids.py"})), :display-name "Push IDs into NNMi", :global-configuration-files [], :protocols ("nnmprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP Address of the NNMi Server", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes (), :id "NNM_Update_Ids", :description "Updates the nodes in the NNM topology with the UCMDB IDs of the corresponding nodes in UCMDB"}, "IBM_HMC_SHELL_PATTERN" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ibm_hmc_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "ibm_hmc_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "storage_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ibm_hmc_lib.py"})), :display-name "IBM Virtualization by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportLparNameAsHostName", :description "Should the job report virtual host names as Lpar names.", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "The IP Address of the destination", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "The Probe Ip Domain", :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("shell" "physical_port" "virtualization_layer" "membership" "execution_environment" "scsi_adapter" "ibm_resource_pool" "ibm_lpar_profile" "cpu" "ioslot" "manage" "interface" "ibm_hmc" "containment" "ibm_pseries_frame" "ip_address" "node" "composition" "usage" "realization" "vlan" "ibm_ivm"), :id "IBM_HMC_SHELL_PATTERN", :description "Discovery adapter for IBM HMC or IVM Software and related Virtualization PSeries Solution discovery"}, "VMware_VirtualCenter_Connection_by_WMI_and_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_virtualcenter_connection_by_wmi_and_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware VirtualCenter Connection by WMI and VIM", :global-configuration-files [], :protocols ("vmwareprotocol" "wmiprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${WMI.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${WMI.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_addresses", :description "", :value "${IpAddress.name}"})), :input-cit "node", :discovered-classes ("node" "ip_address" "composition" "vmware_virtual_center" "containment"), :id "VMware_VirtualCenter_Connection_by_WMI_and_VIM", :description "adapter discovers the VMware VirtualCenter connection using Virtual Infrastructure Management protocol.  If VIM port is specified in credentials, this port will be used. Otherwise it tries to connect to host using WMI protocol and retrieves the VirtualCenter's port information from registry.  The retrieved information is used to generate the connection URL."}, "Oracle Application Server" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "OracleAplicationServer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "oracle_shell_utils.py"})), :display-name "Oracle Application Server", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("composition" "dependency" "ip_address" "node" "containment" "oc4j" "oc4jgroup" "oracleias" "running_software" "uri_endpoint"), :id "Oracle Application Server", :description "Discovers Oracle Application Server"}, "MICROSOFT_MQ" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "active_directory_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ldap_msmq.py"})), :display-name "Microsoft MQ server from Active Directory", :global-configuration-files [], :protocols ("ldapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description ""})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SERVICE_ADDRESS.network_port_number}"})), :input-cit "domaincontroller", :discovered-classes ("activedirectorysite" "node" "ip_address" "msmqmanager" "activedirectoryforest" "membership" "composition" "usage" "activedirectorysystem" "containment"), :id "MICROSOFT_MQ", :description "Discovery adapter for Microsoft MQ server. Used to retrieve Active Directory side information of MS MQ topology."}, "UDDI_Registry_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "UDDI_Registry_Connection.py"})), :display-name "UDDI Registry Connection", :global-configuration-files [], :protocols ("uddiregistryprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.discoveryprobemanager_probeName}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.discoveryprobemanager_ip}"})), :input-cit "discoveryprobemanager", :discovered-classes ("uddiregistry"), :id "UDDI_Registry_Connection", :description "This adapter discovers the UDDI registry using a given URL."}, "SIEBEL_DIS_WEBAPPS_NT" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "siebel_discover_wse.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "NTCMD_HR_REG_Software_Lib.py"})), :display-name "Siebel Web Applications by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"})), :input-cit "web_server", :discovered-classes ("dependency" "ip_address" "node" "siebel_wse" "route" "siebel_site" "siebel_web_app" "composition" "configuration_document" "siebel_gateway" "web_server" "containment"), :id "SIEBEL_DIS_WEBAPPS_NT", :description "This adapter discovers Siebel Webserver Extension and all web applications by NTCMD or UDA protocol."}, "tcp_discovery_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "tcp_discovery_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "tcp_discovery_basic.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "TTY_HR_Process_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "Dis_TCP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "TCP Discovery by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "CaptureProcessInformation", :type "string", :description "Whether to capture processes information"}) #=(clojure.lang.PersistentArrayMap/create {:name "DelayBetweenTCPSnapshots", :type "string", :description "Pause in seconds between discovery cycles"}) #=(clojure.lang.PersistentArrayMap/create {:name "NumberOfTCPSnapshots", :type "string", :description "The count of discovery cycles on particular destination"}) #=(clojure.lang.PersistentArrayMap/create {:name "lsofPath", :type "string", :description "Path where lsof command can be found"}) #=(clojure.lang.PersistentArrayMap/create {:name "useLSOF", :type "string", :description "On Unix machine we can find port to process mapping with lsof command(if installed)"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNetstatOnly", :type "string", :description "Use only netstat command during discovery TCP data. All lsof parameters will be ignored."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip:unknown}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"})), :input-cit "shell", :discovered-classes (), :id "tcp_discovery_by_shell", :description "Discovers TCP information on particular host. Allows multiple discovery cycles to obtain temporary short-lived connections. Reports nothing to UCMDB but collected data used by other jobs to link other CIs to TCP data (like Host resources jobs)."}, "jboss_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx_check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "jboss_check_credential.py"})), :display-name "Check credential for the JBoss JMX protocol", :global-configuration-files [], :protocols ("jbossprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "jboss_check_credential", :description nil}, "ECC_Discovery" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ECC_Discovery.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "EMC Control Center", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${SOURCE.name}"})), :input-cit "oracle", :discovered-classes ("composition" "containment" "cpu" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "node" "storagearray" "storagefabric" "storageprocessor" "unix" "nt"), :id "ECC_Discovery", :description "Populates storage devices and SAN infrastructure from the EMC control Center SRM database"}, "generic_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "generic_check_credential.py"})), :display-name "Check credential for Generic protocol", :global-configuration-files [], :protocols ("genericprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "generic_check_credential", :description nil}, "CiscoWorks_NetDevices" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "CiscoWorks_NetDevices.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ciscoworks_utils.py"})), :display-name "CiscoWorks NetDevices", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryChunkSize", :description "Number of nodes to query at a time (Default: 250)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "rmeDbName", :description "Name of the CiscoWorks Resource Manager Essentials database in Sybase (default: rmengdb)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "db_port", :description "", :value "${SOURCE.network_port_number}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.bound_to_ip_address}"})), :input-cit "ip_service_endpoint", :discovered-classes ("composition" "containment" "hardware_board" "interface" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :id "CiscoWorks_NetDevices", :description "This adapter populates network devices and layer two infrastructure from the Cisco Works Resource Manager Essentials database"}, "sim_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "sim_check_credential.py"})), :display-name "Check credential for SIM protocol", :global-configuration-files [], :protocols ("simprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sim_check_credential", :description nil}, "Atrium to UCMDB" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "atrium_to_ucmdb.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "atrium_map.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "atrium_query.py"})), :display-name "Population from Atrium", :global-configuration-files [], :protocols ("remedyprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ARS_Server", :description "Hostname or IP address of the BMS ARS server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARS_Port", :description "Port for connecting to the ARS server. If portmapper is being used, this should be  left as 0, else specify the TCP port", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "BMC_NameSpace", :description "The BMC NameSpace to use (E.g. BMC.CORE)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :description "Chunk size in which the data should be retrieved from the remote server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DateParsePattern", :description "Set the Date pattern to parse Atrium date strings", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :description "Set to true to run integration in debug mode. I.e. not send any data to UCMDB.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (), :input-cit "discoveryprobegateway", :discovered-classes (), :id "Atrium to UCMDB", :description "Populates CIs and relationships from BMC Atrium"}, "CiscoWorks_Layer2" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "CiscoWorks_Layer2.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ciscoworks_utils.py"})), :display-name "CiscoWorks Layer 2", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "campusDbName", :description "Name of the CiscoWorks Campus database in Sybase (default: aniDB)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryChunkSize", :description "Number of nodes to query at a time (Default: 1000)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "db_port", :description "", :value "${SOURCE.network_port_number}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.ip_address}"}) #=(clojure.lang.PersistentArrayMap/create {:name "netdevice_cmdbid", :description "", :value "${NetDevice.global_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "netdevice_name", :description "", :value "${NetDevice.data_externalid}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_cmdbid", :description "", :value "${PhysicalPort.global_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_container_cmdbid", :description "", :value "${PhysicalPort.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_index", :description "", :value "${PhysicalPort.port_index}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_name", :description "", :value "${PhysicalPort.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port_vlan", :description "", :value "${PhysicalPort.port_vlan}"})), :input-cit "ip_service_endpoint", :discovered-classes ("composition" "containment" "hardware_board" "interface" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :id "CiscoWorks_Layer2", :description "This adapter populates nodes layer two infrastructure from the Cisco Works Campus Manager database"}, "WebserviceByURL" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "WebserviceByURL.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Webservice_Utils.py"})), :display-name "Web Services by URL", :global-configuration-files [], :protocols ("httpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "autoAcceptCerts", :description "Temporary accept received certificates as trusted", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "importWsdlDocuments", :type "string", :description "If set to true, imported WSDL documents will be retrieved and processed."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_ips", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "wsdl_url", :description "", :value "${SOURCE.uri:NA}"})), :input-cit "uri_endpoint", :discovered-classes ("webservice_operation" "dependency" "composition" "webservice" "configuration_document" "containment" "uri_endpoint"), :id "WebserviceByURL", :description "Discovers the Webservice topology by reading WSDL content from a given URL"}, "SQL_NET_Dis_Connection_DB2" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "17", :name "db2_connection_by_sql.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "db2_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "db2_sql_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "db2_sql_v9x_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "db2_model.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "db2_base_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "db2_sql_base_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "db2_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "db2_host.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "db2_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "db2_pyarg_validator.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "iteratortools.py"})), :display-name "DB2 Connection By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :description "Used protocol type", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "db_name", :description "", :value "${Db2Database.name:!NA!}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentials_id", :description "", :value "${Db2Database.credentials_id:!NA!}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SA.network_port_number:!NA!}"})), :input-cit "node", :discovered-classes ("db2" "db2_database" "ip_service_endpoint" "node" "composition" "usage"), :id "SQL_NET_Dis_Connection_DB2", :description "This adapter discovers databases using SQL protocol."}, "TTY_Net_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "networking_win"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "networking_win_shell"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "aix_networking"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "hpnonstop_networking"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "linux_networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "solaris_networking"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "hpux_networking"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "networking_win_wmi"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "host_win_shell"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "host_win_wmi"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "NTCMD_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "TTY_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "TTY_Connection.py"})), :display-name nil, :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useAIXhwId", :description "Identify IBM AIX machines using hardware Id. Note: when set as true and used along with SNMP discovery, duplicate hosts might be created. when set as false no AIX LAPR will be discovered.", :type "string"})), :triggered-ci-data (), :input-cit "ip_address", :discovered-classes ("ip_address" "node" "membership" "composition" "parent" "interface" "ssh" "telnet" "ip_subnet" "containment"), :id "TTY_Net_Dis_Connection", :description "This adapter discovers SSH and Telnet agents by trying to connect to a machine using TTY as well as updating the correct host class (Windows, UNIX, router, and so on)."}, "SQL_APP_Dis_Sybase" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "sybase_dis_physical.py"})), :display-name "Sybase Topology by SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:NA}"})), :input-cit "sybase", :discovered-classes ("process" "dbtablespace" "node" "sybase" "ip_address" "sybasedb" "dbdatafile" "composition" "resource" "dbclient" "containment"), :id "SQL_APP_Dis_Sybase", :description "This adapter discovers Sybase database topology by SQL."}, "SIEBEL_DIS_WEBAPPS_UNIX" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "siebel_discover_wse.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "NTCMD_HR_REG_Software_Lib.py"})), :display-name "Siebel Web Applications by Unix shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "eappsCfgPath", :type "string", :description "Path to Siebel Webserver Extention cofiguration file (eapps.cfg)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "webserver_name", :description nil, :value "${SOURCE.discovered_product_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"})), :input-cit "web_server", :discovered-classes ("dependency" "ip_address" "node" "siebel_wse" "siebel_site" "siebel_web_app" "route" "composition" "configuration_document" "web_server" "siebel_gateway" "containment"), :id "SIEBEL_DIS_WEBAPPS_UNIX", :description "Discover Siebel Webserver Extension and all web applications"}, "VMware_VIM_Connection_Manual" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "vmware_vim_connection_manual.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware VirtualCenter and ESX Manual Connection by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP Address to use for connection", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("composition" "containment" "ip_address" "node" "vmware_esx_server" "vmware_virtual_center" "virtualization_layer"), :id "VMware_VIM_Connection_Manual", :description "adapter discovers the VMware Server connection using Virtual Infrastructure Management protocol. It is activated manually and it uses the URL string parameter for connection."}, "JMX_J2EE_WebLogic" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "weblogic.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "weblogic_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "JMX_J2EE_WebLogic.py"})), :display-name "Weblogic J2EE Topology Discovery by JMX", :global-configuration-files [], :protocols ("weblogicprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "deploymentDescriptors", :description " Set to true to fetch deployment descriptors of J2EE Application, EJB Modules and Web Modules (value: true/false ).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDeployedOnlyApplications", :description "Discover applications that are deployed and in running status"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port}"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description "", :value "${SOURCE.j2eeserver_protocol}"}) #=(clojure.lang.PersistentArrayMap/create {:name "servername", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "version", :description nil, :value "${SOURCE.application_version}"})), :input-cit "weblogicas", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "composition" "dependency" "deployed" "membership" "usage" "webservice" "weblogicas"), :id "JMX_J2EE_WebLogic", :description "This adapter discovers WebLogic j2ee environment and components.Supported WL versions:6.0, 6.1, 7.0, 8.1, 9.0, 9.1, 9.2,10"}, "EMC_AutoStart_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "emc_autostart_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "emc_autostart_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "emc_autostart_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "emc_autostart.py"})), :display-name "EMC AutoStart by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "agentPath", :description "", :value "${AGENT.process_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "domainName", :description "", :value "${CLUSTER_SW.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("cluster_resource_config" "cluster_resource_group" "cluster_resource_group_config" "cluster_software" "composition" "containment" "emc_autostart_cluster" "execution_environment" "ip_address" "membership" "node" "ownership"), :id "EMC_AutoStart_by_Shell", :description "Discover EMC AutoStart cluster by shell"}, "SNMP_NET_Dis_Connection_Client" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "5", :name "SNMP_Connection_Client.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "SNMP_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "icmp_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking_win.py"})), :display-name "Client Connection by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :description "Numeric ping protocol: ICMP (1), ECHO PORT (2) or both (3)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :description "Ping retry", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :description "Number of threads in pool that performs port 7 echoing", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :description "Ping time out (Ms)", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes ("atmswitch" "composition" "containment" "fcswitch" "firewall" "interface" "ip_address" "ip_subnet" "ldom_virtual_switch" "lb" "mainframe" "marconiatmswitch" "membership" "netdevice" "netprinter" "node" "parent" "ras" "router" "snmp" "switch" "terminalserver" "unix" "vax" "vmware_virtual_switch" "nt"), :id "SNMP_NET_Dis_Connection_Client", :description "Discovers SNMP agents by trying to connect to a client machine using the SNMP protocol, updates the node class (Windows, UNIX, router, and so on) according to the relevant OID."}, "WMI_HR_All" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "24", :name "wmi_dis_all.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "23", :name "NTCMD_HR_Dis_Disk_Lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "22", :name "wmi_dis_software_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "21", :name "wmi_dis_cpu_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "20", :name "wmi_dis_share_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "19", :name "wmi_dis_user_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "18", :name "applications.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "17", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "16", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "15", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "14", :name "hostresource_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "13", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "12", :name "wmi_dis_memory_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "hostresource_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "wmi_dis_service_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "memory.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "hostresource.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "Host Resources by WMI", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftwareByOldMechanism", :type "string", :description "Perform software discovery by old non-efficient mechanism"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "wmi", :discovered-classes ("file_system_export" "cpu" "winosuser" "windows_service" "containment" "dependency" "process" "ip_address" "node" "running_software" "iisapppool" "composition" "realization" "usage" "ip_service_endpoint" "installed_software" "file_system"), :id "WMI_HR_All", :description "This adapter discovers host resources and software elements on Windows machines using WMI protocol."}, "MS_Exchange_Topology_by_WMI" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ms_exchange_topology_by_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ms_exchange_utils.py"})), :display-name "Microsoft Exchange Topology by WMI", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "fqdn", :description "", :value "${SOURCE.fqdn:N/A}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostName", :description "", :value "${HOST.name:N/A}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "ms_exchange_server", :discovered-classes ("exchange_administrative_group" "ms_exchange_folder" "ip_address" "node" "membership" "routing_group" "exchangesystem" "composition" "ms_exchange_folder_tree" "containment" "ms_exchange_server"), :id "MS_Exchange_Topology_by_WMI", :description "Connects to the remote host and brings topology for Microsoft Exchange Server 2003"}, "Service_Guard_Cluster_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "oracle_shell_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "service_guard.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "service_guard_discoverers.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Service_Guard_Cluster_Topology.py"})), :display-name "Service Guard Cluster Topology", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "cmclconfig_file", :type "string", :description "Configuration file(extention or file name,default - extention 'ascii')"}) #=(clojure.lang.PersistentArrayMap/create {:name "cmclconfig_path", :type "string", :description "The path to the configuration files"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "cmclconfig_path", :description nil, :value "${PARAMETERS.cmclconfig_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("membership" "execution_environment" "serviceguardcluster" "configuration_document" "containment" "dependency" "ip_address" "node" "sgpackage" "ownership" "sgresource" "composition" "cluster_software"), :id "Service_Guard_Cluster_Topology", :description "Discover ServiceGuard cluster server architecture by TTY"}, "IHS_Dis_WebspherePlugin" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "ihsWebspherePlugin.py"})), :display-name "IHS Plugins by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ihsConfigFile", :description nil, :value "${IHS.webserver_configfile_case_sensitive}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ihs_id", :description nil, :value "${IHS.root_id}"})), :input-cit "shell", :discovered-classes ("httpcontext" "ibmhttpserver" "ip_address" "node" "route" "composition" "ip_service_endpoint" "configuration_document" "containment"), :id "IHS_Dis_WebspherePlugin", :description "Discovers IBM Http Server's WebSphere plugin configuration by parsing the IHS plugin configuration file."}, "oracle_vm_manager_by_maincli" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_arg_validator.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_reportage.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_linkage.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_software.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_virtualization.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_xen_domain.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_node.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_domain.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "ovm_cli.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "manager_by_ovm_cli.py"})), :display-name "Oracle VM Manager Discovery By MainCli", :global-configuration-files [], :protocols ("sshprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportStoppedVMs", :type "string", :description "Perform discovery of stopped VMs"}) #=(clojure.lang.PersistentArrayMap/create {:name "commandExecutionDurationInMs", :type "integer", :description "Time (ms) allocated for CLI commands execution. The value depends on the load factor of manager host. Default value is 2 seconds"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol_port", :description "", :value "${IpServiceEndpoint.network_port_number:NA}"})), :input-cit "oracle_vm_manager", :discovered-classes ("composition" "containment" "dependency" "execution_environment" "ip_address" "ip_service_endpoint" "node" "realization" "running_software" "usage" "virtualization_layer" "xen_domain_config" "server_pool" "interface"), :id "oracle_vm_manager_by_maincli", :description "Make discovery of virtualization inventory using manager's main CLI accessible by SSH protocol"}, "Import_DB" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "db_import.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "import_utils.py"})), :display-name "Import from DB", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "XML file containing the mapping from column to attribute"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column-name : attribute-name (e.g: A_IP_ADDRESS:ip_address, A_IP_DOMAIN:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "schemaName", :type "string", :description "Name of schema"}) #=(clojure.lang.PersistentArrayMap/create {:name "sqlQuery", :type "string", :description "SQL query, if specified, than mapping will be performed against its result. This parameter is ignored in case \"tableName\" parameter is set"}) #=(clojure.lang.PersistentArrayMap/create {:name "tableName", :type "string", :description "Table name, if specified, mapping will be performed against its columns."}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "database_port", :description "", :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "instance_name", :description "", :value "${SOURCE.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "database", :discovered-classes ("configuration_item"), :id "Import_DB", :description " Imports data from an external database into CMDB using mapping of table columns to CIT attributes. Mapping is defined by the following parameters:   ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the CIT attributes to the table columns   Mapping file is used for more complex mapping definitions. Mapping file name is specified by 'mappingFile' parameter.    A SQL 'select' query is generated automatically and selects all columns in specified table, which defined by parameter: tableName   In advanced cases you can specify custom SQL query."}, "VMware_VirtualCenter_Topology_by_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "8", :name "vmware_virtualcenter_topology_by_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "_vmware_vim_base.py"})), :display-name "VMware vCenter Topology by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVMs", :description "Whether we should report Virtual Machines that are powered-off:  - if the value is false, powered-off VMs will not be reported  - if the value is true, powered-off VMs will be reported unless there is a powered-on machine with the same host key (powered-on machine has priority)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "connection_url", :description "", :value "${SOURCE.connection_url}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"})), :input-cit "vmware_virtual_center", :discovered-classes ("composition" "containment" "cpu" "dependency" "execution_environment" "file_system_export" "interface" "ip_address" "license_feature" "license_reservation" "license_server" "manage" "membership" "node" "usage" "vmware_cluster" "vmware_datacenter" "vmware_das_config" "vmware_dpm_config" "vmware_drs_config" "vmware_datastore" "vmware_distributed_switch" "vmware_esx_server" "vmware_host_resource" "vmware_networking_policy" "vmware_port_group" "vmware_resource_pool" "vmware_uplink" "vmware_virtual_switch" "vmware_virtual_center" "virtualization_layer"), :id "VMware_VirtualCenter_Topology_by_VIM", :description "Adapter collects Virtual Infrastructure topology information using vCenter Server by VI Management protocol."}, "NSLOOKUP_on_DNS_Server" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "NSLOOKUP.py"})), :display-name "NSLOOKUP on DNS Server", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DNSServerDomain", :type "string", :description "DNS Server Domain"}) #=(clojure.lang.PersistentArrayMap/create {:name "DNSServerName", :type "string", :description "DNS Server Name"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description nil, :value "${SOURCE.language:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sshKeyPath", :description nil, :value "${SHELL.ssh_keypath:NA}"})), :input-cit "shell", :discovered-classes ("nt" "node" "ip_address" "netprinter" "unix" "containment"), :id "NSLOOKUP_on_DNS_Server", :description "Discovers hosts by querying all available DNS servers"}, "NTCMD_APP_Dis_IIS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "NTCMD_IIS.py"})), :display-name "IIS by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "acceptedStatusCodes", :type "string", :description "Comma separated list of accepted HTTP status codes, indicating availability of discovered url."}) #=(clojure.lang.PersistentArrayMap/create {:name "adsutil_path", :type "string", :description "Path to the adsutil.vbs script"}) #=(clojure.lang.PersistentArrayMap/create {:name "checkConnectionToUrl", :type "string", :description "Should or not reported URLs be verified by HTTP(s)"}) #=(clojure.lang.PersistentArrayMap/create {:name "do_web_service", :type "string", :description "If true, the script will discover web-services"}) #=(clojure.lang.PersistentArrayMap/create {:name "web_service_file_extensions", :type "string", :description "List of file extensions which will detect as web services.Note: Wildcards is not supported"}) #=(clojure.lang.PersistentArrayMap/create {:name "report_legacy_topology", :type "string", :description "Whether to report the legacy IIS topology or new one."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "iis_name", :description nil, :value "${SOURCE.discovered_product_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "iis_version", :description nil, :value "${SOURCE.version}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"})), :input-cit "iis", :discovered-classes ("iis_ftp_server" "deployed" "iis_smtp_server" "configuration_document" "containment" "dependency" "iis" "client_server" "node" "ip_address" "uri_endpoint" "webvirtualhost" "composition" "iisresource" "usage" "ip_service_endpoint"), :id "NTCMD_APP_Dis_IIS", :description "This adapter discovers Microsoft Internet Information Services (IIS)."}, "ms_exchange_topology_by_ntcmd" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "9", :name "ms_exchange_topology_by_NTCMD.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "ms_exchange_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "powershellutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "msexchange_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "msexchange.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"})), :display-name "Microsoft Exchange Topology by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"})), :input-cit "ms_exchange_server", :discovered-classes ("exchange_administrative_group" "composition" "exchangeclientaccessserver" "ms_exchange_clustered_mailbox" "ms_exchange_dag" "exchangeedgeserver" "exchangehubserver" "exchangemailserver" "exchangesystem" "exchangeunifiedmessagingserver" "membership" "ms_exchange_server" "node"), :id "ms_exchange_topology_by_ntcmd", :description "This adapter discovers Microsoft Exchange topology by NTCMD or UDA protocol. It is based on executing of PowerShell scenario on the remote machine."}, "vmware_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "vmware_vim_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "vmware_check_credential.py"})), :display-name "Check credential for VMware protocol", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "vmware_check_credential", :description nil}, "tcp_discovery_by_snmp" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "tcp_discovery_by_snmp.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "tcp_discovery_basic.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "snmp_dis_process_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "Dis_TCP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "TCP Discovery by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "CaptureProcessInformation", :type "string", :description "Whether to capture processes information"}) #=(clojure.lang.PersistentArrayMap/create {:name "DelayBetweenTCPSnapshots", :type "string", :description "Pause in seconds between discovery cycles"}) #=(clojure.lang.PersistentArrayMap/create {:name "NumberOfTCPSnapshots", :type "string", :description "The count of discovery cycles on particular destination"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip:unknown}"})), :input-cit "snmp", :discovered-classes (), :id "tcp_discovery_by_snmp", :description "Discovers TCP information on particular host. Allows multiple discovery cycles to obtain temporary short-lived connections. Reports nothing to UCMDB but collected data used by other jobs to link other CIs to TCP data (like Host resources jobs)."}, "Layer2_Topology_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "switch_layer2_by_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "TTY_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "layer2_shell_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "layer2.py"})), :display-name "Layer2 Topology by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SWITCH.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${NA}"})), :input-cit "shell", :discovered-classes ("composition" "interface" "layer2_connection" "membership" "node" "physical_port" "realization" "switch"), :id "Layer2_Topology_by_Shell", :description "Reports Layer2 and networking related data by ssh or shell from network switches"}, "CF_Oracle" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "CF_Oracle.py"})), :display-name "Oracle Config Files", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description nil, :value "${SOURCE.name:NA}"})), :input-cit "oracle", :discovered-classes ("composition" "oracle" "configuration_document"), :id "CF_Oracle", :description "Discovers Oracle database configurations based on the v$parameter table"}, "Storage_Devices_Connection_by_CIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "cim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "cim_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "smis.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "smis_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "smis_connection.py"})), :display-name "Storage Devices Connection by CIM", :global-configuration-files [], :protocols ("cimprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("cim" "composition" "ip_address" "node" "containment"), :id "Storage_Devices_Connection_by_CIM", :description "This adapter is used for initial connection to CIM Agent"}, "SAP_Dis_ITS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "saputils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_its.py"})), :display-name "SAP Internet Transaction Server Discovery", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "installPath", :description nil, :value "${PROCESS.process_path}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SHELL.application_ip}"})), :input-cit "iis", :discovered-classes ("dependency" "sap_its_wgate" "node" "ip_address" "sap_its_agate" "sap_r3_server" "composition" "web_server" "containment"), :id "SAP_Dis_ITS", :description "Discover SAP Internet Transaction Server based on parsing configuration files."}, "DNS_Discovery" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "DNS_Discovery.py"})), :display-name "DNS Discovery", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dnsServers", :description "Comma-separated value of DNS Servers to use upon Node Name lookup", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_id", :description nil, :value "${IpAddress.root_id}"})), :input-cit "node", :discovered-classes ("node" "ip_address"), :id "DNS_Discovery", :description "Discover DNS names on IPs and hosts"}, "sapjmx_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "sapjmx_check_credential.py"})), :display-name "Check credential for SAP JMX protocol", :global-configuration-files [], :protocols ("sapjmxprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sapjmx_check_credential", :description nil}, "wmi_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "wmi_check_credential.py"})), :display-name "Check credential for WMI protocol", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "wmi_check_credential", :description nil}, "MigrateDDMItoUDAgentAdapter" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Init", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InitMigrate.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Connect", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["DDMiConnect.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Ensure remote OS Version is supported", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckRemoteOSVersion.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Get DDMI agent configuration", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["GetDDMIConfiguration.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Non-Native UD Agent", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["MigrateAgentInPlace.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Non-Native Agent Installed", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckNonNativeAgentInstalled.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["120000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["5"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Lock Scanner Node", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["LockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Init Update from Non-Native to Native", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InitUpgrade.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Agent Basic Resources", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgentBasicResources.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Native UD Agent", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgent.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Native Agent Installed", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckAgentInstalled.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["120000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["5"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Unlock Scanner Node", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnlockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Upgrade Status", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckUpgradeStatus.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Migrate DDMI Agent to UD Agent", :global-configuration-files [], :protocols ("udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "BandwidthLimit", :description "Bandwidth limit to be applied while uploading/downloading in kb/s", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Format ([] indicates an optional field):<ip address|host name>[:<80|1977>]", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Format ([] indicates an optional field):<ip address|host name>[:<80|1977>]", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "architecture", :description "", :value "${UDA.architecture:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${UDA.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"})), :input-cit "ip_address", :discovered-classes ("composition" "node" "uda"), :id "MigrateDDMItoUDAgentAdapter", :description "This adapter updates UD Agent."}, "uda_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "uda_check_credential.py"})), :display-name "Check credential for UDA protocol", :global-configuration-files [], :protocols ("udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "uda_check_credential", :description nil}, "Sap_Profile_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_profiles_by_shell.py"})), :display-name "SAP Profiles by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${SHELL.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "configFilePath", :description "", :value "${SOURCE.sap_instance_profile}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "triggerCIT", :description "", :value "${SOURCE.root_class}"})), :input-cit "sap_app_server", :discovered-classes ("composition" "usage" "configuration_document"), :id "Sap_Profile_By_Shell", :description "Discover profile files for SAP Application Servers"}, "Sap_System_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_system_by_shell.py"})), :display-name "SAP Systems by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "instanceName", :description "Instance name of format \"host_SID_number\"", :value "${SOURCE.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${SHELL.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "configFilePath", :description "", :value "${SOURCE.sap_instance_profile:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "triggerCIT", :description "", :value "${SOURCE.root_class}"})), :input-cit "sap_app_server", :discovered-classes ("membership" "sap_system" "composition" "usage" "sap_app_server" "configuration_document"), :id "Sap_System_By_Shell", :description "The job discovers SAP Systems using information from the configuration files"}, "TTY_HACMP_Applications" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "TTY_HACMP_Applications.py"})), :display-name nil, :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "cldisp_command", :type "string", :description "Actual command to use for cldisp. Can use full path or even root /path/cldisp"}) #=(clojure.lang.PersistentArrayMap/create {:name "cllsif_command", :type "string", :description "Actual command to use for cllsif -c. Can use full path or even root /path/cllsif -c. But do not leave off the -c."}) #=(clojure.lang.PersistentArrayMap/create {:name "vg_command", :type "string", :description "Actual command to use for gathering info about a volume group (lspv -p for AIX,  lvdisplay for Linux)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "cluster", :description "", :value "${HACMP_CLUSTER.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_os", :description "", :value "${HOST.discovered_os_name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "The CMDB Id of the triggered Host", :value "${HOST.root_id}"})), :input-cit "shell", :discovered-classes ("membership" "execution_environment" "physicalvolume" "cluster_resource_group" "interface" "containment" "hacmpcluster" "dependency" "volumegroup" "node" "ip_address" "ownership" "running_software" "hacmpgroup" "composition" "usage" "cluster_software" "hacmpresource"), :id "TTY_HACMP_Applications", :description "Discovers IBM HACMP virtual applications "}, "SQL_NET_Dis_Connection_Oracle" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SQL_Connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"})), :display-name "Oracle Connection By SQL", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "application_ip", :description "", :value "${DB.application_ip:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "application_port", :description "", :value "${DB.application_port:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${IpAddress.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_ip", :description "", :value "${SA.bound_to_ip_address:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sa_port", :description "", :value "${SA.network_port_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sid", :description "", :value "${DB.name:NA}"})), :input-cit "node", :discovered-classes ("composition" "oracle" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :id "SQL_NET_Dis_Connection_Oracle", :description "This adapter discovers databases using SQL protocol."}, "InstallUDAgent" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name #=(clojure.lang.PersistentStructMap/create {:tag :steps, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Connect", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["ShellConnect.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Ensure remote OS Version is supported", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckRemoteOSVersion.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Lock Scanner Node", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["LockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["900000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["40"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["1800000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Agent Basic Resources", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgentBasicResources.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent Installed Before Installation", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckAgentInstalledBeforeInstallation.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Install Agent", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["InstallAgent.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent Install Error Code", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckInstallErrorCode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["90000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["7"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Check Agent Installed", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["CheckAgentInstalled.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutParking, :attrs nil, :content [#=(clojure.lang.PersistentStructMap/create {:tag :initialTimeout, :attrs nil, :content ["90000"]}) #=(clojure.lang.PersistentStructMap/create {:tag :retriesThreshold, :attrs nil, :content ["12"]}) #=(clojure.lang.PersistentStructMap/create {:tag :multipleBy, :attrs nil, :content ["2"]}) #=(clojure.lang.PersistentStructMap/create {:tag :maxRetry, :attrs nil, :content ["7"]}) #=(clojure.lang.PersistentStructMap/create {:tag :timeoutThreshold, :attrs nil, :content ["900000"]})]})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Unlock Scanner Node", :failure-policy "optional"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["UnlockScannerNode.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]}) #=(clojure.lang.PersistentStructMap/create {:tag :step, :attrs #=(clojure.lang.PersistentArrayMap/create {:name "Delete Connected Shell", :failure-policy "mandatory"}), :content [#=(clojure.lang.PersistentStructMap/create {:tag :module, :attrs #=(clojure.lang.PersistentArrayMap/create {:type "jython"}), :content ["DeleteConnectedShell.py"]}) #=(clojure.lang.PersistentStructMap/create {:tag :noParking, :attrs nil, :content nil})]})]})})), :display-name "Install UD Agent", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "UdAgentInstallCredentialId", :description "UD Agent credential id to be used to install UD Agent. Try all if empty.", :type "string", :display-type "UDACredential"}) #=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RunUDAgentUnderRootAccount", :description "Install UD Agent to run under root account on Unix machines, otherwise use installing user account (true/false, default true).", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ProtocolList", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "", :value "${SHELL.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SHELL.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "shellId", :description "", :value "${SHELL.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ipTaggingList", :description "", :value "${IP.ip_lease_time:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "macList", :description "", :value "${SHELL.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeIpList", :description "", :value "${IP.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "nodeMacList", :description "", :value "${IP.arp_mac:NA}"})), :input-cit "node", :discovered-classes ("composition" "uda" "node"), :id "InstallUDAgent", :description "This adapter installs UD Agent."}, "SQL_NET_Dis_db2_Conn" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "db2_net_dis.py"})), :display-name nil, :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("composition" "db2"), :id "SQL_NET_Dis_db2_Conn", :description "DB2 database connection adapter."}, "SAP_Dis_Site_AS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "saputils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_site_by_jco.py"})), :display-name "SAP ABAP Topology Discovery", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportComponentsAsConfigFile", :type "string", :description "When set to 'true' report software components as registry (configuration file). When set to 'false' - report separate CI per component. Default value is 'true'"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRFCConnections", :type "string", :description "Get the RFC Connections of the sap system if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSAPProfiles", :type "string", :description "Discovery SAP profiles by querying SAP database"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "instance_number", :description "", :value "${SOURCE.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connection_client", :description "", :value "${SOURCE.connection_client:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "system_name", :description "", :value "${SAP_SYSTEM.name}"})), :input-cit "sap_r3_server", :discovered-classes ("sap_r3_server" "membership" "sap_system" "jdbcdatasource" "sap_gateway" "sap_work_process" "configuration_document" "sap_client" "containment" "database" "dependency" "node" "ip_address" "running_software" "composition" "usage" "sap_rfc_connection" "sap_software_component"), :id "SAP_Dis_Site_AS", :description "Discover SAP environment based on Computer Center Management System (CCMS)."}, "NTCMD_HR_REG_Software" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "NTCMD_HR_REG_Software.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "NTCMD_HR_REG_Software_Lib.py"})), :display-name "Host Software by NTCMD or UDA", :global-configuration-files [], :protocols ("ntadminprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description nil, :value "${SOURCE.codepage:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "os_version", :description nil, :value "${HOST.discovered_os_name}"})), :input-cit "shell", :discovered-classes ("composition" "installed_software"), :id "NTCMD_HR_REG_Software", :description "Discover Installed software information on Windows machines using NTCMD or UDA protocol. In order for this adapter to work Windows XP's reg.exe file must be renamed to reg_mam.exe and be copied to 'probeManager\\discoveryResources' under probe install directory."}, "SIEBEL_DIS_APP_SERVERS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "siebel_discover_enterprise.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "siebel_common.py"})), :display-name "Siebel Application Servers by Siebel Gateway", :global-configuration-files [], :protocols ("siebelgtwyprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.application_port:NA}"})), :input-cit "siebel_gateway", :discovered-classes ("dependency" "ip_address" "siebel_comp_grp" "node" "membership" "composition" "siebel_component" "siebel_app_server" "configuration_document" "containment" "siebel_application"), :id "SIEBEL_DIS_APP_SERVERS", :description "Discover Siebel topology using srvrmgr client"}, "uddiregistry_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "uddi_registry_check_credential.py"})), :display-name "Check credential for UDDI Registry", :global-configuration-files [], :protocols ("uddiregistryprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "uddiregistry_check_credential", :description nil}, "NTCMD_NET_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "networking_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "processdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "NTCMD_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "NTCMD_Connection.py"})), :display-name "Connection by NTCMD or UDA protocol", :global-configuration-files [], :protocols ("ntadminprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"})), :triggered-ci-data (), :input-cit "ip_address", :discovered-classes ("nt" "node" "ip_address" "running_software" "membership" "dns_server" "composition" "parent" "interface" "containment" "ip_subnet" "ntcmd"), :id "NTCMD_NET_Dis_Connection", :description "Try to connect to a WIN server using HPCmd (NetBIOS) or UD Agent."}, "iSeries Resources by EView" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "eview400_resources.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "eview400_lib.py"})), :display-name "", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "commandTimeout", :description "Timeout value (in seconds) after which the command issued against the EView agent with timeout", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "Set to true to enable detailed logging in probe debug log", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_ASP", :description "Discover the the Auxillary Storage Pools and Disk Units", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_CPUs", :description "Whether to discover Iseries LPAR CPU CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Network", :description "Whether to discover ISeries Interface CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Software", :description "Whether to discover Iseries Installed Software CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Subsystems", :description "Whether to discover Iseries Subsystem CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_TCP_UDP", :description "Whether to discover Iseries LPAR TCP ports and connectivity and UDP ports", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ApplicationPath", :description "", :value "${SOURCE.application_path:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "LparName", :description "", :value "${HOST.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "NodeName", :description "", :value "${SOURCE.discovered_product_name}"})), :input-cit "eview", :discovered-classes ("client_server" "composition" "containment" "cpu" "dependency" "ibm_pseries_frame" "installed_software" "interface" "ip_address" "ip_service_endpoint" "ip_subnet" "logical_volume" "membership" "node" "parent" "storagepool" "as400_node" "iseriessubsystem"), :id "iSeries Resources by EView", :description "This adapter discovers the IBM ISeries Resources on the on an Iseries box such as CPUs , Memory, Disks, Network Controllers, Installed Software."}, "TCP_Services" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Service.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Services.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "Netlinks_Servers.py"})), :display-name "TCP_Services", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ignoreUnackedTcpConn", :type "string", :description "TCP specific options"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "string", :description "Report connections from client IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "string", :description "Report connections from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyHostDependLinks", :type "string", :description "Report only host dependancy"}) #=(clojure.lang.PersistentArrayMap/create {:name "services", :type "string", :description "Services to discover, can include number or known name and can be separated by comma(* for all known ports from configuration file)"}) #=(clojure.lang.PersistentArrayMap/create {:name "updateUtilizationInfo", :type "string", :description "Report accummulated packet and octets (bytes) count on links"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoredIps", :type "String", :description "Ips that should be filtered,comma separated (like 10.*.*.*,15.45.*.*). Default none (empty)."})), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes ("dependency" "client_server" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "containment"), :id "TCP_Services", :description "Discover key services on the network according to portNumberToPortName.xml configuration file. Brings data from Universal Discovery database"}, "ApacheTomcat_Topology" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_mon_utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "tomcat_by_shell.py"})), :display-name "Apache Tomcat Topology", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "configfile", :description "", :value "${TOMCAT.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"})), :input-cit "shell", :discovered-classes ("membership" "webapplication" "jdbcdatasource" "configuration_document" "containment" "database" "dependency" "node" "ip_address" "tomcatservice" "webvirtualhost" "tomcat" "composition" "usage" "tomcatcluster" "ip_service_endpoint"), :id "ApacheTomcat_Topology", :description "Discovers Apache Tomcat Web servers"}, "ARIS_To_UCMDB" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "Push_to_UCMDB_from_ARIS.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "exportTQL_for_ARIS_to_UCMDB.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "Pull_from_ARIS.py"})), :display-name "Software AG ARIS", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :description "If set to true, the integration will only create the result XML file and not push data", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARIS_XML_file", :description "The Full path with filename for the XML input file that will be used to import CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARISLocaleId", :description "Locale ID that should be used if there are multiple locales in the ARIS XML file", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (), :input-cit "discoveryprobegateway", :discovered-classes ("business_application" "business_function" "business_service" "containment" "node" "organization" "ownership" "person"), :id "ARIS_To_UCMDB", :description "Populates CIs from IDS Scheer ARIS using an XML export file from ARIS"}, "WebLogic_By_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "fptools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbcutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jmx.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc_url_parser.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jdbc.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_connection.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jms.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "jee_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "file_ver_lib.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "process_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "weblogic.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "weblogic_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "weblogic_by_shell.py"})), :display-name "Weblogic J2EE Topology Discovery by Shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "database_instance" "composition" "dependency" "deployed" "membership" "usage" "webservice" "weblogicas"), :id "WebLogic_By_Shell", :description "Discovers WebLogic J2EE environment and components by shell. Supported versions: 8.1, 9.0, 9.1, 9.2, 10"}, "SNMP_NET_Dis_Router_Arp" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "DiscoverArp.py"})), :display-name "Router ARP by SNMP", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "backupSnmpMethod", :type "string", :description "Backup snmp method (walk, bulk, getnext)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of scope range as well"}) #=(clojure.lang.PersistentArrayMap/create {:name "moonWalkBulkSize", :type "string", :description "Moon walk bulk size"}) #=(clojure.lang.PersistentArrayMap/create {:name "moonWalkSleep", :type "string", :description "Moon walk sleep time (Ms)"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpBulkSize", :type "string", :description "What is the size of the bulk in a bulk mode"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpMethod", :type "string", :description "Snmp method (walk, bulk, getnext)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description nil, :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "netAddress", :description nil, :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description nil, :value "${SOURCE.snmp_port}"}) #=(clojure.lang.PersistentArrayMap/create {:name "retry", :description nil, :value "${SOURCE.snmp_retry}"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpSupportMultiOid", :description nil, :value "${SOURCE.snmp_supportmultioid}"}) #=(clojure.lang.PersistentArrayMap/create {:name "timeOut", :description nil, :value "${SOURCE.snmp_timeout}"})), :input-cit "snmp", :discovered-classes ("node" "ip_address" "membership" "composition" "parent" "interface" "containment" "ip_subnet"), :id "SNMP_NET_Dis_Router_Arp", :description "This adapter discovers the ARP table of a router using the SNMP protocol. This discovery reveals IP addresses by querying the protocol that translates IPs into the Ethernet addresses used by local area networks, as well as the host and network it belongs to."}, "TCP_Potential_Services" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "Netlinks_Potential_Servers.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "Netlinks_Services.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Netlinks_Service.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "tcpdbutils.py"})), :display-name "TCP Potential Services", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDependLinks", :type "string", :description ""}) #=(clojure.lang.PersistentArrayMap/create {:name "disregardListenPorts", :type "string", :description "Should we disregard that port is listening and check minimal conditions instead"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoredIps", :type "string", :description "Ips that should be filtered,comma separated (like 10.*.*.*,15.45.*.*). Default none (empty)."}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "string", :description "Report connections from client IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "string", :description "Report connections from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "minClients", :type "string", :description "How many connected clients make this service a suspected server. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "minOctets", :type "string", :description "Only include clients that sent more than X octets (bytes) to a service. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "minPackets", :type "string", :description "Only include clients that sent more than X packets to a service. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocols", :type "string", :description "Limit query to these IP protocols (delimited by commas)"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"})), :input-cit "ip_address", :discovered-classes ("dependency" "client_server" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "containment"), :id "TCP_Potential_Services", :description "The job tries to identify servers by network traffic data or number of clients. Brings data from Universal Discovery database."}, "Mainframe_TCP_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "tcpdbutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Mainframe_TCP_by_SNMP.py"})), :display-name "Mainframe TCP by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description nil, :value "${SOURCE.root_container}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("process" "composition"), :id "Mainframe_TCP_by_SNMP", :description "This adapter discovers IBM mainframe."}, "SANscreen_Discovery" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SANscreen_Discovery.py"})), :display-name "NetApp SANScreen/OnCommand", :global-configuration-files [], :protocols ("sanscreenprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :description "Maximum number of items to pull (per query) from the SANscreen WebService API", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.bound_to_ip_address}"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :value "${SOURCE.network_port_number}"})), :input-cit "ip_service_endpoint", :discovered-classes ("composition" "containment" "cpu" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "memory" "node" "storagearray" "storageprocessor" "unix" "nt"), :id "SANscreen_Discovery", :description "This adapter discovers storage devices and SAN infrastructure from NetApp SANscreen/OnCommand"}, "WMI_NET_Dis_Connection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "clientdiscoveryutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "host_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "host_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "host_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "networking_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "networking_win_wmi.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "10", :name "WMI_Connection_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "11", :name "WMI_Connection.py"})), :display-name "Host Connection by WMI", :global-configuration-files [], :protocols ("wmiprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_cmdbid", :description "", :value "${HOST.root_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "host_key", :description "", :value "${HOST.host_key:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mac_addrs", :description "", :value "${NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_mac_address", :description "", :value "${SOURCE.arp_mac:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description "", :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("node" "ip_address" "wmi" "membership" "composition" "parent" "interface" "containment" "ip_subnet"), :id "WMI_NET_Dis_Connection", :description "This adapter discovers WMI agents by trying to connect to a Windows machine using the WMI protocol."}, "HanaDb_by_Shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_platform.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "db_builder.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "hana.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "hana_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "hanadb_by_shell.py"})), :display-name "HanaDb by shell", :global-configuration-files [], :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SHELL.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SHELL.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbport", :description "", :value "${SOURCE.application_port:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbsid", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SHELL.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processParams", :description "", :value "${PROCESS.process_parameters:}"}) #=(clojure.lang.PersistentArrayMap/create {:name "processPath", :description "", :value "${PROCESS.process_path:}"})), :input-cit "hana_database", :discovered-classes ("composition" "ownership" "usage" "containment" "ip_service_endpoint" "dependency" "running_software" "ip_address" "node" "hana_database" "database_instance" "db_log_file" "dbdatafile" "db_trace_file" "dbuser" "configuration_document"), :id "HanaDb_by_Shell", :description "Discover HanaDb instances"}, "hp_npar_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "storage_topology.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "npar_by_shell.py"})), :display-name "HP nPartitions by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description "", :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "connected_os_credentials_id", :description nil, :value "${SOURCE.connected_os_credentials_id:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("hp_vpar_config" "membership" "io_chassis" "scsi_adapter" "cpu" "physicalvolume" "interface_aggregation" "interface" "cell_board" "containment" "dependency" "volumegroup" "node" "fchba" "hp_complex" "hp_npar_config" "composition" "usage" "logical_volume" "file_system"), :id "hp_npar_by_shell", :description "This adapter discovers HP partitionable server (either cell-based or not) topology by connecting to the vPar or nPar"}, "ms_sharepoint_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "3", :name "SharePointMain.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "sharepoint_win_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "sharepoint.py"})), :display-name nil, :global-configuration-files [], :protocols ("ntadminprotocol" "powershellprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverSharePointUrls", :type "string", :description "Parameter defines should or not be discovered URLs of SharePoint sites"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportIntermediateWebService", :type "string", :description "Should or not be reported IIS WebService between IIS Web Server and IIS Web Site. Should be set in accord to IIS Application by NTCMD job."}) #=(clojure.lang.PersistentArrayMap/create {:name "relativeCommandTimeoutMultiplier", :type "string", :description "How much time to wait the result against default command execution time"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credentials to SharePoint host", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP address of SharePoint host", :value "${SOURCE.application_ip}"})), :input-cit "agent", :discovered-classes ("nt" "membership" "sharepoint_service" "iiswebsite" "containment" "iiswebservice" "iis" "ip_address" "uri_endpoint" "client_server" "running_software" "iisapppool" "composition" "usage" "sqlserver" "sharepoint_farm"), :id "ms_sharepoint_by_shell", :description "adapter contains mechanism of MS SharePoint topology discovery"}, "Alteon_app_switch_by_SNMP" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "Alteon_app_switch_by_SNMP.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "snmputils.py"})), :display-name "Alteon application switch by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "IP address of SNMP destination", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "oid", :description nil, :value "${SOURCE.snmp_oid}"})), :input-cit "snmp", :discovered-classes ("ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "alteon_app_switch" "ip_service_endpoint" "lb" "configuration_document" "containment"), :id "Alteon_app_switch_by_SNMP", :description "Discovers Nortel Application Switches using the SNMP protocol"}, "SNMP_NET_Dis_Catalyst_Vlans" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "SNMP_Net_Dis_Catalyst_Vlans.py"})), :display-name "Catalist Vlans by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "smpDescription", :description nil, :value "${SOURCE.snmp_description:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostModel", :description "", :value "${HOST.discovered_model:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostOs", :description "", :value "${HOST.discovered_os_name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("elan" "physical_port" "membership" "composition" "elanvlanmap" "vlan" "bcastdomain"), :id "SNMP_NET_Dis_Catalyst_Vlans", :description "This adapter discovers VLANs on a switch by SNMP."}, "ssl_certificate_by_https" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "ssl_cert_discovery_by_https.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "ssl_cert_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "ssl_cert.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "distinguished_name.py"})), :display-name "SSL Certificate Discovery", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "host_id", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "https_port", :description "", :value "${SOURCE.network_port_number}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip", :description "", :value "${SOURCE.bound_to_ip_address}"})), :input-cit "ip_service_endpoint", :discovered-classes ("dependency" "digital_certificate" "running_software" "usage" "ip_service_endpoint"), :id "ssl_certificate_by_https", :description "Adapter Description"}, "sql_oracle_check_credential" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "protocol.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "check_credential.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "oracle_check_credential.py"})), :display-name "Check credential for Oracle SQL protocol", :global-configuration-files [], :protocols ("sqlprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "", :value "${SOURCE.name}"})), :input-cit "discoveryprobegateway", :discovered-classes (), :id "sql_oracle_check_credential", :description nil}, "DNS_Zone_by_DNS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "4", :name "dns_zone_by_probe_shell.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "dns_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "dns.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "entity.py"})), :display-name "DNS Zone Topology", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeIPs", :type "string", :description "If IP is out of probes range and parameter set to false IP is not reported. The default value is \"false\"."}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBrokenAliases", :type "string", :description "If parameter set to true aliases which canonical resource does not exists will be reported"}) #=(clojure.lang.PersistentArrayMap/create {:name "zoneList", :type "string", :description "Comma separated list of zones is an obligatory attribute. It provides names of zones to transfer."})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SERVICE_ADDRESS.bound_to_ip_address}"})), :input-cit "node", :discovered-classes ("ip_address" "dnszone" "composition" "realization" "dns_record"), :id "DNS_Zone_by_DNS", :description "Discovers the DNS Resource Record topology of DNS Zone by querying name server from local shell (Probe) via DNS protocol"}, "SNMP_CDP_LLDP_neighbors" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "networking_win.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "SNMP_Networking_Utils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "SNMP_CDP_LLDP.py"})), :display-name "CDP/LLDP neighbors layer 2 devices by SNMP", :global-configuration-files [], :protocols ("snmpprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCdpMib", :description "Perform layer 2 discovery from CDP mib", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverLldpMib", :description "Perform layer 2 discovery from LLDP mib", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "hostId", :description "", :value "${HOST.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "snmp", :discovered-classes ("layer2_connection" "node" "membership" "containment" "composition" "interface" "ip_address"), :id "SNMP_CDP_LLDP_neighbors", :description "This adapter discovers Layer 2 neighbors network devices"}, "SAP_Sys_Dis" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index nil, :name "iteratortools.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "entity.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "cmdlineutils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "saputils.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "command.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_flow.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_abap_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index nil, :name "sap_system_dis.py"})), :display-name "SAP ABAP Discovery", :global-configuration-files [], :protocols ("sapprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "hostname", :description "", :value "${HOST.name:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sap_port", :description "", :value "${IpServiceEndpoint.network_port_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sapas_instance", :description "", :value "${SAPAS.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sapas_client", :description "", :value "${SAPAS.connection_client:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sapcs_instance", :description "", :value "${SAPCS.instance_number:NA}"}) #=(clojure.lang.PersistentArrayMap/create {:name "sapcs_client", :description "", :value "${SAPCS.connection_client:NA}"})), :input-cit "ip_address", :discovered-classes ("node" "ip_address" "sap_r3_server" "membership" "sap_system" "composition" "containment"), :id "SAP_Sys_Dis", :description "Discover SAP Systems based on SAP JCO."}, "XLS_Parser" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "2", :name "import_from_excel.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "xlsutils.py"})), :display-name "Import from Excel Workbook", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "file_name", :type "string", :description "The location of Excel (xls, xlsx) file. The script does NOT handle multiple files at once so enter the full path to single file."}) #=(clojure.lang.PersistentArrayMap/create {:name "integer_list_delimiter", :type "string", :description "The delimiter used to handle values in the spreadsheet that are to be treated as the uCMDB data type 'integer_list'"}) #=(clojure.lang.PersistentArrayMap/create {:name "relationship_attr_delimiter", :type "string", :description "On the relationship tab of source file object the link attributes could be added. The default is attribute_name|attribute_value. Should be aligned with actual data."}) #=(clojure.lang.PersistentArrayMap/create {:name "string_list_delimiter", :type "string", :description "The delimiter used to handle values in the spreadsheet which would be mapped as uCMDB data type 'string_list'"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes ("configuration_item" "managed_relationship"), :id "XLS_Parser", :description "Imports data from Excel Workbooks. Parses through multiple worksheet XLS files. Uses 'CIImports.xls' (default) file to import data."}, "NetFlow_StartCollector" {:used-scripts (), :display-name "Net Flow Start Collector", :global-configuration-files [], :protocols (), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "delayDurationInMinutes", :description "How long the listener should sleep(-1 means no delay)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "listenDurationInMinutes", :type "string", :description "How long the listener should run and accept incoming NetFlow data (-1 means run until manually stopped)"}) #=(clojure.lang.PersistentArrayMap/create {:name "localAddress", :type "string", :description "IP address of Discover Probe"}) #=(clojure.lang.PersistentArrayMap/create {:name "listenPort", :type "integer", :description "Port the Discover probe listen on for NetFlow data"}) #=(clojure.lang.PersistentArrayMap/create {:name "authorizedRouters", :type "string", :description "List of IPs of authorized Netflow exporters(comma-separated, * for all)"})), :triggered-ci-data (), :input-cit "discoveryprobemanager", :discovered-classes (), :id "NetFlow_StartCollector", :description "This adapter listens to NetFlow data broadcasts and writes the data to the Probe database, where the data is aggregated and made available for the following adapters:  Potential Services by TCP DB, Services Connections by TCP DB, and Services by TCP DB."}, "red_hat_cluster_by_shell" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "red_hat_cluster_by_shell.py"})), :display-name "Red Hat Cluster by Shell", :global-configuration-files [], :protocols ("sshprotocol" "telnetprotocol"), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "Protocol", :description nil, :value "${SOURCE.root_class}"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description nil, :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.application_ip}"})), :input-cit "shell", :discovered-classes ("node" "membership" "red_hat_cluster" "composition" "cluster_software" "file_system" "clustered_file_system" "realization"), :id "red_hat_cluster_by_shell", :description "Discover Red Hat Cluster Suite."}, "VMware_VMotion_discovery_by_VIM" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "10", :name "vmware_vmotion_monitor.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "9", :name "vmware_vim.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "8", :name "_vmware_vim_41.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "7", :name "_vmware_vim_40.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "6", :name "_vmware_vim_25.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "5", :name "host_discoverer.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "_vmware_vim_20.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "_vmware_vim_base.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "shared_resources_util.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "1", :name "memory.py"})), :display-name "VMware VMotion by VIM", :global-configuration-files [], :protocols ("vmwareprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "connectionRetryNumber", :type "string", :description "Maximum attempts to restore connection.  Zero as value means unlimited number of attempts."}) #=(clojure.lang.PersistentArrayMap/create {:name "eventBasedDiscoveryEnabled", :type "string", :description "At the beginning job checks history in range of past hours, then if this parameter is set to true waits for the new vmotion events."}) #=(clojure.lang.PersistentArrayMap/create {:name "historyHours", :type "string", :description "In scope of specified hours job will check for vmotion events when it starts"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "", :value "${SOURCE.credentials_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description "", :value "${SOURCE.application_ip}"}) #=(clojure.lang.PersistentArrayMap/create {:name "server_url", :description "", :value "${SOURCE.connection_url}"})), :input-cit "vmware_virtual_center", :discovered-classes ("vmware_port_group" "node" "ip_address" "virtualization_layer" "vmware_host_resource" "execution_environment" "composition" "usage" "vmware_virtual_switch" "interface" "containment"), :id "VMware_VMotion_discovery_by_VIM", :description "adapter monitors migration events of Virtual Machines from one host to another."}, "vCloud_Director_URL_by_vCloud_API" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "vcloud.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "2", :name "vcloud_report.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "3", :name "vcloud_discover.py"}) #=(clojure.lang.PersistentArrayMap/create {:index "4", :name "vcloud_director_url_by_vcloud_api.py"})), :display-name "vCloud Director URL by vCloud API", :global-configuration-files [], :protocols ("vcloudprotocol"), :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseUrl", :description "Base URL to VMWare Cloud Director", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVms", :description "Set this parameter to true to report powered off VMs", :type "string"})), :triggered-ci-data (), :input-cit "discoveryprobegateway", :discovered-classes ("ip_address" "node" "interface" "vmware_vcloud" "vmware_vcloud_director" "vcloud_organization" "vcloud_vdc" "vcloud_vapp" "vcloud_vapp_template" "vcloud_media" "vcloud_catalog" "uri_endpoint" "usage" "manage" "composition" "containment" "aggregation"), :id "vCloud_Director_URL_by_vCloud_API", :description "Adapter discovers VMware vCloud Director using direct connection URL by vCloud API"}, "TCP_Webserver_Detection" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "WebserverConnection.py"})), :display-name "TCP Web Server Detection", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "http_port", :description "", :value "${SERVICE_ADDRESS.network_port_number}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_address", :description nil, :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "ip_domain", :description nil, :value "${SOURCE.routing_domain}"})), :input-cit "ip_address", :discovered-classes ("iis" "node" "running_software" "containment" "ip_address" "composition" "usage" "ip_service_endpoint" "sunoneserver" "web_server"), :id "TCP_Webserver_Detection", :description "This adapter discovers web servers using TCP ports."}, "Link DB Datafiles With Clustered FS" {:used-scripts (#=(clojure.lang.PersistentArrayMap/create {:index "1", :name "linkDbDatafileAndFs.py"})), :display-name "Link DB Datafiles With Clustered FileSystem", :global-configuration-files [], :protocols (), :parameters (), :triggered-ci-data (#=(clojure.lang.PersistentArrayMap/create {:name "dbFileId", :description "", :value "${SOURCE.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "dbFilePath", :description "", :value "${SOURCE.name}"}) #=(clojure.lang.PersistentArrayMap/create {:name "fsId", :description "", :value "${CLUSTEREDFS.root_id}"}) #=(clojure.lang.PersistentArrayMap/create {:name "mountPoints", :description "", :value "${CLUSTEREDFS.mount_point}"})), :input-cit "dbdatafile", :discovered-classes ("dbdatafile" "file_system" "node" "usage"), :id "Link DB Datafiles With Clustered FS", :description "This adapter is used for linking of database datafiles with clustered file system"}}})