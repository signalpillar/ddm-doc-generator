#=(clojure.lang.PersistentArrayMap/create {:class-by-name #=(clojure.lang.PersistentArrayMap/create {"AbstractReportDefinition" #=(clojure.lang.PersistentArrayMap/create {:description "Abstract Report definition", :display-name "AbstractReportDefinition", :class-name "AbstractReportDefinition"})}), :job-by-id {"VMware ESX Topology by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Topology by VIM", :display-name nil, :description "", :parameters (), :pattern-id "VMware_ESX_Topology_by_VIM", :trigger "vmware_esx"}), "SQLDiscoveryTutorial" #=(clojure.lang.PersistentArrayMap/create {:id "SQLDiscoveryTutorial", :display-name nil, :description "", :parameters (), :pattern-id "SQLDiscoveryTutorial", :trigger "sqlServer"}), "JBoss Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "JBoss Connections by JMX", :display-name "JEE JBoss Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_JBoss_Connection", :trigger "rmi_ports"}), "Range IPs by NMAP" #=(clojure.lang.PersistentArrayMap/create {:id "Range IPs by NMAP", :display-name "Range IPs by nmap", :description "", :parameters (), :pattern-id "IpRange_by_nmap", :trigger "probe"}), "Oracle Applications by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Applications by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "OracleApps", :trigger "oracle_database"}), "SAP Java Topology by HTTP" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by HTTP", :display-name nil, :description "", :parameters (), :pattern-id "sap_java_topology_by_http", :trigger "sap_http_endpoints"}), "Siebel Gateway Connection" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Gateway Connection", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)", :trigger "siebel_ports_or_gtwy"}), "Sun Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Sun Cluster by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Sun_Cluster_by_Shell", :trigger "sun_cluster_node_shell"}), "SAP ITS by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ITS by NTCMD", :display-name "SAP ITS by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SAP_Dis_ITS", :trigger "sap_its_process"}), "Microsoft Exchange Connection by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Connection by WMI", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Connection_by_WMI", :trigger "ms_exchange_process_and_wmi"}), "Merge VLANs by Ports" #=(clojure.lang.PersistentArrayMap/create {:id "Merge VLANs by Ports", :display-name nil, :description "", :parameters (), :pattern-id "Merge VLANs", :trigger "MergeVLANs"}), "MS NLB by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "MS NLB by NTCMD", :display-name "MS NLB by NTCMD or UDA", :description "", :parameters (), :pattern-id "MS NLB by NTCMD", :trigger "ntcmd_with_2_IP"}), "Oracle LMS Data Collection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle LMS Data Collection by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "Oracle_LMS_Data_Collection", :trigger "oracle_database"}), "Red Hat Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Red Hat Cluster by Shell", :display-name nil, :description "Discovers Red Hat Cluster information", :parameters (), :pattern-id "red_hat_cluster_by_shell", :trigger "redhat_cluster_running_software"}), "Microsoft Exchange Connection by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Connection by NTCMD", :display-name "Microsoft Exchange Connection by NTCMD or UDA", :description "", :parameters (), :pattern-id "ms_exchange_connection_by_ntcmd", :trigger "ms_exchange2007_process_and_ntcmd"}), "Host Applications by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by SNMP", :display-name "Host Applications by SNMP", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "SNMP_HR_All", :trigger "snmp"}), "Microsoft Message Queue Topology by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Message Queue Topology by NTCMD", :display-name "Microsoft Message Queue Topology by NTCMD or UDA", :description "", :parameters (), :pattern-id "microsoft_mq_ntcmd", :trigger "ntcmd_msmq"}), "MSSQL Server Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MSSQL Server Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_MsSql", :trigger "sql_db_port_sa"}), "Mainframe topology by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe topology by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "Mainframe_topology_by_SNMP", :trigger "ip_of_mainframe_or_lpar"}), "Xen Topology by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Xen Topology by TTY", :display-name "Xen and KVM by Shell", :description "", :parameters (), :pattern-id "Xen_by_TTY", :trigger "xen_unix_with_shell"}), "TIBCO EMS by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TIBCO EMS by Shell", :display-name nil, :description "", :parameters (), :pattern-id "tibco_ems_by_shell", :trigger "tibco_ems"}), "MQ by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MQ by Shell", :display-name nil, :description "", :parameters (), :pattern-id "MQ_Topology", :trigger "shell_on_mq_host"}), "Oracle VM Server for SPARC Technology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle VM Server for SPARC Technology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "LDOM_by_shell", :trigger "ldom_control_domain_by_shell"}), "Cisco CSS by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Cisco CSS by SNMP", :display-name "Cisco CSS by SNMP", :description nil, :parameters (), :pattern-id "Cisco_CSS_by_SNMP", :trigger "snmp_of_cisco_css"}), "DB2 Universal Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "DB2 Universal Database Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_DB2", :trigger "db2_db_port_sa"}), "Layer2 by NNM" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 by NNM", :display-name nil, :description "", :parameters (), :pattern-id "NNM_Integration", :trigger "ip"}), "Import CIs from ARIS" #=(clojure.lang.PersistentArrayMap/create {:id "Import CIs from ARIS", :display-name nil, :description "", :parameters (), :pattern-id "ARIS_To_UCMDB", :trigger "probe"}), "Oracle Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Database Connection by SQL", :display-name nil, :description "", :parameters (), :pattern-id "SQL_NET_Dis_Connection_Oracle", :trigger "oracle_db_port_sa"}), "SAP Solution Manager Topology by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Solution Manager Topology by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_SolMan_Topology", :trigger "sap_solman_connected"}), "Vista Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Vista Integration by SQL", :display-name nil, :description "", :parameters (), :pattern-id "Aperture_Vista_by_SQL", :trigger "aperture_vista_db"}), "J2EE Weblogic by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic by Shell", :display-name "JEE Weblogic by Shell", :description "", :parameters (), :pattern-id "WebLogic_By_Shell", :trigger "weblogic_by_shell"}), "Command runner" #=(clojure.lang.PersistentArrayMap/create {:id "Command runner", :display-name nil, :description "", :parameters (), :pattern-id "command_runner", :trigger nil}), "iSeries Resources" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Resources", :display-name "IBM i Resources", :description "", :parameters (), :pattern-id "iSeries Resources by EView", :trigger "eview_iseries_agent"}), "MaxDb by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MaxDb by Shell", :display-name nil, :description "", :parameters (), :pattern-id "MaxDb by Shell", :trigger "maxdb"}), "MySQL by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MySQL by Shell", :display-name nil, :description "Discovers MySQL instances and replication topology", :parameters (), :pattern-id "MySQL by shell", :trigger "mysql"}), "Network Connectivity Data Analyzer" #=(clojure.lang.PersistentArrayMap/create {:id "Network Connectivity Data Analyzer", :display-name nil, :description "", :parameters (), :pattern-id "Network_Connectivity_Data_Analyzer", :trigger "local"}), "Blade Server by IBM Systems Director REST API" #=(clojure.lang.PersistentArrayMap/create {:id "Blade Server by IBM Systems Director REST API", :display-name nil, :description "", :parameters (), :pattern-id "blade_servers_by_ibm_director_api", :trigger "ibm_systems_director"}), "Host Resources and Applications by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by SNMP", :display-name "Host Resources by SNMP", :description nil, :parameters (), :pattern-id "SNMP_HR_All", :trigger "snmp"}), "Siebel DB by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel DB by NTCMD", :display-name "Siebel DB by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SIEBEL_DIS_DB_NT", :trigger "siebel_appserver_nt"}), "VMware VirtualCenter Connection by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Connection by VIM", :display-name "VMware vCenter Connection by VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Connection_by_VIM", :trigger "vmware_vcenter_connection"}), "IBM Systems Director TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Systems Director TCP Ports", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Host Connection to AS400" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection to AS400", :display-name nil, :description "", :parameters (), :pattern-id "AS400_NET_Dis_Connection", :trigger "ip_with_as400_or_without_host"}), "IBM LPAR And VIO Server Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IBM LPAR And VIO Server Topology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "IBM_LPAR_VIO_BY_SHELL", :trigger "ibm_lpar_or_vio_trigger_tql"}), "Storage Devices Topology by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage Devices Topology by CIM", :display-name "Storage Devices Topology by CIM", :description "", :parameters (), :pattern-id "Storage_Devices_Topology_by_CIM", :trigger "smis_topology"}), "Host Resources and Applications by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by Shell", :display-name "Host Resources by Shell", :description nil, :parameters (), :pattern-id "TTY_HR_All", :trigger "host_shell"}), "HP nPartitions by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP nPartitions by Shell", :display-name "HP nPars and vPars by Shell", :description "", :parameters (), :pattern-id "hp_npar_by_shell", :trigger "npartitions_host_shell"}), "J2EE JBoss by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE JBoss by Shell", :display-name "JEE JBoss by Shell", :description "", :parameters (), :pattern-id "JBoss_By_Shell", :trigger "jboss_by_shell"}), "Inventory Discovery by Scanner" #=(clojure.lang.PersistentArrayMap/create {:id "Inventory Discovery by Scanner", :display-name nil, :description "", :parameters (), :pattern-id "InventoryDiscoveryByScanner", :trigger "scanner_shell"}), "JEE Glassfish by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "JEE Glassfish by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Glassfish_By_Shell", :trigger "glassfish_by_shell_and_port"}), "MySQL Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MySQL Connection by SQL", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :pattern-id "SQL_NET_Dis_Connection_MySql", :trigger "mysql_db_port_sa"}), "IHS Websphere Plugin by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IHS Websphere Plugin by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "IHS_Dis_WebspherePlugin", :trigger "host_ihs_shell"}), "IP Traffic by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "IP Traffic by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_ServicesConnectivity", :trigger "local"}), "J2EE Weblogic by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic by JMX", :display-name "JEE Weblogic by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebLogic", :trigger "weblogic_admin_server"}), "DB2 Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "DB2 Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_Db2", :trigger "db2withuser"}), "IBM SVC by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "IBM SVC by CIM", :display-name nil, :description "", :parameters (), :pattern-id "ibm_svc_by_cim", :trigger "ibm_svc_ports"}), "Microsoft Exchange Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "ms_exchange_topology_by_ldap", :trigger "trigger_domainctl_ldap"}), "Oracle RAC Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle RAC Topology by Shell", :display-name nil, :description "Discovers Oracle RAC Topology by Shell", :parameters (), :pattern-id "Oracle_RAC_Topology_by_Shell", :trigger "oracle_with_full_listeners"}), "Host Connection by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by PowerShell", :display-name nil, :description "", :parameters (), :pattern-id "PowerShell_Host_Connection", :trigger "ip_with_powershell_or_without_host"}), "Webservice Connections by UDDI Registry" #=(clojure.lang.PersistentArrayMap/create {:id "Webservice Connections by UDDI Registry", :display-name "Web Service Connections by UDDI Registry", :description nil, :parameters (), :pattern-id "UDDI_Registry_Connection", :trigger "local"}), "Oracle Config Files by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Config Files by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "CF_Oracle", :trigger "oracle_database"}), "Oracle Listeners by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Listeners by Shell", :display-name nil, :description "Discovers Oracle TNS Listener by Shell", :parameters (), :pattern-id "Oracle_Listeners_by_Shell", :trigger "rac_oracledb_with_shell"}), "SANscreen Integration by WebService" #=(clojure.lang.PersistentArrayMap/create {:id "SANscreen Integration by WebService", :display-name nil, :description "", :parameters (), :pattern-id "SANscreen_Discovery", :trigger "sanscreen_server"}), "IP MAC Harvesting by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "IP MAC Harvesting by SNMP", :display-name nil, :description "", :parameters (), :pattern-id "IP_MAC_Harvesting_By_SNMP", :trigger "snmp_with_arp_cache"}), "Host Resources and Applications by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by WMI", :display-name "Host Resources by WMI", :description nil, :parameters (), :pattern-id "WMI_HR_All", :trigger "wmi"}), "DNS Zone by Nslookup" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Zone by Nslookup", :display-name "DNS Zone by nslookup", :description "", :parameters (), :pattern-id "DNS_Zone", :trigger "dns_server_shell"}), "Sybase Database Connection by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Sybase Database Connection by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_NET_Dis_Connection_Sybase", :trigger "sybase_db_port_sa"}), "Databases TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "Databases TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :type "string", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "SAP Solution Manager by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Solution Manager by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_SolutionManager", :trigger "sap_solman_connected"}), "MS Cluster by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "MS Cluster by NTCMD", :display-name "MS Cluster by NTCMD or UDA", :description nil, :parameters (), :pattern-id "MS_Cluster_Topology", :trigger "ntcmd_on_mscs"}), "Update UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Update UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "UpdateUDAgent", :trigger "node_with_udagent"}), "Link DB Datafiles And Clustered FS" #=(clojure.lang.PersistentArrayMap/create {:id "Link DB Datafiles And Clustered FS", :display-name nil, :description "", :parameters (), :pattern-id "Link DB Datafiles With Clustered FS", :trigger "link_datafile_and_clustered_fs"}), "Siebel DB by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel DB by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_DB_UNIX", :trigger "siebel_appserver_shell"}), "Inventory Discovery by Manual Scanner Deployment" #=(clojure.lang.PersistentArrayMap/create {:id "Inventory Discovery by Manual Scanner Deployment", :display-name nil, :description "", :parameters (), :pattern-id "InventoryDiscoveryByManualScannerDeployment", :trigger "probe"}), "TIBCO BusinessWorks by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TIBCO BusinessWorks by Shell", :display-name nil, :description "", :parameters (), :pattern-id "tibco_bw_by_shell", :trigger "tibco_bw"}), "Microsoft SharePoint Topology" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft SharePoint Topology", :display-name nil, :description "", :parameters (), :pattern-id "ms_sharepoint_by_shell", :trigger "sharepoint_application_agents"}), "Class B IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Class B IPs by ICMP", :display-name nil, :description "Performs an IP ping sweep on class B networks", :parameters (), :pattern-id "ICMP_NET_Dis_IpNetwork", :trigger "network_B"}), "Host Applications by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by Shell", :display-name "Host Applications by Shell", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery. For Windows machines only Local Users are discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "TTY_HR_All", :trigger "host_shell"}), "ECC Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "ECC Integration by SQL", :display-name nil, :description "", :parameters (), :pattern-id "ECC_Discovery", :trigger "ECC_OracleDB"}), "Active Directory Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Active Directory Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "LDAP_Active_Directory_Topology", :trigger "trigger_domainctl_ldap"}), "HP Network Automation by Java" #=(clojure.lang.PersistentArrayMap/create {:id "HP Network Automation by Java", :display-name "HP Network Automation by Java", :description "", :parameters (), :pattern-id "HP_Network_Automation_by_Java", :trigger "ip"}), "Veritas Cluster by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Veritas Cluster by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "Veritas_Cluster_Topology", :trigger "shell_of_veritas_cs"}), "HACMP Application Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "HACMP Application Discovery", :display-name nil, :description "", :parameters (), :pattern-id "TTY_HACMP_Applications", :trigger "shell_in_HACMP_cluster"}), "VMware ESX Topology by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Topology by CIM", :display-name "VMware ESX Topology by CIM", :description "", :parameters (), :pattern-id "VMware_ESX_Topology_by_CIM", :trigger "esx_topology_by_cim"}), "Hyper-V Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Hyper-V Topology by Shell", :display-name "Hyper-V Topology by Shell", :description "", :parameters (), :pattern-id "hyperv_topology_by_shell", :trigger "ntcmd_on_hyperv_host"}), "Class C IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Class C IPs by ICMP", :display-name nil, :description "Performs an IP ping sweep on class C networks", :parameters (), :pattern-id "ICMP_NET_Dis_IpNetwork", :trigger "network_C"}), "Sybase Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Sybase Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_Sybase", :trigger "sybase_db"}), "Oracle VM for x86 by Manager Main CLI" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle VM for x86 by Manager Main CLI", :display-name "Oracle VM for x86 by Manager Main CLI", :description "", :parameters (), :pattern-id "oracle_vm_manager_by_maincli", :trigger "oracle_vm_manager_with_ssh_endpoint"}), "Import from Excel Sample" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Excel Sample", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "file_name", :type "string", :description "The location of Excel (xls, xlsx) file. The script does NOT handle multiple files at once so enter the full path to single file."})), :pattern-id "XLS_Parser", :trigger nil}), "J2EE WebSphere Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere Connections by JMX", :display-name "JEE WebSphere Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebSphere_Connection", :trigger "websphere_ports"}), "Import from Properties file" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Properties file", :display-name nil, :description "", :parameters (), :pattern-id "Import_Properties_file", :trigger nil}), "Webservices by UDDI Registry" #=(clojure.lang.PersistentArrayMap/create {:id "Webservices by UDDI Registry", :display-name "Web Services by UDDI Registry", :description nil, :parameters (), :pattern-id "UDDI_Registry", :trigger "uddiregistry"}), "SAP Applications by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Applications by SAP JCO", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_Applications", :trigger "sap_as_connected"}), "SAP ABAP Topology by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ABAP Topology by SAP JCO", :display-name nil, :description "", :parameters (), :pattern-id "SAP_Dis_Site_AS", :trigger "sap_as_connected"}), "Microsoft Exchange Topology by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by PowerShell", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Topology_by_PowerShell", :trigger "ms_exchange_process_and_powershell"}), "Oracle TNS Names by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle TNS Names by LDAP", :display-name nil, :description nil, :parameters (), :pattern-id "oracle_tns_names_by_ldap", :trigger "trigger_domainctl_ldap"}), "Host Applications by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by WMI", :display-name "Host Applications by WMI", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "WMI_HR_All", :trigger "wmi"}), "HP NonStop Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP NonStop Topology by Shell", :display-name nil, :description "", :parameters (), :pattern-id "hp_nonstop_topology_by_shell", :trigger "hp_nonstop_shell"}), "Host Applications by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Applications by PowerShell", :display-name "Host Applications by PowerShell", :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :pattern-id "PowerShell_HR_All", :trigger "host_powershell"}), "vCloud Director by vCloud API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud Director by vCloud API", :display-name nil, :description "", :parameters (), :pattern-id "vCloud_Director_by_vCloud_API", :trigger "vcloud_director_on_host_with_ip"}), "Siebel Application Server Configuration" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Application Server Configuration", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_APP_SERVER_CONFIG", :trigger "siebel_as_shell"}), "SSL Certificate Discovery by HTTPS" #=(clojure.lang.PersistentArrayMap/create {:id "SSL Certificate Discovery by HTTPS", :display-name "SSL Certificate Discovery by HTTPS", :description "", :parameters (), :pattern-id "ssl_certificate_by_https", :trigger "ssl_certificate_discovery"}), "Layer2 Topology VLAN based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology VLAN based by SNMP", :display-name "Layer2 Topology VLAN-based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_Dis_L2_Vlan", :trigger "catalyst_vlan_with_bridge"}), "NetApp Filer by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "NetApp Filer by WebServices", :display-name nil, :description "", :parameters (), :pattern-id "NetApp_Filer_by_WebServices", :trigger "NetApp Filer"}), "Range IPs by ICMP" #=(clojure.lang.PersistentArrayMap/create {:id "Range IPs by ICMP", :display-name nil, :description "", :parameters (), :pattern-id "ICMP_NET_Dis_IpRange", :trigger "probe"}), "Layer 2 Topology by CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Layer 2 Topology by CiscoWorks LMS", :display-name nil, :description "", :parameters (), :pattern-id "CiscoWorks_Layer2", :trigger "CiscoWorks Campus DB Port"}), "Process Layer2 Saved Files" #=(clojure.lang.PersistentArrayMap/create {:id "Process Layer2 Saved Files", :display-name nil, :description "", :parameters (), :pattern-id "processLayer2Files", :trigger "local"}), "Collect Network Data by NetFlow" #=(clojure.lang.PersistentArrayMap/create {:id "Collect Network Data by NetFlow", :display-name nil, :description nil, :parameters (), :pattern-id "NetFlow_StartCollector", :trigger "local"}), "AWS by Web Services" #=(clojure.lang.PersistentArrayMap/create {:id "AWS by Web Services", :display-name nil, :description "", :parameters (), :pattern-id "AWS_by_WebServices", :trigger "probe"}), "Hyper-V Topology by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Hyper-V Topology by WMI", :display-name "Hyper-V Topology by WMI", :description "", :parameters (), :pattern-id "hyperv_topology_by_wmi", :trigger "wmi_on_hyperv_host"}), "Microsoft Exchange Topology by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by WMI", :display-name nil, :description "", :parameters (), :pattern-id "MS_Exchange_Topology_by_WMI", :trigger "ms_exchange_server_and_host_and_wmi"}), "TCP data by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "TCP data by SNMP", :display-name "TCP Data by SNMP", :description "Collects network data by SNMP", :parameters (), :pattern-id "tcp_discovery_by_snmp", :trigger "host_snmp"}), "Webserver by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Webserver by Shell", :display-name "Web Server by Shell", :description nil, :parameters (), :pattern-id "Apache", :trigger "apache_shell"}), "Alteon application switch by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Alteon application switch by SNMP", :display-name "Alteon application switch by SNMP", :description nil, :parameters (), :pattern-id "Alteon_app_switch_by_SNMP", :trigger "snmp_of_alteon"}), "F5 BIG-IP LTM by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "F5 BIG-IP LTM by SNMP", :display-name "F5 BIG-IP LTM by SNMP", :description nil, :parameters (), :pattern-id "F5_BIGIP_LTM_by_SNMP", :trigger "snmp_of_f5"}), "Microsoft Exchange Topology by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Exchange Topology by NTCMD", :display-name "Microsoft Exchange Topology by NTCMD or UDA", :description "", :parameters (), :pattern-id "ms_exchange_topology_by_ntcmd", :trigger "ms_exchange_server2007_and_host_and_ntcmd"}), "VMware ESX Connection by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Connection by VIM", :display-name nil, :description "", :parameters (), :pattern-id "VMware_ESX_Connection_by_VIM", :trigger "vmware_esx_process_on_host"}), "Apache Tomcat by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Apache Tomcat by Shell", :display-name nil, :description nil, :parameters (), :pattern-id "ApacheTomcat_Topology", :trigger "tomcat_by_shell"}), "Host Connection by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Host_Connection_By_Shell", :trigger "ip_with_shell_or_without_host"}), "Import from CSV file" #=(clojure.lang.PersistentArrayMap/create {:id "Import from CSV file", :display-name nil, :description "", :parameters (), :pattern-id "Import_CSV", :trigger nil}), "VMware VirtualCenter Connection by WMI and VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Connection by WMI and VIM", :display-name "VMware vCenter Connection by WMI and VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Connection_by_WMI_and_VIM", :trigger "vmware_virtualcenter_process_with_wmi"}), "Update Ids in NNM" #=(clojure.lang.PersistentArrayMap/create {:id "Update Ids in NNM", :display-name nil, :description "", :parameters (), :pattern-id "NNM_Update_Ids", :trigger "ip"}), "File Monitor by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "File Monitor by Shell", :display-name nil, :description "", :parameters (), :pattern-id "FILE_Mon", :trigger nil}), "HACMP Topology Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "HACMP Topology Discovery", :display-name nil, :description "", :parameters (), :pattern-id "TTY_HACMP_Topology", :trigger "shell_not_ntcmd_HACMP"}), "Call Home Processing" #=(clojure.lang.PersistentArrayMap/create {:id "Call Home Processing", :display-name "Call Home Processing", :description "", :parameters (), :pattern-id "CallHomeProcessing", :trigger "Inventory_Discovery_Trigger"}), "Uninstall UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Uninstall UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "UninstallUDAgent", :trigger "node_with_udagent"}), "Dynamic Credential Sample" #=(clojure.lang.PersistentArrayMap/create {:id "Dynamic Credential Sample", :display-name nil, :description "", :parameters (), :pattern-id "DynamicCredentialSample", :trigger nil}), "Host Resources and Applications by PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "Host Resources and Applications by PowerShell", :display-name "Host Resources by PowerShell", :description "", :parameters (), :pattern-id "PowerShell_HR_All", :trigger "host_powershell"}), "TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Potential Servers by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Potential Servers by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_Potential_Services", :trigger nil}), "WebServer Detection using TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "WebServer Detection using TCP Ports", :display-name "Web Server Detection using TCP Ports", :description nil, :parameters (), :pattern-id "TCP_Webserver_Detection", :trigger "http_ports"}), "Host Networking by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Networking by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_HostBase", :trigger "snmp"}), "Arp Table by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Arp Table by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Router_Arp", :trigger "snmp_router"}), "iSeries Objects" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Objects", :display-name "IBM i Objects", :description "", :parameters (), :pattern-id "iSeries Objects by EView", :trigger "eview_iseries_agent"}), "DB Connections by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "DB Connections by Shell", :display-name nil, :description "Database existence discovery by Shell", :parameters (), :pattern-id "DB_Connect_by_TTY", :trigger "host_shell"}), "WebServices by URL" #=(clojure.lang.PersistentArrayMap/create {:id "WebServices by URL", :display-name "Web Services by URL", :description "", :parameters (), :pattern-id "WebserviceByURL", :trigger "wsdl_url"}), "Oracle Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_Dis_Oracle", :trigger "oracle_database"}), "Host Connection by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by WMI", :display-name nil, :description nil, :parameters (), :pattern-id "WMI_NET_Dis_Connection", :trigger "ip_with_wmi_or_without_host"}), "J2EE Weblogic Connections by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE Weblogic Connections by JMX", :display-name "JEE Weblogic Connections by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebLogic_Connection", :trigger "weblogic_ports"}), "Servers by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Servers by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_Services", :trigger "local"}), "IBM HMC by SHELL" #=(clojure.lang.PersistentArrayMap/create {:id "IBM HMC by SHELL", :display-name "IBM Virtualization by Shell", :description "Discovers topology of IBM Hardware Management Console and IVM", :parameters (), :pattern-id "IBM_HMC_SHELL_PATTERN", :trigger "ibm_hmc_by_shell"}), "JBoss by JMX" #=(clojure.lang.PersistentArrayMap/create {:id "JBoss by JMX", :display-name "JEE JBoss by JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_JBoss", :trigger "jboss_server"}), "Layer2 Topology Bridge based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology Bridge based by SNMP", :display-name "Layer2 Topology Bridge-based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_Dis_L2_Bridge", :trigger "catalyst_bridge_no_vlan"}), "Oracle Application Server" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Application Server", :display-name "Oracle Application Server by Shell", :description "", :parameters (), :pattern-id "Oracle Application Server", :trigger "ntcmd_and_opmn"}), "Service Guard Cluster Topology by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Service Guard Cluster Topology by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "Service_Guard_Cluster_Topology", :trigger "shell_of_serviceguard_cs"}), "IBM Tivoli Network Manager by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Tivoli Network Manager by Shell", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dla_config_file_name", :description "Configuration file which is used to export IdML", :type "string"})), :pattern-id "ibm_tivoli_network_manager_by_shell", :trigger "ibm_tnm_shell"}), "MS Domains" #=(clojure.lang.PersistentArrayMap/create {:id "MS Domains", :display-name "Microsoft Windows Domains", :description nil, :parameters (), :pattern-id "MS_NET_Dis_Domain", :trigger "probe"}), "SAP TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "SAP TCP Ports", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all known ports"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "Import from Database" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Database", :display-name nil, :description "", :parameters (), :pattern-id "Import_DB", :trigger nil}), "VMware VirtualCenter Topology by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VirtualCenter Topology by VIM", :display-name "VMware vCenter Topology by VIM", :description "", :parameters (), :pattern-id "VMware_VirtualCenter_Topology_by_VIM", :trigger "vmware_virtual_center"}), "Layer2 Topology CDP-LLDP based by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology CDP-LLDP based by SNMP", :display-name "Layer2 Topology CDP-LLDP based by SNMP", :description nil, :parameters (), :pattern-id "SNMP_CDP_LLDP_neighbors", :trigger "snmp_of_network_device"}), "Migrate DDMI Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Migrate DDMI Agent", :display-name "Migrate DDMI Agent", :description "", :parameters (), :pattern-id "MigrateDDMItoUDAgentAdapter", :trigger "ip"}), "Manual VMware VIM Connection" #=(clojure.lang.PersistentArrayMap/create {:id "Manual VMware VIM Connection", :display-name "Manual VMware VIM Connection", :description "", :parameters (), :pattern-id "VMware_VIM_Connection_Manual", :trigger "ip"}), "Merge Clustered Software" #=(clojure.lang.PersistentArrayMap/create {:id "Merge Clustered Software", :display-name nil, :description "", :parameters (), :pattern-id "Merge_Clustered_Software", :trigger "mergeDiscClusteredSoft"}), "Siebel Web Applications by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Web Applications by NTCMD", :display-name "Siebel Web Applications by NTCMD or UDA", :description nil, :parameters (), :pattern-id "SIEBEL_DIS_WEBAPPS_NT", :trigger "siebel_webserver_nt"}), "DB Connections by WMI" #=(clojure.lang.PersistentArrayMap/create {:id "DB Connections by WMI", :display-name nil, :description "Database existence discovery by WMI", :parameters (), :pattern-id "DB_Connect_by_Agent", :trigger "wmi_no_shell"}), "VMware VMotion Monitor by VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware VMotion Monitor by VIM", :display-name "VMware vMotion Monitor by VIM", :description "", :parameters (), :pattern-id "VMware_VMotion_discovery_by_VIM", :trigger "vmware_virtual_center"}), "Cisco HSRP by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Cisco HSRP by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "HSRP_by_SNMP", :trigger "snmp_of_HSRP"}), "VLANs by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "VLANs by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Catalyst_Vlans", :trigger "snmp_of_catalyst_switch"}), "Storage Devices Connection by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage Devices Connection by CIM", :display-name "Storage Devices Connection by CIM", :description "", :parameters (), :pattern-id "Storage_Devices_Connection_by_CIM", :trigger "smi_connection"}), "Layer2 Topology by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2 Topology by Shell", :display-name "Layer2 Topology by Shell", :description "", :parameters (), :pattern-id "Layer2_Topology_by_Shell", :trigger "switch_with_shell"}), "EMC AutoStart by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "EMC AutoStart by Shell", :display-name nil, :description "", :parameters (), :pattern-id "EMC_AutoStart_by_Shell", :trigger "emc_autostart_with_shell"}), "Microsoft Message Queue Topology by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Microsoft Message Queue Topology by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "MICROSOFT_MQ", :trigger "trigger_domainctl_ldap"}), "Install UD Agent" #=(clojure.lang.PersistentArrayMap/create {:id "Install UD Agent", :display-name nil, :description "", :parameters (), :pattern-id "InstallUDAgent", :trigger "shell_no_udagent"}), "J2EE WebSphere by Shell or JMX" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere by Shell or JMX", :display-name "JEE WebSphere by Shell or JMX", :description nil, :parameters (), :pattern-id "JMX_J2EE_WebSphere", :trigger "websphere"}), "WebSphere to Webserver Dependency" #=(clojure.lang.PersistentArrayMap/create {:id "WebSphere to Webserver Dependency", :display-name "WebSphere to Web Server Dependency", :description "", :parameters (), :pattern-id "WebSphere_Webserver_Dependency", :trigger "websphere_webserver_dependencies"}), "Client Connection by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Client Connection by SNMP", :display-name "Client Connection by SNMP", :description "This job could collect ARP cache availabitly attribute by SNMP", :parameters (), :pattern-id "SNMP_NET_Dis_Connection_Client", :trigger "probe"}), "Server Ports by Network Data" #=(clojure.lang.PersistentArrayMap/create {:id "Server Ports by Network Data", :display-name nil, :description nil, :parameters (), :pattern-id "TCP_ListenPorts", :trigger "local"}), "MS Domains Topology" #=(clojure.lang.PersistentArrayMap/create {:id "MS Domains Topology", :display-name "Microsoft Windows Domains Topology", :description "", :parameters (), :pattern-id "MS_Domain_Topogy", :trigger "ms_domain"}), "SAP Java Topology by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by WebServices", :display-name nil, :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :pattern-id "SAP_Dis_J2EE_Site", :trigger "sap_http_ports"}), "Siebel Application Servers" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Application Servers", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_APP_SERVERS", :trigger "siebel_gtwy_connected"}), "Hosts by Shell using NSLOOKUP on DNS Server" #=(clojure.lang.PersistentArrayMap/create {:id "Hosts by Shell using NSLOOKUP on DNS Server", :display-name "Hosts by Shell using nslookup on DNS Server", :description nil, :parameters (), :pattern-id "NSLOOKUP_on_DNS_Server", :trigger "dns_server_shell"}), "SAP System By Shell" #=(clojure.lang.PersistentArrayMap/create {:id "SAP System By Shell", :display-name "SAP System by Shell", :description "", :parameters (), :pattern-id "Sap_System_By_Shell", :trigger "sap_system_with_shell"}), "Siebel Web Applications by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Siebel Web Applications by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SIEBEL_DIS_WEBAPPS_UNIX", :trigger "siebel_webserver_shell"}), "J2EE TCP Ports" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE TCP Ports", :display-name "JEE TCP Ports", :description nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all known ports"})), :pattern-id "TCP_NET_Dis_Port", :trigger "ip"}), "IIS Applications by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "IIS Applications by NTCMD", :display-name "IIS Applications by NTCMD or UDA", :description nil, :parameters (), :pattern-id "NTCMD_APP_Dis_IIS", :trigger "host_ntcmd_iis"}), "Active Directory Connection by LDAP" #=(clojure.lang.PersistentArrayMap/create {:id "Active Directory Connection by LDAP", :display-name nil, :description "", :parameters (), :pattern-id "LDAP_Active_Directory_Connection", :trigger "trigger_host_ldap"}), "IBM Systems Director Connection by HTTP" #=(clojure.lang.PersistentArrayMap/create {:id "IBM Systems Director Connection by HTTP", :display-name nil, :description "", :parameters (), :pattern-id "ibm_systems_director_connection", :trigger "ibm_systems_director_port"}), "VLAN ports by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "VLAN ports by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_VMS_catalyst", :trigger "catalyst_vlan"}), "Mainframe TCP by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe TCP by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "Mainframe_TCP_by_SNMP", :trigger "snmp_of_lpar"}), "Network Devices from CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Network Devices from CiscoWorks LMS", :display-name nil, :description "This job populates network devices and layer two infrastructure from the Cisco Works Resource Manager Essentials database", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"})), :pattern-id "CiscoWorks_NetDevices", :trigger "CiscoWorks RME DB Port"}), "DNS Resolver" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Resolver", :display-name nil, :description nil, :parameters (), :pattern-id "DNS_Discovery", :trigger "host"}), "Host Connection by SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Host Connection by SNMP", :display-name nil, :description nil, :parameters (), :pattern-id "SNMP_NET_Dis_Connection", :trigger "ip_with_snmp_or_without_host"}), "Layer 2 Topology from CiscoWorks LMS" #=(clojure.lang.PersistentArrayMap/create {:id "Layer 2 Topology from CiscoWorks LMS", :display-name nil, :description "This job populates nodes layer two infrastructure from the Cisco Works Campus Manager database", :parameters (), :pattern-id "CiscoWorks_Layer2", :trigger "CiscoWorks Campus DB Port"}), "HanaDb by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HanaDb by Shell", :display-name nil, :description "", :parameters (), :pattern-id "HanaDb_by_Shell", :trigger "hanadb"}), "Import data from Atrium" #=(clojure.lang.PersistentArrayMap/create {:id "Import data from Atrium", :display-name nil, :description "Import CIs and Relationships from BMC Atrium into UCMDB", :parameters (), :pattern-id "Atrium to UCMDB", :trigger "probe"}), "DNS Zone by DNS" #=(clojure.lang.PersistentArrayMap/create {:id "DNS Zone by DNS", :display-name nil, :description "", :parameters (), :pattern-id "DNS_Zone_by_DNS", :trigger "dns_service"}), "J2EE WebSphere by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "J2EE WebSphere by Shell", :display-name "JEE WebSphere by Shell", :description "", :parameters (), :pattern-id "WebSphere_By_Shell", :trigger "websphere_by_shell"}), "vCloud Director URL by vCloud API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud Director URL by vCloud API", :display-name nil, :description "", :parameters (), :pattern-id "vCloud_Director_URL_by_vCloud_API", :trigger nil}), "Solaris Zones by TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Solaris Zones by TTY", :display-name nil, :description nil, :parameters (), :pattern-id "SolarisZone_Disc_By_TTY", :trigger "shell_solariszone"}), "VMware ESX Connection by CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware ESX Connection by CIM", :display-name "VMware ESX Connection by CIM", :description "", :parameters (), :pattern-id "VMware_ESX_Connection_by_CIM", :trigger "esx_connection_by_cim"}), "SIM Integration by WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "SIM Integration by WebServices", :display-name nil, :description "", :parameters (), :pattern-id "SIM_Discovery", :trigger "sim_server"}), "Host Fingerprint using nmap" #=(clojure.lang.PersistentArrayMap/create {:id "Host Fingerprint using nmap", :display-name nil, :description nil, :parameters (), :pattern-id "OS_Fingerprint", :trigger "ip"}), "TCP data by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "TCP data by Shell", :display-name "TCP Data by Shell", :description "Collects TCP data by Shell", :parameters (), :pattern-id "tcp_discovery_by_shell", :trigger "host_shell"}), "iSeries Connection" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Connection", :display-name "IBM i Connection", :description "", :parameters (), :pattern-id "EView iSeries Connection", :trigger "probe"}), "MSSQL Topology by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "MSSQL Topology by SQL", :display-name nil, :description nil, :parameters (), :pattern-id "SQL_APP_Dis_SqlServer", :trigger "sqlServer"}), "Import from Excel Workbook" #=(clojure.lang.PersistentArrayMap/create {:id "Import from Excel Workbook", :display-name nil, :description "", :parameters (), :pattern-id "XLS_Parser", :trigger nil}), "HP IVM by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HP IVM by Shell", :display-name "HP IVM by Shell", :description "", :parameters (), :pattern-id "hp_ivm", :trigger "host_shell_ivm"}), "Import from CSV sample" #=(clojure.lang.PersistentArrayMap/create {:id "Import from CSV sample", :display-name nil, :description "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "csvFile", :type "string", :description "Absolute path to the CSV file on the remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column number : attribute name,"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping file located in \"Configuration Files\" folder of this package"})), :pattern-id "Import_CSV", :trigger nil}), "SAP Java Topology by SAP JMX" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Java Topology by SAP JMX", :display-name nil, :description nil, :parameters (), :pattern-id "SAP_Dis_J2EE_Site", :trigger "sap_jmx_ports"}), "SE Integration by SQL" #=(clojure.lang.PersistentArrayMap/create {:id "SE Integration by SQL", :display-name nil, :description "This discovery job retrieves Storage and SAN information from the HP Storage Essentials SRM database", :parameters (), :pattern-id "SE_Discovery", :trigger "HPSE_OracleDB"}), "Hosts using NSLookup on Probe" #=(clojure.lang.PersistentArrayMap/create {:id "Hosts using NSLookup on Probe", :display-name "Hosts using nslookup on Probe", :description nil, :parameters (), :pattern-id "NSLOOKUP_on_Probe", :trigger "probe"}), "SAP Profiles by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "SAP Profiles by Shell", :display-name nil, :description "", :parameters (), :pattern-id "Sap_Profile_By_Shell", :trigger "sap_app_servers"}), "SAP ABAP Connection by SAP JCO" #=(clojure.lang.PersistentArrayMap/create {:id "SAP ABAP Connection by SAP JCO", :display-name nil, :description "", :parameters (), :pattern-id "SAP_Sys_Dis", :trigger "sap_server_or_port"})}, :pattern-by-id {"SQLDiscoveryTutorial" #=(clojure.lang.PersistentArrayMap/create {:id "SQLDiscoveryTutorial", :description "Getting Started Guide SQL Discovery Tutorial", :display-name "SQL Discovery Tutorial", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "tablename", :description "name of the table from which to retrieve the data", :type "string"})), :discovered-classes ("location" "membership" "person"), :protocols ("sqlprotocol"), :input-cit "sqlserver"}), "VMware_ESX_Connection_by_CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_ESX_Connection_by_CIM", :description "VMware ESX Connection by CIM adapter", :display-name "VMware ESX Connection by CIM", :parameters (), :discovered-classes ("cim" "composition" "containment" "ip_address" "interface" "virtualization_layer" "vmware_esx_server"), :protocols ("cimprotocol"), :input-cit "ip_address"}), "sap_java_topology_by_http" #=(clojure.lang.PersistentArrayMap/create {:id "sap_java_topology_by_http", :description "Discover SAP J2EE environment based on XML queried by HTTP", :display-name "SAP J2EE Topology by HTTP", :parameters (), :discovered-classes ("database" "ip_address" "ip_service_endpoint" "j2eecluster" "j2ee_sap_central_services" "sap_j2ee_app_server" "sap_j2ee_dispatcher" "sap_j2ee_server_process" "sap_system" "sap_java_software_component"), :protocols ("sapjmxprotocol"), :input-cit "ip_service_endpoint"}), "SQL_Dis_Oracle" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_Dis_Oracle", :description "This adapter discovers Oracle database topology by SQL.", :display-name "Oracle database topology by SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "comprehensiveDiscovery", :type "string", :description "False (the default): DBA Object, DB Job and DB User are not retrieved. If the parameter set to false changing of other parameters have no affect to discovery process (DBA Objects will not be brought)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverFunctions", :type "string", :description "False (the default): functions are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPackageBody", :type "string", :description "False (the default): package bodies are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPackages", :type "string", :description "False (the default): packages are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcedures", :type "string", :description "False (the default): procedures are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverTables", :type "string", :description "False (the default): tables are not retrieved."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverReportPageSize", :type "integer", :description "Maximum amount of query result objects that will be sent in one bulk"})), :discovered-classes ("dbtablespace" "dbjob" "db_controlfile" "membership" "dblinkobj" "oracle" "oracle_schema" "containment" "dependency" "dbaobjects" "composition" "dbschedulerjob" "dbclient" "dbdatafile" "resource" "db_redofile" "dbuser" "process" "node" "db_archivefile" "ip_address" "db_redofilegroup" "ownership" "dbsnapshot" "rac"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "Sun_Cluster_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Sun_Cluster_by_Shell", :description "adapter discovers Sun Cluster topology via shell including cluster nodes, resource groups and resources, quorum configuration, cluster interconnect.", :display-name nil, :parameters (), :discovered-classes ("sunresourcegroup" "suncluster" "membership" "execution_environment" "interface" "configuration_document" "containment" "sunclusterresource" "layer2_connection" "node" "ip_address" "composition" "cluster_software"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "DynamicCredentialSample" #=(clojure.lang.PersistentArrayMap/create {:id "DynamicCredentialSample", :description "This Discovery adapter serves as a sample how to dynamically create and use credentials for connecting to remote machines.", :display-name "Dynamic Credential Sample", :parameters (), :discovered-classes (), :protocols (), :input-cit "node"}), "nnm_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "nnm_check_credential", :description nil, :display-name "Check credential for NNM protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("nnmprotocol"), :input-cit "discoveryprobegateway"}), "PowerShell_HR_All" #=(clojure.lang.PersistentArrayMap/create {:id "PowerShell_HR_All", :description "Discovers host resources, process connectivity and software elements on Windows machines using PowerShell protocol.", :display-name "Host Resources by PowerShell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery.In case this value is true, all installed softwares are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :discovered-classes ("osuser" "file_system_export" "cpu" "windows_service" "containment" "dependency" "process" "client_server" "node" "ip_address" "running_software" "iisapppool" "composition" "realization" "usage" "ip_service_endpoint" "installed_software" "file_system"), :protocols ("powershellprotocol"), :input-cit "powershell"}), "Mainframe_topology_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe_topology_by_SNMP", :description "This adapter discovers IBM mainframe topology.", :display-name "Mainframe topology by SNMP", :parameters (), :discovered-classes ("snmp" "ip_address" "lpar" "mainframe" "membership" "sysplex" "composition" "containment"), :protocols ("snmpprotocol"), :input-cit "ip_address"}), "ICMP_NET_Dis_IpRange" #=(clojure.lang.PersistentArrayMap/create {:id "ICMP_NET_Dis_IpRange", :description "This adapter performs an IP ping sweep on probe range(s).", :display-name "IP ping sweep", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :type "string", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character)."}) #=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :type "string", :description "Ping time out (Ms)"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :type "string", :description "Ping retry"}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :type "string", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)"}) #=(clojure.lang.PersistentArrayMap/create {:name "virtualModeDiscover", :type "string", :description "Flag that indicates if we want to discover the virtual ips"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :type "string", :description "Ping protocol: ICMP (1), ECHO PORT (2) or both (3)"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :type "string", :description "Number of threads in pool that performs port 7 echoing"}) #=(clojure.lang.PersistentArrayMap/create {:name "isIPv4PingEnabled", :type "string", :description "Ping all IPv4 addresses within the defined ranges"}) #=(clojure.lang.PersistentArrayMap/create {:name "isIPv6PingEnabled", :type "string", :description "Ping all IPv6 addresses within the defined ranges"})), :discovered-classes ("dependency" "ip_address"), :protocols (), :input-cit "discoveryprobegateway"}), "PowerShell_Host_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "PowerShell_Host_Connection", :description "This adapter discovers PowerShell agents by trying to connect to a Windows machine using the PowerShell protocol.", :display-name "Host Connection by PowerShell", :parameters (), :discovered-classes ("nt" "terminalserver" "membership" "parent" "interface" "ip_subnet" "containment" "ip_address" "node" "running_software" "composition" "dns_server" "powershell"), :protocols ("powershellprotocol"), :input-cit "ip_address"}), "MS NLB by NTCMD" #=(clojure.lang.PersistentArrayMap/create {:id "MS NLB by NTCMD", :description "Discovers MS Network Load Balancing topology by NTCMD or UDA", :display-name "MS NLB by NTCMD or UDA", :parameters (), :discovered-classes ("node" "ip_address" "membership" "nlb_clustersoftware" "composition" "ms_nlb_cluster" "configuration_document" "containment"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "nt"}), "SQL_NET_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection", :description "This adapter discovers databases using SQL protocol.", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :discovered-classes ("composition" "sqlserver" "oracle"), :protocols ("sqlprotocol"), :input-cit "ip_address"}), "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_GATEWAY_CONNECTION_(GTWY)", :description "This adapter discovers Siebel Gateway Naming Server and related components by Siebel-Web protocol.", :display-name "Siebel Gateway Connection Discovery", :parameters (), :discovered-classes ("membership" "siebel_site" "composition" "siebel_gateway"), :protocols ("siebelgtwyprotocol"), :input-cit "ip_address"}), "DNS_Zone" #=(clojure.lang.PersistentArrayMap/create {:id "DNS_Zone", :description "Discovers the DNS Resource Record topology of DNS Zone by querying name server using remote shell", :display-name "DNS Zone Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeIPs", :type "string", :description "If IP is out of range of probe and parameter set to false IP is not reported. The default value is \"false\"."}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBrokenAliases", :type "string", :description "If parameter set to true aliases which canonical resource does not exists will be reported"}) #=(clojure.lang.PersistentArrayMap/create {:name "zoneList", :type "string", :description "Comma separated list of zones is an optional attribute. It provides names of zones to transfer. By default zone list is not specified so it is guessed"})), :discovered-classes ("ip_address" "dnszone" "composition" "realization" "dns_record"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "powershell_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "powershell_check_credential", :description nil, :display-name "Check credential for Powershell protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("powershellprotocol"), :input-cit "discoveryprobegateway"}), "tibco_ems_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "tibco_ems_by_shell", :description "Discover TIBCO EMS and its resources", :display-name "TIBCO EMS By Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_queues", :description "To discover TIBCO EMS queues, set this to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_topics", :description "To discover TIBCO EMS topics, set this to true", :type "string"})), :discovered-classes ("composition" "ip_service_endpoint" "jmsdestination" "jmsserver" "node" "process" "tibco_ems_server" "usage" "containment" "ip_address"), :protocols ("sshprotocol" "tibcoprotocol" "telnetprotocol"), :input-cit "process"}), "ms_exchange_topology_by_ldap" #=(clojure.lang.PersistentArrayMap/create {:id "ms_exchange_topology_by_ldap", :description "adapter discovers Microsoft Exchange topology using information stored in Active Directory.", :display-name "Microsoft Exchange Topology by LDAP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportMDBUsers", :description "", :type "string"})), :discovered-classes ("activedirectorysite" "ms_exchange_folder" "activedirectorysystem" "exchange_administrative_group" "routing_group" "membership" "routing_group_connector" "smtp_connector" "routing_connector" "ms_exchange_folder_tree" "containment" "node" "ip_address" "activedirectoryforest" "exchangesystem" "ms_exchange_role" "composition" "ms_exchange_server" "ownership" "ms_exchange_mailbox_database" "ms_exchange_dag" "execution_environment"), :protocols ("ldapprotocol"), :input-cit "domaincontroller"}), "NNM_Integration" #=(clojure.lang.PersistentArrayMap/create {:id "NNM_Integration", :description "Connects to the NNMi web service and populates NNMi discovered nodes, IPs, networks, interfaces and layer two connection information to create a Layer 2 topology in UCMDB. Note that it is recommended NOT to run the UCMDB Layer 2 discoveries if using NNMi Layer 2 integration discovery.", :display-name "Population from NNMi", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisabledIp", :description "Whether to discover Disabled Ips (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverLayer2", :description "Whether to discover Layer2connection related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNodes", :description "Whether to discover Node related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNonManagedInterface", :description "Whether to discover Non Managed Interfaces (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverNonManagedNode", :description "Whether to discover Non Managed Nodes (false - do not discover)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverPhysicalPorts", :description "Whether to discover Physical Ports", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverVlans", :description "Whether to discover Vlan related topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeLayer2", :description "Page size for Layer2 discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeNodes", :description "Page size for Nodes discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pageSizeVlans", :description "Page size for VLANs discovery", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("composition" "containment" "hardware_board" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :protocols ("nnmprotocol"), :input-cit "ip_address"}), "LDAP_Active_Directory_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "LDAP_Active_Directory_Topology", :description "Discovers Active Directory via LDAP", :display-name "LDAP Active Directory Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "globalCatalogPort", :type "string", :description "Port number of domain controller that serves as Global Catalog for full topology discovery enabled by parameter \"tryToDiscoverGlobalCatalog\""}) #=(clojure.lang.PersistentArrayMap/create {:name "reportOUAsConfigurationDocument", :type "string", :description "If flag is set to \"true\" - report tree of Organizational Unit as configuration document, otherwise as tree of CIs"}) #=(clojure.lang.PersistentArrayMap/create {:name "tryToDiscoverGlobalCatalog", :type "string", :description "If this flag parameter is set to \"true\", attempt will be made to discover whole topology connecting to domain controller as to Global Catalog by specified port in parameter \"globalCatalogPort\""}) #=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description "Value referes to the DN under which records about domain controller servers are stored. Default value is OU=Domain Controllers"})), :discovered-classes ("activedirectorysite" "activedirectorysystem" "activedirectorysitelink" "domaincontrollerrole" "membership" "activedirectorydomain" "configuration_document" "ip_subnet" "containment" "ip_address" "node" "activedirectoryforest" "domaincontroller" "composition"), :protocols ("ldapprotocol"), :input-cit "domaincontroller"}), "VMware_ESX_Topology_by_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_ESX_Topology_by_VIM", :description "This adapter discovers VMware ESX Servers using VIM protocol.", :display-name "VMware ESX Topology by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVMs", :type "string", :description "Whether we should report Virtual Machines that are powered-off:  - if the value is false, powered-off VMs will not be reported  - if the value is true, powered-off VMs will be reported unless there is a powered-on machine with the same host key (powered-on machine has priority)"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :discovered-classes ("license_feature" "vmware_resource_pool" "license_server" "virtualization_layer" "vmware_networking_policy" "vmware_host_resource" "execution_environment" "file_system_export" "cpu" "vmware_virtual_switch" "interface" "containment" "vmware_port_group" "license_reservation" "node" "ip_address" "composition" "usage" "dependency" "vmware_esx_server" "vmware_datastore"), :protocols ("vmwareprotocol"), :input-cit "virtualization_layer"}), "hyperv_topology_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "hyperv_topology_by_shell", :description "adapter discovers Microsoft Hyper-V virtualization topology using shell protocol.", :display-name "Hyper-V Topology by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :discovered-classes ("layer2_connection" "node" "virtualization_layer" "membership" "execution_environment" "composition" "switch" "interface" "hyperv_partition_config"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "shell"}), "weblogic_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "weblogic_check_credential", :description nil, :display-name "Check credential for the Weblogic JMX protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("weblogicprotocol"), :input-cit "discoveryprobegateway"}), "SE_Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "SE_Discovery", :description "Populates storage devices and SAN infrastructure from the HP Storage Essentials SRM database", :display-name "Storage Essentials", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignorePortsWithoutWWN", :description "If this is set to true, CIs for Fiber Channel Ports without WWN will be ignored", :type "string"})), :discovered-classes ("composition" "containment" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "memory" "netapp_filer" "node" "realization" "storagearray" "storagefabric" "storagepool" "storageprocessor" "unix" "nt"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "ntadmin_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "ntadmin_check_credential", :description nil, :display-name "Check credential for Ntadmin protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("ntadminprotocol"), :input-cit "discoveryprobegateway"}), "Cisco_CSS_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Cisco_CSS_by_SNMP", :description "Discovers Cisco CSS (Content Services Switch) using the SNMP protocol", :display-name "Cisco CSS by SNMP", :parameters (), :discovered-classes ("ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "lb" "ip_service_endpoint" "cisco_css" "containment"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "siebelgtwy_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "siebelgtwy_check_credential", :description nil, :display-name "Check credential for Siebel protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("siebelgtwyprotocol"), :input-cit "discoveryprobegateway"}), "blade_servers_by_ibm_director_api" #=(clojure.lang.PersistentArrayMap/create {:id "blade_servers_by_ibm_director_api", :description "This adapter brings chassis and blade servers topology using connection to IBM Systems Director REST API", :display-name "Blade Servers by IBM Systems Director REST API", :parameters (), :discovered-classes (), :protocols (), :input-cit "ibm_systems_director"}), "Network_Connectivity_Data_Analyzer" #=(clojure.lang.PersistentArrayMap/create {:id "Network_Connectivity_Data_Analyzer", :description "Discover client server connections on the network according to the chosen parameters. Brings data from DFM database", :display-name "Network Connectivity Data Analyzer", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportIpTrafficLink", :description "enables/disables reporting of traffic link if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportNodeDependencyLink", :description "enables/disables reporting of dependency link if value is 'true'/'false'.  Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportServerRunningSoftware", :description "enables/disables reporting of server running software if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "acceptedServices", :description "list of service to report(ssh, oracle,  mysql, etc, '*' means report all found services). Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :description "enables/disables reporting of outscope servers if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :description "enables/disables reporting of outscope clients if value is 'true'/'false'. Empty value means to use discoveryDescriptorFile as configuration source.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoveryDescriptorFile", :description "Full path to a job configuration file used to define analysis and reporting approach per ip range scope(forward slashes should be used to specify the path).", :type "string"})), :discovered-classes ("dependency" "traffic" "client_server" "containment" "composition" "node" "ip_address" "ip_service_endpoint" "usage"), :protocols (), :input-cit "discoveryprobemanager"}), "command_runner" #=(clojure.lang.PersistentArrayMap/create {:id "command_runner", :description "This adapter is used to create communication logs", :display-name "Command runner", :parameters (), :discovered-classes (), :protocols (), :input-cit "agent"}), "F5_BIGIP_LTM_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "F5_BIGIP_LTM_by_SNMP", :description "This adapter discovers F5 BIG-IP Local Traffic Manager using SNMP protocol", :display-name "F5 BIGIP by SNMP", :parameters (), :discovered-classes ("f5_ltm" "ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "ip_service_endpoint" "lb" "configuration_document" "containment"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "ssh_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "ssh_check_credential", :description nil, :display-name "Check credential for SSH protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sshprotocol"), :input-cit "discoveryprobegateway"}), "MaxDb by Shell" #=(clojure.lang.PersistentArrayMap/create {:id "MaxDb by Shell", :description "Discovers MaxDB instances and topology", :display-name "MaxDb by Shell", :parameters (), :discovered-classes ("composition" "configuration_document" "containment" "dbdatafile" "dbuser" "database_instance" "ip_address" "ip_service_endpoint" "maxdb" "node" "sqlbackup"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :input-cit "maxdb"}), "SQL_NET_Dis_Connection_MySql" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection_MySql", :description "This adapter discovers databases using SQL protocol.", :display-name "MySql Connection By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :discovered-classes ("composition" "mysql" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :protocols ("sqlprotocol"), :input-cit "node"}), "Oracle_LMS_Data_Collection" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle_LMS_Data_Collection", :description "This adapter collects data related to Oracle software usage, which can then be sent to Oracle LMS organization for Oracle License Review or Audit.", :display-name "Oracle LMS data collection by SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "group", :description "Grouping as defined by the customer(e.g. regions, department, etc)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "aggregationLevel", :description "Different levels of aggregations that are used to calculate a value: e.g. database level, server level, network level, etc.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "oracleCSI", :description "Oracle Customer Support identifier (CSI) that is used to interact with Oracle Support-Services.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "applicationName", :description "Name of the application running in conjunction with the Oracle product.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "applicationStatus", :description "Status of the Application (e.g. productive, test environment, development, training, etc.)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "userCountForApplication", :description "If the DBA_USERS table contains generic Usernames/Schemas to connect to the application/database, the customer should provide the User Count at Application - Level.", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "serverNameInTheCluster", :description "Typical question would be: Are the servers clustered? If yes which servers make the cluster?", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "measurementComment", :description "Additional comments out of the measurement or comments from the customer.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "size", :description "Default size of compressed LMS data. (bytes)", :type "integer"})), :discovered-classes ("composition" "audit_document" "oracle"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "MySQL by shell" #=(clojure.lang.PersistentArrayMap/create {:id "MySQL by shell", :description "Discovers MySQL instances and replication topology", :display-name "MySQL by shell", :parameters (), :discovered-classes ("client_server" "ip_address" "node" "composition" "ip_service_endpoint" "configuration_document" "mysql_replication" "containment" "mysql"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "mysql"}), "cim_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "cim_check_credential", :description nil, :display-name "Check credential for CIM protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("cimprotocol"), :input-cit "discoveryprobegateway"}), "JMX_J2EE_WebLogic_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_WebLogic_Connection", :description "Discovers WebLogic Server based on JMX protocol. Supported versions: 6.0, 6.1, 7.0, 8.1, 9.0, 9.1, 9.2, 10", :display-name "Weblogic Server Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "containment" "membership" "usage" "jvm" "ip_service_endpoint" "ip_address" "weblogicas"), :protocols ("weblogicprotocol"), :input-cit "ip_address"}), "hyperv_topology_by_wmi" #=(clojure.lang.PersistentArrayMap/create {:id "hyperv_topology_by_wmi", :description "adapter discovers Microsoft Hyper-V virtualization topology using WMI protocol.", :display-name "Hyper-V Topology by WMI", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :discovered-classes ("layer2_connection" "node" "virtualization_layer" "membership" "execution_environment" "composition" "switch" "interface" "hyperv_partition_config"), :protocols ("wmiprotocol"), :input-cit "wmi"}), "ldap_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "ldap_check_credential", :description nil, :display-name "Check credential for LDAP protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("ldapprotocol"), :input-cit "discoveryprobegateway"}), "SAP_Dis_SolutionManager" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Dis_SolutionManager", :description "Discover SAP business layer based on Solution Manager system management suite.", :display-name "SAP Business Layer Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverScenarioProcesses", :description "If set to true processes of scenarios will be discovered. Default value is false", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "getProcessSteps", :type "string", :description "Get processes steps information"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("ip_address" "node" "sap_r3_server" "sap_business_process" "membership" "sap_transaction" "sap_bp_project" "sap_process_step" "composition" "sap_system" "sap_business_scenario" "containment"), :protocols ("sapprotocol"), :input-cit "sap_r3_server"}), "MS_Exchange_Topology_by_PowerShell" #=(clojure.lang.PersistentArrayMap/create {:id "MS_Exchange_Topology_by_PowerShell", :description "This adapter discovers Microsoft Exchange by PowerShell protocol. It is based on executing Exchange native cmdlets.", :display-name "MS Exchange Topology by Powershell", :parameters (), :discovered-classes ("exchange_administrative_group" "composition" "exchangeclientaccessserver" "exchangeedgeserver" "exchangehubserver" "exchangemailserver" "exchangesystem" "exchangeunifiedmessagingserver" "membership" "ms_exchange_server" "ms_exchange_clustered_mailbox" "ms_exchange_dag" "node" "containment" "ms_exchange_mailbox_database" "execution_environment" "ip_address" "ownership"), :protocols ("powershellprotocol"), :input-cit "powershell"}), "WebSphere_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "WebSphere_By_Shell", :description "This adapter discovers WebSphere J2EE environment and components by shell.", :display-name "Websphere J2EE Topology Discovery by Shell", :parameters (), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "containment" "database_instance" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "Aperture_Vista_by_SQL" #=(clojure.lang.PersistentArrayMap/create {:id "Aperture_Vista_by_SQL", :description "Discovers Aperture VISTA data centers and power infrastructure using the Aperture VISTA Database", :display-name "Aperture VISTA by SQL", :parameters (), :discovered-classes ("chassis" "usage" "node" "power_distribution_unit" "remote_power_panel" "composition" "datacenter" "datacenter_resource" "rack" "unix" "containment"), :protocols ("sqlprotocol"), :input-cit "sqlserver"}), "processLayer2Files" #=(clojure.lang.PersistentArrayMap/create {:id "processLayer2Files", :description "Adapter Description", :display-name "Process Layer2 Collected Files", :parameters (), :discovered-classes ("composition" "interface" "layer2_connection" "membership" "node"), :protocols (), :input-cit "discoveryprobemanager"}), "TTY_HACMP_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "TTY_HACMP_Topology", :description "Discovers IBM HACMP node Topology on servers via SSH, Telnet or UDA", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "AIX_ClusterPackageName", :type "string", :description "The command to get the cluster license on AIX"}) #=(clojure.lang.PersistentArrayMap/create {:name "cldisp_command", :type "string", :description "Actual command to use for cldisp. Can use full path or even root /path/cldisp"})), :discovered-classes ("volumegroup" "ip_address" "node" "membership" "composition" "logical_volume" "cluster_software" "physicalvolume" "interface" "containment" "hacmpcluster"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "DB_Connect_by_TTY" #=(clojure.lang.PersistentArrayMap/create {:id "DB_Connect_by_TTY", :description "Identifies databases on  hosts by host credentials, using the Shell protocols", :display-name "Database Connections by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_oracle", :type "string", :description "Set to \"true\" for Oracle identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_mssql", :type "string", :description "Set to \"true\" for Microsoft SQL Server  identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_db2", :type "string", :description "Set to \"true\" for DB2 (UDB) identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "use_lsof", :type "string", :description "Set to \"true\" if lsof is available on AIX and/or Solaris. HPUX discovery will use LSOF regardless of this flag."}) #=(clojure.lang.PersistentArrayMap/create {:name "use_sudo", :type "string", :description "Set to \"true\" if sudo should be used for commands on UNIX"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterByDiscoveredProcesses", :type "string", :description "** Do not set to TRUE ** Out-of-the-box process filters do not include database processes, and this dicsovery will not work effectively unless we receive an unfiltered list of processes"})), :discovered-classes ("nt" "ip_address" "node" "composition" "sqlserver" "ip_service_endpoint" "oracle" "db2" "unix" "containment"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "sql_generic_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sql_generic_check_credential", :description nil, :display-name "Check credential for Generic SQL protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sqlprotocol"), :input-cit "discoveryprobegateway"}), "SAP_SolMan_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_SolMan_Topology", :description "Discover SAP Topology based on Solution Manager.", :display-name "SAP Topology by Solution Manager", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("sap_r3_server" "j2ee_sap_central_services" "sap_j2ee_app_server" "membership" "sap_system" "j2eecluster" "sap_client" "node" "ip_address" "configuration_document" "database" "containment" "dependency" "composition" "usage"), :protocols ("sapprotocol"), :input-cit "sap_r3_server"}), "SIM_Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "SIM_Discovery", :description "Populates servers and other devices from an HP SIM (Systems Insight Manager) server", :display-name "Systems Insight Manager", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dbIP", :type "string", :description "IP Address of the SIM CMS Database"}) #=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :type "string", :description "Number of nodes to pull from HP SIM per web service call. Changing this value may affect performance and is not recommended"}) #=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierAttributes", :type "string", :description "** DON'T FORGET TO SINGLE QUOTE YOUR ENTRY **  Comma separated list of source attributes used to identify the CI Type of a HOST as UNIX, Windows, etc."}) #=(clojure.lang.PersistentArrayMap/create {:name "HostCitIdentifierMap", :type "string", :description "** DON'T FORGET TO SINGLE QUOTE YOUR ENTRY ** Case-sensitive map of <IdentifierAttributeValue>:<UCMDB CI Type>"}) #=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :type "string", :description "If set to true, the integration will only create the result XML file and not push data into UCMDB"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("nt" "host_node" "enclosure" "membership" "netprinter" "management_processor" "cpu" "switch" "rack" "interface" "containment" "process" "chassis" "dependency" "node" "ip_address" "hp_complex" "composition" "logical_volume" "unix"), :protocols ("simprotocol"), :input-cit "ip_address"}), "UDDI_Registry" #=(clojure.lang.PersistentArrayMap/create {:id "UDDI_Registry", :description "Discovers a UDDI Registry and published services using a given URL", :display-name "UDDI Registry Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "organization", :type "string", :description "Organization"}) #=(clojure.lang.PersistentArrayMap/create {:name "query_chunk_size", :type "string", :description "Integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("dependency" "ip_address" "organization" "uri_endpoint" "composition" "webservice" "containment"), :protocols ("uddiregistryprotocol"), :input-cit "uddiregistry"}), "IP_MAC_Harvesting_By_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "IP_MAC_Harvesting_By_SNMP", :description "This adapter collects IP MAC mapping by SNMP and reports delta information to UCMDB.", :display-name "IP MAC Harvesting By SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DelayTimePerSNMPRequest", :description "Delay time for every snmp get next request, unit:ms", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsCollectDataCenterIP", :description "Whether to collect data center IP", :type "string"})), :discovered-classes ("ip_address"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "Merge VLANs" #=(clojure.lang.PersistentArrayMap/create {:id "Merge VLANs", :description "Used to create links between VLAN and physical ports across different switches in case the corresponding interfaces have connectivity.  Connectivity between interfaces is determined based on the Layer2Connection CI presence.", :display-name "Merge VLANs", :parameters (), :discovered-classes ("membership" "physical_port" "vlan"), :protocols (), :input-cit "vlan"}), "networkautomation_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "networkautomation_check_credential", :description nil, :display-name "Check credential for Network Automation Java protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("networkautomationprotocol"), :input-cit "discoveryprobegateway"}), "SQL_Server_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_Server_Connection", :description "This adapter discovers the credentials of SQL Server database discovered by adapters which do not use SQL credentials.", :display-name nil, :parameters (), :discovered-classes ("composition" "sqlserver"), :protocols ("sqlprotocol"), :input-cit "sqlserver"}), "hp_ivm" #=(clojure.lang.PersistentArrayMap/create {:id "hp_ivm", :description "This adapter discovers HPIntegrity Virtual Machine topology by connecting to the physical or virtual server", :display-name "HP Integrity Virtual Machine by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportHostNameAsVmName", :description "Set Host Name to the value of VM name", :type "string"})), :discovered-classes ("composition" "execution_environment" "hp_ivm_config" "node" "virtualization_layer"), :protocols ("sshprotocol" "telnetprotocol"), :input-cit "shell"}), "FILE_Mon" #=(clojure.lang.PersistentArrayMap/create {:id "FILE_Mon", :description "Discovers Document files and Directories", :display-name "File Monitor by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "binary_file_extensions", :type "string", :description "Binary files extensions"}) #=(clojure.lang.PersistentArrayMap/create {:name "extensions", :type "string", :description "All files extensions"}) #=(clojure.lang.PersistentArrayMap/create {:name "folders", :type "string", :description "List of folders to gather files from"}) #=(clojure.lang.PersistentArrayMap/create {:name "recursively", :type "string", :description "Scan folder recursively."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnixHiddenFiles", :type "string", :description "Whether to discover hidden files on Unix like system.If True then all hidden files will be discovered.(Parameter doesn't depend extentions parameter)."})), :discovered-classes ("composition" "configuration_document"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "JMX_J2EE_WebSphere_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_WebSphere_Connection", :description "This adapter discovers WebSphere servers based on either SOAP or RMI authentication.", :display-name "Websphere Server Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "usage" "ip_service_endpoint" "ip_address" "websphereas"), :protocols ("websphereprotocol"), :input-cit "ip_address"}), "Oracle_Listeners_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle_Listeners_by_Shell", :description "Discovers Oracle listeners. Is required for Oracle RAC deep discovery", :display-name "Oracle Listeners by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "OracleHomes", :description "Used when no ORACLE_HOME environment variable is defined. Value must coincide with the same parameter in Oracle RAC topology by Shell Job", :type "string"})), :discovered-classes ("composition" "containment" "ip_address" "node" "oracle_listener"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "VMware_VirtualCenter_Connection_by_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_VirtualCenter_Connection_by_VIM", :description "Adapter discovers connection to VMware vCenter server using Virtual Infrastructure Management protocol.", :display-name "VMware vCenter Connection by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("composition" "containment" "ip_address" "node" "vmware_virtual_center"), :protocols ("vmwareprotocol"), :input-cit "node"}), "OS_Fingerprint" #=(clojure.lang.PersistentArrayMap/create {:id "OS_Fingerprint", :description "This adapter discovers hosts, IPs, open TCP and UDP ports and host operating systems using nmap.exe.", :display-name "OS Fingerprint", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "Create_Application_CI", :type "string", :description "Create an application CI based on the port fingerprint information"}) #=(clojure.lang.PersistentArrayMap/create {:name "Perform_Port_Fingerprints", :type "string", :description "Try to discover the application behind the port. (this operation will open the port)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_os_name", :type "string", :description "Discover Host OS, which may have some inaccuracy"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_host_timeout", :type "string", :description "The amount of time Nmap is allowed to spend scanning a single host (in seconds)"}) #=(clojure.lang.PersistentArrayMap/create {:name "scan_known_ports_only", :type "string", :description "Scan for ports listed in the portNumberToPortName.xml file"}) #=(clojure.lang.PersistentArrayMap/create {:name "scan_these_ports_only", :type "string", :description "Limit the range of ports to scan.  Example range: T:1-10,42,U:1-30 discover (TCP ports 1 to 10 and 42)  and (UDP ports 1-30),(empty means using nmap default)"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_location", :type "string", :description "Location of nmap executable tool. If empty nmap is looked in system path"})), :discovered-classes ("node" "ip_address" "running_software" "composition" "parent" "ip_service_endpoint" "interface" "containment"), :protocols (), :input-cit "ip_address"}), "Storage_Devices_Topology_by_CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage_Devices_Topology_by_CIM", :description "Adapter used for discovery of storage topology via CIM protocol", :display-name "Storage Devices Topology by CIM", :parameters (), :discovered-classes ("composition" "fcconnect" "fcport" "ip_address" "logical_volume" "node" "storagearray" "storagepool"), :protocols ("cimprotocol"), :input-cit "cim"}), "netapp_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "netapp_check_credential", :description nil, :display-name "Check credentials for the Netapp Filer", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("netappprotocol"), :input-cit "discoveryprobegateway"}), "MS_Exchange_Connection_by_WMI" #=(clojure.lang.PersistentArrayMap/create {:id "MS_Exchange_Connection_by_WMI", :description "Connects to the remote host by WMI and discovers Exchange Server CI", :display-name "Microsoft Exchange Connection by WMI", :parameters (), :discovered-classes ("host_node" "composition" "ms_exchange_server"), :protocols ("wmiprotocol"), :input-cit "wmi"}), "SNMP_Dis_L2_Vlan" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_Dis_L2_Vlan", :description "This adapter discovers the Layer 2 topology of a specific VLAN by SNMP.", :display-name "L2 Vlan by SNMP", :parameters (), :discovered-classes ("layer2_connection" "node" "physical_port" "membership" "composition" "realization" "bridge" "interface"), :protocols ("snmpprotocol"), :input-cit "vlan"}), "HP_Network_Automation_by_Java" #=(clojure.lang.PersistentArrayMap/create {:id "HP_Network_Automation_by_Java", :description "HP Network Automation by Java", :display-name "HP Network Automation by Java", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryTopologyPerDevice", :description "Whether to perform separate queries per device (true), or retrieve topology with queries for all devices at once (false, default).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportDeviceConfigs", :description "Whether to report configuration as config files for devices", :type "string"})), :discovered-classes ("composition" "configuration_document" "containment" "hardware_board" "interface" "ip_address" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :protocols ("networkautomationprotocol"), :input-cit "ip_address"}), "JMX_J2EE_JBoss" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_JBoss", :description "This adapter discovers JBoss J2EE environment and components based on the JMX protocol.", :display-name "Jboss J2EE Topology Discovery by JMX", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "containment" "webservice" "jbossas"), :protocols ("jbossprotocol"), :input-cit "jbossas"}), "MQ_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "MQ_Topology", :description "Discover Websphere MQ topology by using SSH, TELNET, NTCMD or UDA", :display-name "Websphere MQ Topology by shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_dynamic_queues", :type "string", :description "Enable discovery of permanent and temporary dynamic queues"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_remote_hosts", :type "string", :description "Enables resolution and discovery of remote servers and MQ objects referenced by the server being discovered. If set to false, relationships between MQ objects on different servers will not be discovered"}) #=(clojure.lang.PersistentArrayMap/create {:name "mq_cmd_timeout", :type "string", :description "Sets the command timeout for MQ commands"}) #=(clojure.lang.PersistentArrayMap/create {:name "mqver_path", :type "string", :description "Path to 'mqver' or 'dspmqver' executables. Separate multiple entries by \";\""}) #=(clojure.lang.PersistentArrayMap/create {:name "sudo_command", :type "string", :description "Use the MQ username here"}) #=(clojure.lang.PersistentArrayMap/create {:name "use_sudo", :type "string", :description "Should SUDO be used?"})), :discovered-classes ("membership" "mqnamelist" "mqreceiverchannel" "mqchannel" "containment" "mqsenderchannel" "dependency" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "webspheremq" "mqqueuemanager" "mqcluster" "mqqueue"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "sql_db2_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sql_db2_check_credential", :description nil, :display-name "Check credential for DB2 SQL protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sqlprotocol"), :input-cit "discoveryprobegateway"}), "IBM_LPAR_VIO_BY_SHELL" #=(clojure.lang.PersistentArrayMap/create {:id "IBM_LPAR_VIO_BY_SHELL", :description "Adapter for Discovery of IBM VIO Server or any IBM LPar running system", :display-name "IBM LPar And VIO Server by Shell", :parameters (), :discovered-classes ("sea_adapter" "membership" "scsi_adapter" "parent" "ioslot" "physicalvolume" "interface" "interface_aggregation" "containment" "interfaceindex" "dependency" "node" "volumegroup" "ip_address" "fchba" "composition" "realization" "logical_volume" "usage" "file_system"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SIEBEL_DIS_APP_SERVER_CONFIG" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_APP_SERVER_CONFIG", :description "Discover configuration file of Siebel application server", :display-name "Siebel Application Server Configuration File by shell", :parameters (), :discovered-classes ("composition" "siebel_app_server" "configuration_document"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "siebel_app_server"}), "microsoft_mq_ntcmd" #=(clojure.lang.PersistentArrayMap/create {:id "microsoft_mq_ntcmd", :description "Discovery adapter for Microsoft MQ server side. Uses NTCMD or UDA protocol in order to retrieve queues, triggers and rules related data", :display-name "Microsoft MQ by NTCMD or UDA", :parameters (), :discovered-classes ("ip_address" "node" "msmqmanager" "msmqqueue" "composition" "msmqtrigger" "usage" "msmqrule" "containment"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "shell"}), "ms_exchange_connection_by_ntcmd" #=(clojure.lang.PersistentArrayMap/create {:id "ms_exchange_connection_by_ntcmd", :description "This adapter discovers Microsoft Exchange by NTCMD or UDA protocol. It is based on executing of PowerShell scenario on the remote machine.", :display-name "Microsoft Exchange Connection by NTCMD or UDA", :parameters (), :discovered-classes ("node" "composition" "ms_exchange_server"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "shell"}), "SQL_NET_Dis_Connection_MsSql" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection_MsSql", :description "This adapter discovers databases using SQL protocol.", :display-name "MsSql Connection By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :discovered-classes ("composition" "sqlserver" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :protocols ("sqlprotocol"), :input-cit "node"}), "ibm_systems_director_connection" #=(clojure.lang.PersistentArrayMap/create {:id "ibm_systems_director_connection", :description "Thsi pattern discovers IBM Director using REST API", :display-name "IBM Director", :parameters (), :discovered-classes ("ibm_systems_director" "ip_service_endpoint" "node"), :protocols ("httpprotocol"), :input-cit "ip_service_endpoint"}), "sap_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sap_check_credential", :description nil, :display-name "Check credential for SAP protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sapprotocol"), :input-cit "discoveryprobegateway"}), "as400_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "as400_check_credential", :description nil, :display-name "Check credential for the AS400 protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("as400protocol"), :input-cit "discoveryprobegateway"}), "telnet_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "telnet_check_credential", :description nil, :display-name "Check credential for Telnet protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("telnetprotocol"), :input-cit "discoveryprobegateway"}), "db2_topology_by_sql" #=(clojure.lang.PersistentArrayMap/create {:id "db2_topology_by_sql", :description "Discover the physical elements within DB2 database.", :display-name "DB2 Topology By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "report_system_tables", :description "Flag indicating whether job should report system tables", :type "boolean"})), :discovered-classes ("db2" "db2_database" "db2_buffer_pool" "dbdatafile" "dbtablespace" "db2_partition_group" "db2_partition" "db2_schema" "ip_address" "node" "process" "resource"), :protocols ("sqlprotocol"), :input-cit "db2_database"}), "websphere_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "websphere_check_credential", :description nil, :display-name "Check credentials for the Webshpere JMX protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("websphereprotocol"), :input-cit "discoveryprobegateway"}), "Oracle_RAC_Topology_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle_RAC_Topology_by_Shell", :description "Discovers Oracle RAC topology", :display-name "Oracle RAC Topology by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "OracleHomes", :description "Used when no ORACLE_HOME environment variable is defined. Value must coincide with the same parameter in Oracle Listeners by Shell Job", :type "string"})), :discovered-classes ("composition" "containment" "ip_address" "membership" "node" "oracle" "rac" "oracle_listener" "running_software"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "oracle_listener"}), "AWS_by_WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "AWS_by_WebServices", :description "Discovers AWS topologies of the EC2 and RDS services using Web Services", :display-name "AWS by Web Services", :parameters (), :discovered-classes ("amazon_account" "amazon_ec2_config" "composition" "containment" "membership" "ip_address" "location" "logicalvolume_snapshot" "logical_volume" "uri_endpoint" "configuration_document" "dbsnapshot" "database" "node" "usage"), :protocols ("awsprotocol"), :input-cit "discoveryprobegateway"}), "Import_CSV" #=(clojure.lang.PersistentArrayMap/create {:id "Import_CSV", :description " Imports data from a CSV file into CMDB using mapping of the CSV file columns to CIT attributes. Mapping is defined by the following parameters: ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the CIT attributes to the CSV file columns. Mapping file is used for more complex mapping definitions. Mapping file name is specified by 'mappingFile' parameter.", :display-name "Import from CSV", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "csvFile", :type "string", :description "Absolute path to the CSV file on the remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "delimiter", :type "string", :description "Delimiter used in CSV file"}) #=(clojure.lang.PersistentArrayMap/create {:name "quoteSymbol", :type "string", :description "Quoting symbol used in CSV file"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping file located in \"Configuration Files\" folder of this package"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column-number : attribute-name (e.g: 0:ip_address, 1:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "rowToStartIndex", :type "string", :description "Index of row to start with. Set this parameter to 2 in order to skip header row"}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."}) #=(clojure.lang.PersistentArrayMap/create {:name "skipEmptyValues", :type "string", :description "Whether to skip empty values. If set to true, empty column values will not be sent."})), :discovered-classes ("configuration_item"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "tibco_bw_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "tibco_bw_by_shell", :description "Discover TIBCO BusinessWorks and its resources", :display-name "TIBCO BusinessWorks By Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_jms_topology", :description "To discover JMS topology set this to true.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "temp_directory", :description "Temporary directory on the TIBCO Business Works server with read-write access", :type "string"})), :discovered-classes ("composition" "connection" "ip_address" "jmsdestination" "jmsserver" "membership" "node" "tibco_administration_domain" "tibco_application" "tibco_business_works" "tibco_adapter" "usage" "containment" "tibco_ems_server" "ip_service_endpoint"), :protocols ("sshprotocol" "tibcoprotocol" "telnetprotocol"), :input-cit "tibco_business_works"}), "UpdateUDAgent" #=(clojure.lang.PersistentArrayMap/create {:id "UpdateUDAgent", :description "This adapter updates UD Agent.", :display-name "Update UD Agent", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RunUDAgentUnderRootAccount", :description "Install UD Agent to run under root account on Unix machines, otherwise use installing user account (true/false, default true).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "UdAgentInstallCredentialId", :description "UD Agent credential id to be used to install/upgrade UD Agent. Try all if empty.", :type "string", :display-type "UDACredential"})), :discovered-classes ("composition" "uda" "node"), :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :input-cit "node"}), "MS_Cluster_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "MS_Cluster_Topology", :description "This adapter discovers Microsoft Cluster architecture by NTCMD.", :display-name "MS Cluster Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"})), :discovered-classes ("cluster_resource_group" "cluster_software" "composition" "configuration_document" "containment" "dependency" "execution_environment" "ip_address" "mscluster" "mscsgroup" "mscsresource" "membership" "node" "ownership" "virtual"), :protocols ("ntadminprotocol" "udaprotocol" "powershellprotocol"), :input-cit "agent"}), "iSeries Objects by EView" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Objects by EView", :description "This adapter discovers the IBM ISeries Objects such as Job Queues , Output Queues, Libraries, Files, Programs", :display-name "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "commandTimeout", :description "Timeout value (in seconds) after which the command issued against the EView agent with timeout", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "Set to true to enable detailed logging in probe debug log", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Jobs", :description "Discover the Active Jobs on the Iseries lpar", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Library", :description " Discover Iseries Library Objects", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Program", :description "Discover Iseries Program Objects", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Queue", :description "Discover the Queues (Job, Output)", :type "string"})), :discovered-classes ("composition" "iseries_file" "iseries_job" "iseries_jobqueue" "iseries_library" "iseries_outqueue" "iseries_program" "membership" "as400_node" "iseriessubsystem"), :protocols (), :input-cit "eview"}), "SNMP_NET_Dis_HostBase" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_HostBase", :description "Discovers host networking topology using SNMP route and system tables", :display-name "Host Networking by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverRoute", :type "string", :description "Indicates if we want to discover the route table"})), :discovered-classes ("nt" "terminalserver" "membership" "switch" "ras" "vax" "containment" "ip_subnet" "composition" "snmp" "firewall" "netprinter" "netdevice" "parent" "interface" "interfaceindex" "node" "ip_address" "router" "route" "atmswitch" "unnumbered" "lb" "bridge" "unix"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "IpRange_by_nmap" #=(clojure.lang.PersistentArrayMap/create {:id "IpRange_by_nmap", :description "This adapter performs an IP ping scan on probe range(s) by NMAP tool.", :display-name "IP ping scan by NMAP tool", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :type "string", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character)."}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :type "string", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmap_location", :type "string", :description "Location of nmap executable tool. If empty nmap is looked in system path"})), :discovered-classes ("ip_address"), :protocols (), :input-cit "discoveryprobegateway"}), "TCP_ListenPorts" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_ListenPorts", :description "Discover listening ports on the network according to portNumberToPortName.xml configuration file. Brings data from Universal Discovery database.", :display-name "TCP Listen Ports", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "services", :type "string", :description "Services to discover, can include number or known name and can be separated by comma (* for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "boolean", :description "Report ports for IPs that not in scope"})), :discovered-classes ("ip_address" "node" "composition" "ip_service_endpoint" "containment"), :protocols (), :input-cit "discoveryprobemanager"}), "SNMP_HR_All" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_HR_All", :description "Discovers host resources and software elements", :display-name "Host Resources by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :discovered-classes ("winosuser" "windows_service" "containment" "process" "dependency" "ip_address" "node" "running_software" "composition" "usage" "installed_software" "file_system"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "Import_Properties_file" #=(clojure.lang.PersistentArrayMap/create {:id "Import_Properties_file", :description " Imports data from a Properties file into CMDB, using mapping of the CSV file columns to CIT attributes   This mapping is usually defined by the setting adapter parameters: ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the Properties attributes to the CSV file columns   In cases you need more complex mapping abilities, such as  conversion of the strings contained in Properties file to the appropriate type of CMDB object's attribute,   you should use the mapping XML configuration file specified by the mappingFile parameter.   ", :display-name "Import from properties file", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "Mapping XML file located in \"Configuration files\" folder of this package"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: key name : attribute-name (e.g: address:ip_address, defaultDomain:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "propertyFile", :type "string", :description "Absolute path to the '.properties' file on remote host"}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."})), :discovered-classes ("configuration_item"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "vcloud_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "vcloud_check_credential", :description nil, :display-name "Check credential for the vCloud Director", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("vcloudprotocol"), :input-cit "discoveryprobegateway"}), "MS_Domain_Topogy" #=(clojure.lang.PersistentArrayMap/create {:id "MS_Domain_Topogy", :description "Discovers hosts on Microsoft Domain.", :display-name "MS_Domain_Topogy", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :discovered-classes ("node" "ip_address" "membership" "containment"), :protocols (), :input-cit "msdomain"}), "Apache" #=(clojure.lang.PersistentArrayMap/create {:id "Apache", :description "Discovers Apache web servers using the Shell protocols", :display-name "Apache Web Servers by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "configFiles", :type "string", :description "Full path to Apache configuration files, including file names. Multiple files should be separated by ';'"})), :discovered-classes ("apache" "apachemodule" "composition" "configuration_document" "containment" "dependency" "deployed" "httpcontext" "ibmhttpserver" "ip_address" "ip_service_endpoint" "node" "running_software" "usage" "webvirtualhost" "web_server"), :protocols ("sshprotocol" "telnetprotocol" "ntadminprotocol"), :input-cit "shell"}), "AS400_NET_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "AS400_NET_Dis_Connection", :description "Connects to the AS400 Server using the JT400 Toolbox", :display-name "AS400_NET_Dis_Connection", :parameters (), :discovered-classes ("as400" "composition" "containment" "interface" "ip_address" "ip_subnet" "membership" "node" "parent"), :protocols ("as400protocol"), :input-cit "ip_address"}), "SQL_NET_Dis_db2_from_db2" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_db2_from_db2", :description "This package discover the existnace of the db2 database", :display-name nil, :parameters (), :discovered-classes ("node" "composition" "db2"), :protocols ("sqlprotocol"), :input-cit "db2"}), "TNSNamesParser" #=(clojure.lang.PersistentArrayMap/create {:id "TNSNamesParser", :description "This adapter discovers Oracle databases using tnsnames.ora parsing.", :display-name nil, :parameters (), :discovered-classes ("ip_address" "node" "composition" "oracle" "configuration_document" "containment"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :input-cit "shell"}), "NetApp_Filer_by_WebServices" #=(clojure.lang.PersistentArrayMap/create {:id "NetApp_Filer_by_WebServices", :description "This adapter discovers volumes, shares and other details on a NetApp filer", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "filerOptions", :type "string", :description "This is a comma separated list of options that shoud be retrieved from the Filer"}) #=(clojure.lang.PersistentArrayMap/create {:name "chunkSize", :type "string", :description "Maximum number of objects pulled from NetApp Operations Manager per SOAP call"}) #=(clojure.lang.PersistentArrayMap/create {:name "getSnapShotInfo", :type "string", :description "Set to 'true' to get snapshot details on volumes"}) #=(clojure.lang.PersistentArrayMap/create {:name "getNetworkShareInfo", :type "string", :description "Set to 'true' to get CIFS and NFS share details (requires appropriate ONTAP licenses)"}) #=(clojure.lang.PersistentArrayMap/create {:name "getSnapVaultInfo", :type "string", :description "Set to 'true' to get SnapVault information (requires appropriate ONTAP licenses)"})), :discovered-classes ("file_system_export" "membership" "cpu" "interface" "memory" "containment" "logicalvolume_snapshot" "dependency" "node" "ip_address" "composition" "logical_volume" "realization" "file_system"), :protocols ("netappprotocol"), :input-cit "ip_address"}), "SQL_Oracle_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_Oracle_Connection", :description "This adapter discovers the credentials of Oracle database discovered by TNS parser using an Oracle protocol.", :display-name nil, :parameters (), :discovered-classes ("composition" "oracle"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "VMware_ESX_Topology_by_CIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_ESX_Topology_by_CIM", :description "VMware ESX Topology by CIM", :display-name "VMware ESX Topology by CIM", :parameters (), :discovered-classes ("composition" "containment" "cpu" "execution_environment" "ip_address" "node" "vmware_esx_server" "vmware_host_resource" "virtualization_layer"), :protocols ("cimprotocol"), :input-cit "vmware_esx_server"}), "snmp_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "snmp_check_credential", :description nil, :display-name "Check credential for SNMP protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("snmpprotocol"), :input-cit "discoveryprobegateway"}), "Xen_by_TTY" #=(clojure.lang.PersistentArrayMap/create {:id "Xen_by_TTY", :description "KVM and Xen discovery adapter based on libvirt cli", :display-name "Xen and KVM by Shell Adapter", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "virsh_path", :type "string", :description "Path to the virsh management utility"})), :discovered-classes ("physical_port" "virtualization_layer" "file_system_export" "execution_environment" "interface" "xen_domain_config" "containment" "layer2_connection" "node" "composition" "realization" "bridge" "file_system" "kvm_domain_config"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "vCloud_Director_by_vCloud_API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud_Director_by_vCloud_API", :description "Adapter discovers VMware vCloud Director using vCloud API", :display-name "vCloud Director by vCloud API", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVms", :description "Set this parameter to true to report powered off VMs", :type "string"})), :discovered-classes ("ip_address" "node" "interface" "vmware_vcloud" "vmware_vcloud_director" "vcloud_organization" "vcloud_vdc" "vcloud_vapp" "vcloud_vapp_template" "vcloud_media" "vcloud_catalog" "uri_endpoint" "usage" "manage" "composition" "containment" "aggregation"), :protocols ("vcloudprotocol"), :input-cit "node"}), "JBoss_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "JBoss_By_Shell", :description "This adapter discovers JBoss J2EE environment and components using shell.", :display-name "Jboss J2EE Topology Discovery by Shell", :parameters (), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "containment" "membership" "usage" "webservice" "jbossas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SNMP_Dis_L2_Bridge" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_Dis_L2_Bridge", :description "This adapter discovers the Layer 2 topology of a switch by SNMP.", :display-name "L2 Bridge by SNMP", :parameters (), :discovered-classes ("layer2_connection" "node" "physical_port" "membership" "composition" "realization" "bridge" "interface"), :protocols ("snmpprotocol"), :input-cit "bridge"}), "aws_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "aws_check_credential", :description nil, :display-name "Check credential for the Amazon Web Services", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("awsprotocol"), :input-cit "discoveryprobegateway"}), "OracleApps" #=(clojure.lang.PersistentArrayMap/create {:id "OracleApps", :description "This adapter discovers Oracle E-Business Suite components.", :display-name "Oracle E-Business Suite components", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "schemaName", :type "string", :description "If schema name is specified it will be used to query general system and applications information from database tables"}) #=(clojure.lang.PersistentArrayMap/create {:name "viewSchemaName", :type "string", :description "If schema name is specified it will be used to query general system and applications information from database views"})), :discovered-classes ("dbtablespace" "membership" "resource" "deployed" "oracle" "containment" "dependency" "process" "node" "ip_address" "oracleias" "oracleappservice" "composition" "usage" "oracleapplication" "oraclesystem" "oracleappservicemanager" "oraclewebcomponent"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "SAP_Dis_J2EE_Site" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Dis_J2EE_Site", :description "Discover SAP J2EE environment based on JMX.", :display-name "SAP J2EE Topology by JMX", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportComponentsAsConfigFile", :type "string", :description "When set to 'true' report java system components as registry (configuration file). When set to 'false' - report separate CI per component. Default value is 'true'"})), :discovered-classes ("webmodule" "messagedrivenbean" "j2ee_sap_central_services" "membership" "deployed" "sap_j2ee_server_process" "containment" "j2eeapplication" "dependency" "ejb" "running_software" "composition" "sap_j2ee_app_server" "ip_service_endpoint" "ejbmodule" "statelesssessionbean" "entitybean" "sap_system" "jdbcdatasource" "sap_j2ee_dispatcher" "configuration_document" "database" "statefulsessionbean" "servlet" "j2eecluster" "ip_address" "node" "usage" "j2eedomain" "sap_java_system_component"), :protocols ("sapjmxprotocol"), :input-cit "ip_address"}), "MS_NET_Dis_Domain" #=(clojure.lang.PersistentArrayMap/create {:id "MS_NET_Dis_Domain", :description "Discovers Microsoft Domains, same as: My Network Places->Entire Network.", :display-name "Discover Microsoft Domains", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "MsDomainsList", :description "MS Domains to be discovered", :type "string"})), :discovered-classes ("msdomain"), :protocols (), :input-cit "discoveryprobegateway"}), "SNMP_NET_Dis_VMS_catalyst" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_VMS_catalyst", :description "Discovers the physical ports on a VLAN", :display-name "VMS Catalyst by SNMP", :parameters (), :discovered-classes ("bridge" "composition" "containment" "dependency" "membership" "physical_port" "vlan"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "NSLOOKUP_on_Probe" #=(clojure.lang.PersistentArrayMap/create {:id "NSLOOKUP_on_Probe", :description "Discover hosts executing NSLOOKUP command on probe machine's shell", :display-name "NSLOOKUP on Probe", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DNSServerName", :type "string", :description "DNS Server Name"}) #=(clojure.lang.PersistentArrayMap/create {:name "DNSServerDomain", :type "string", :description "DNS Server Domain"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :discovered-classes ("nt" "ip_address" "node" "netprinter" "unix" "containment"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "discoveryprobegateway"}), "HSRP_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "HSRP_by_SNMP", :description "Discovers Cisco HSRP routers using SNMP protocol.", :display-name "Cisco HSRP routers by SNMP", :parameters (), :discovered-classes ("node" "ip_address" "membership" "containment"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "SQL_NET_Dis_sybase_Conn" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_sybase_Conn", :description "This adapter discovers Sybase database by SQL.", :display-name nil, :parameters (), :discovered-classes ("ip_address" "node" "sybase" "composition" "containment"), :protocols ("sqlprotocol"), :input-cit "ip_address"}), "CallHomeProcessing" #=(clojure.lang.PersistentArrayMap/create {:id "CallHomeProcessing", :description "Call Home Processing", :display-name "Call Home Processing", :parameters (), :discovered-classes (), :protocols (), :input-cit "callhome_event"}), "SAP_Dis_Applications" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Dis_Applications", :description "Discovers SAP environment based on Computer Center Management System (CCMS). Discovery process can take up to several hours in case long period of time is defined for transaction changes (the 'from' date to the 'to' date).", :display-name "SAP Application Components Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "getActiveTransactions", :type "string", :description "Get all active transactions and aggregated statistics if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getAllTransactions", :type "string", :description "Get all transactions if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getAppComponents", :type "string", :description "Get all the SAP application components if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "getTransChanges", :type "string", :description "Get transaction changes using Change and Transport System"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesDaysInterval", :type "string", :description "Get transaction changes by given number of days back from today"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesFromDate", :type "string", :description "Get transaction changes from this date"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesFromTime", :type "string", :description "Get changes from this time"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesToDate", :type "string", :description "Get transaction changes till this date"}) #=(clojure.lang.PersistentArrayMap/create {:name "transChangesToTime", :type "string", :description "Get transaction changes till this time"})), :discovered-classes ("sap_transport" "sap_transport_change" "sap_application_component" "sap_transaction" "composition" "sap_system" "usage" "containment"), :protocols ("sapprotocol"), :input-cit "sap_r3_server"}), "LDOM_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "LDOM_by_shell", :description "Adapter discovers LDOM topology via control domain.", :display-name "Oracle VM Server for SPARC Technology by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "match_domain_names_to_hostnames", :description "When enabled guest LDOMs will be reported with their hostnames set to domain names, which may aid in hosts reconciliation.", :type "string"})), :discovered-classes ("node" "ldom_resource" "hypervisor" "interface" "ip_address" "logical_volume" "layer2_connection" "composition" "containment" "dependency" "realization" "execution_environment" "membership"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SIEBEL_DIS_DB_NT" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_DB_NT", :description "Discover DB of odbc connection", :display-name "Siebel Database by NTCMD or UDA", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "oracle_name", :type "string", :description "Can include several ORACLE_NAME paths (for different machines) comma separated. If empty, uses hard-coded (in the script) registry locations"})), :discovered-classes ("dependency" "ip_address" "node" "composition" "containment" "database"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "siebel_app_server"}), "SQL_APP_Dis_SqlServer" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_APP_Dis_SqlServer", :description "The job discovers MS SQL Server topology.", :display-name "MS SQL Server topology by SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigs", :description "True (the default): server configuration ('mssql database configuration.txt') is retrieved.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDbUser", :description "True: database users are discovered; false (the default): database users are not discovered.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSqlFile", :description "True: sql/data files are discovered; false (the default): sql/data files are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSqlJob", :description "True: SQL Jobs are discovered; false (the default): SQL Jobs are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverStoredProcedures", :description "True: SQL Stored Procedure are discovered; false (the default): SQL Stored Procedure are not discovered", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInternalProcedures", :description "True: Report Internal SQL Stored Procedures from master and msdb databases; false (the default): Internal SQL Stored Procedure from master and msdb are not reported.\\nNote: Internal system procedure begins from such strings 'sp_', 'xp_', 'ms_' and 'sysmail_'", :type "string"})), :discovered-classes ("replicated" "sqlfile" "sqldatabase" "sqlserverpublication" "sqlservermaintenanceplan" "sqlbackup" "sqlserversubscription" "configuration_document" "dbuser" "containment" "dblink" "dependency" "process" "ip_address" "node" "ownership" "composition" "sqlserverdistributor" "usage" "sqljob" "sqlserver" "dbclient" "sqlserverpublisher" "file_system" "dbaobjects"), :protocols ("sqlprotocol"), :input-cit "sqlserver"}), "WebSphere_Webserver_Dependency" #=(clojure.lang.PersistentArrayMap/create {:id "WebSphere_Webserver_Dependency", :description "Pattern discovers dependencies between web servers and WebSphere application servers.", :display-name "Web server to WebSphere Dependency", :parameters (), :discovered-classes ("dependency" "httpcontext" "j2eedeployedobject" "running_software"), :protocols (), :input-cit "webmodule"}), "LDAP_Active_Directory_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "LDAP_Active_Directory_Connection", :description "Discover the existence of Active Directory Domain Controlers via LDAP", :display-name "LDAP Active Directory Connection", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description "Value referes to the DN under which records about domain controller servers are stored. Default value is OU=Domain Controllers"})), :discovered-classes ("node" "ip_address" "domaincontroller" "composition" "containment"), :protocols ("ldapprotocol"), :input-cit "ip_address"}), "oracle_tns_names_by_ldap" #=(clojure.lang.PersistentArrayMap/create {:id "oracle_tns_names_by_ldap", :description "This adapter discovers Oracle database topology by SQL.", :display-name "Oracle TNS Names by LDAP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDN", :description "LDAP root node from which will be search orclContext objects"})), :discovered-classes ("composition" "containment" "ip_service_endpoint" "usage" "realization" "ip_address" "node" "oracle" "oracle_servicename" "oracle_listener"), :protocols ("ldapprotocol"), :input-cit "domaincontroller"}), "hp_nonstop_topology_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "hp_nonstop_topology_by_shell", :description "HP NonStop topology discovery.", :display-name nil, :parameters (), :discovered-classes ("hp_nonstop" "nonstop_sql_mx" "composition" "database_instance" "database"), :protocols ("sshprotocol" "udaprotocol"), :input-cit "shell"}), "InventoryDiscoveryByManualScannerDeployment" #=(clojure.lang.PersistentArrayMap/create {:id "InventoryDiscoveryByManualScannerDeployment", :description "This adapter executed hardware and installed software inventory discovery by manually deployed scanfile.", :display-name "Inventory Discovery by Manual Scanner Deployment", :parameters (#=(clojure.lang.PersistentArrayMap/create {:display-type "MappingConfiguration", :name "MappingConfiguration", :description "Specifies scan file model mapping configuration.", :type "xml"})), :discovered-classes ("composition" "containment" "installed_software" "ip_address" "node" "cpu" "hardware_board" "graphics_adapter" "disk_device" "display_monitor" "inventory_scanner" "file_system" "file_system_export"), :protocols (), :input-cit "discoveryprobegateway"}), "ICMP_NET_Dis_IpNetwork" #=(clojure.lang.PersistentArrayMap/create {:id "ICMP_NET_Dis_IpNetwork", :description "Performs IP ping sweep", :display-name "IP ping sweep", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :description "Ping time out (Ms)", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :description "Ping retry", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "virtualModeDiscover", :description "Flag that indicates if we want to discover the virtual ips", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :type "string", :description "Ping protocol: ICMP (1), ECHO PORT (2) or both (3)"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :type "string", :description "Number of threads in pool that performs port 7 echoing"}) #=(clojure.lang.PersistentArrayMap/create {:name "byScopeDiscover", :description "Flag that indicates if we ping ips out of scope", :type "string"})), :discovered-classes ("dependency" "ip_address" "ip_subnet" "membership"), :protocols (), :input-cit "ip_subnet"}), "TTY_HR_All" #=(clojure.lang.PersistentArrayMap/create {:id "TTY_HR_All", :description "Discovers host resources, process connectivity and software elements on UNIX and Windows machines using SSH, Telnet, NTCMD or UDA protocols.", :display-name "Host Resources by TTY", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery.In case this value is true, all installed softwares are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery. For Windows machines only Local Users are discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "lsofPath", :type "string", :description "Path where lsof command can be found for process communication discovery on UNIX machines."}) #=(clojure.lang.PersistentArrayMap/create {:name "useLSOF", :type "string", :description "When the parameter is set to true, discovery tries to use LSOF utility to discover process-to-port information on Unix machines."}) #=(clojure.lang.PersistentArrayMap/create {:name "useNetstatOnly", :type "string", :description "Use only netstat command during discovery TCP data. All lsof parameters will be ignored."}) #=(clojure.lang.PersistentArrayMap/create {:name "wmicPath", :type "string", :description "Default wmic path"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :discovered-classes ("osuser" "file_system_export" "cpu" "windows_service" "containment" "process" "dependency" "client_server" "ip_address" "node" "running_software" "iisapppool" "composition" "usage" "realization" "ip_service_endpoint" "installed_software" "file_system"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "TCP_NET_Dis_Port" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_NET_Dis_Port", :description "Discover open tcp\\udp ports on a host of known server ports.", :display-name "TCP Ports Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "checkIfIpIsReachable", :description "Flag that indicates if we want to check if the discovered IP is reachable before we ping its ports (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "checkOnlyKnownPorts", :description "Discover only known ports. This flag does not cancel 'ports' parameter - overriding this flag to false is applicable only with real ports range in 'ports' parameter", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "connectTimeOut", :description "The timeout when connecting to IP and port", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "nmapPath", :description "Full path to nmap executable file. (e.g. C:\\Program Files (x86)\\Nmap\\nmap.exe)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingTimeOut", :description "ICMP ping timeout Ms", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ports", :description "List of TCP ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNMap", :description "Flag indicating to use nmap or not during port scanning. Note: if nmapPath was not specified the nmap from system path will be used", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "scanUDP", :description "Flag indicating to scan UDP ports. Note: UDP scan support only if nmap is used", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "UDPports", :description "List of UDP ports, can include ranges, separate port numbers and known protocol names (like http, ftp, etc) comma separated.Empty or * : all knownports. Also accepts ranges like 1000-1100 which would be filtered to known ports or not according to the checkOnlyKnownPorts parameter", :type "string"})), :discovered-classes ("composition" "containment" "ip_address" "ip_service_endpoint" "node"), :protocols (), :input-cit "ip_address"}), "SNMP_NET_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_Connection", :description "Discovers SNMP agents by trying to connect to a data center machine using the SNMP protocol, updates the node class (Windows, UNIX, router, and so on) according to the relevant OID", :display-name "Host Connection by SNMP", :parameters (), :discovered-classes ("atmswitch" "composition" "containment" "fcswitch" "firewall" "interface" "ip_address" "ip_subnet" "ldom_virtual_switch" "lb" "mainframe" "marconiatmswitch" "membership" "netdevice" "netprinter" "node" "parent" "ras" "router" "snmp" "switch" "terminalserver" "unix" "vax" "vmware_virtual_switch" "nt"), :protocols ("snmpprotocol"), :input-cit "ip_address"}), "Host_Connection_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Host_Connection_By_Shell", :description "Establishes a Shell connection to the remote machines. Discovery tries to connect to remote machines through the SSH, Telnet, NTCMD or UDA protocols until the first valid connection is found.", :display-name "Host Connection by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :type "string", :description "Discovered machine language"}) #=(clojure.lang.PersistentArrayMap/create {:name "udaConnectionOrder", :description "When should be the position of UD Protocol in the protocol connections order. Possible values: first, last, none", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useAIXhwId", :type "string", :description "Identify IBM AIX machines using hardware Id. Note: when set as true and used along with SNMP discovery, duplicate hosts might be created. When set as false no AIX LPAR will be discovered."}) #=(clojure.lang.PersistentArrayMap/create {:name "enableStamping", :type "string", :description "Whether to enable stamping ud_unique_id to the managed computer"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyStampingClient", :type "string", :description "Whether to only stamp on client IP. If turned off, it will be set in any case (both data centre and client)."})), :discovered-classes ("hp_nonstop" "snmp" "nt" "terminalserver" "membership" "parent" "switch" "ras" "vax" "interface" "ssh" "ip_subnet" "containment" "telnet" "ntcmd" "uda" "ip_address" "usage" "realization" "sea_adapter" "node" "running_software" "router" "atmswitch" "dns_server" "composition" "unix" "ipmp_group"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "ip_address"}), "InventoryDiscoveryByScanner" #=(clojure.lang.PersistentArrayMap/create {:id "InventoryDiscoveryByScanner", :description "This adapter executed hardware and installed software inventory discovery by scanners.", :display-name "Inventory Discovery By Scanner Adapter", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "IsScannerDowngradeAllowed", :description "Specifies if scanner downgrade is allowed", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsScannerUpgradeAllowed", :description "Specifies if scanner upgrade is allowed", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "IsPrePostScriptAllowed", :description "Specifies if allow scanner run pre-scan/post-scan scripts", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrePostScriptExecTimeout", :description "Pre-scan/post-scan script maximum runtime(min)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RemoveScanData", :description "Remove Scan data on remote host after it was downloaded on probe machine.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DownloadScanFileBeforeExecution", :description "Download Scan File from remote machine (if exists) before execution.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ScannerConfigurationFile", :description "Specifies configuration file name which should be uploaded with scanner and used for scanner execution.", :type "xml", :display-type "ScannerConfigurationPerPlatform"}) #=(clojure.lang.PersistentArrayMap/create {:display-type "MappingConfiguration", :name "MappingConfiguration", :description "Specifies scan file model mapping configuration.", :type "xml"}) #=(clojure.lang.PersistentArrayMap/create {:name "enableStamping", :type "string", :description "Whether to enable stamping ud_unique_id to the managed computer"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyStampingClient", :type "string", :description "Whether to only stamp on client IP. If turned off, it will be set in any case (both data centre and client)."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."}) #=(clojure.lang.PersistentArrayMap/create {:name "collectIPv6Connectivity", :type "string", :description "If collect IPv6 related connectivity"}) #=(clojure.lang.PersistentArrayMap/create {:name "filterP2PProcessesByName", :type "string", :description "Processes names that should not be reported(* to filter all processes - no P2P)"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreP2PLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "P2PServerPorts", :type "string", :description "Server Ports to discover, can either be a number or a known  name, separated by comma (use * for all ports)"})), :discovered-classes ("composition" "containment" "installed_software" "ip_address" "node" "cpu" "hardware_board" "graphics_adapter" "disk_device" "display_monitor" "inventory_scanner" "file_system" "file_system_export" "process" "running_software" "ip_service_endpoint" "realization" "usage" "dependency"), :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :input-cit "node"}), "Glassfish_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Glassfish_By_Shell", :description "This adapter discovers Glassfish JEE environment and components using shell.", :display-name "Glassfish JEE Topology Discovery by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportAdminApps", :description "enables/disables reporting of administrator applications if value is 'true'/'false'.", :type "string"})), :discovered-classes ("node" "ip_address" "j2eedomain" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "composition" "dependency" "deployed" "membership" "usage" "webservice" "glassfishas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SolarisZone_Disc_By_TTY" #=(clojure.lang.PersistentArrayMap/create {:id "SolarisZone_Disc_By_TTY", :description "This adapter discovers Solaris Zones by shell protocols (SSH, Telnet or UDA) including non-global zones, resource pools, netwroking CPU and their dependencies.", :display-name "Solaris Zone by TTY", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "zloginWithConnectedUser", :description "If true zlogin will be done with connected to global zone user account. If false then zlogin will use root account", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"})), :discovered-classes ("file_system_export" "membership" "cpu" "parent" "interface" "ip_subnet" "containment" "solaris_resource_pool" "node" "ip_address" "fchba" "realization" "composition" "usage" "solaris_zone_config" "ipmp_group" "file_system" "execution_environment" "hypervisor"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "VMware_ESX_Connection_by_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_ESX_Connection_by_VIM", :description "adapter discovers VMware ESX Servers running on Unix hosts.", :display-name "VMware ESX Connection by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("virtualization_layer" "composition" "vmware_esx_server"), :protocols ("vmwareprotocol"), :input-cit "node"}), "Veritas_Cluster_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "Veritas_Cluster_Topology", :description "Discover Veritas cluster server architecture by Shell", :display-name "Veritas Cluster Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"}) #=(clojure.lang.PersistentArrayMap/create {:name "main_cf_path", :type "string", :description "Veritas Main.cf folder. Default: /etc/VRTSvcs/conf/config/"})), :discovered-classes ("membership" "veritascluster" "configuration_document" "containment" "vcsresource" "dependency" "vcsgroup" "node" "ip_address" "ownership" "running_software" "composition" "usage" "cluster_software" "ip_service_endpoint"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "JMX_Only_J2EE_WebSphere" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_Only_J2EE_WebSphere", :description "This adapter discovers WebSphere J2EE environment and components.", :display-name "Websphere J2EE Topology Discovery by JMX", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "applications", :description "List of applications to discover (comma separated)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigFile", :description "Discover additional configuration files for cell, server, and application, if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverEAR", :description "Discover J2ee application EAR files if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJDBCResources", :description "Discover jdbc providers and datasources if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "servers", :description "List of servers to discover (comma separated)", :type "string"})), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "websphereprotocol"), :input-cit "websphereas"}), "DB_Connect_by_Agent" #=(clojure.lang.PersistentArrayMap/create {:id "DB_Connect_by_Agent", :description "Identifies databases on hosts using host credentials using the WMI protocol", :display-name "Database Connections by Agent", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discover_oracle", :type "string", :description "Set to \"true\" for Oracle identification"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_mssql", :type "string", :description "Set to \"true\" for Microsoft SQL Server  identification"})), :discovered-classes ("nt" "ip_address" "node" "composition" "ip_service_endpoint" "sqlserver" "oracle" "containment"), :protocols ("wmiprotocol"), :input-cit "wmi"}), "SIEBEL_DIS_DB_UNIX" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_DB_UNIX", :description "Discover DB of odbc connection", :display-name "Siebel Database by Unix shell", :parameters (), :discovered-classes ("dependency" "ip_address" "node" "composition" "database" "containment"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "siebel_app_server"}), "TCP_ServicesConnectivity" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_ServicesConnectivity", :description "Discovers the IP Communication adapters - which IPs communicte and the top interesting ports for these communication channels. Brings data from Universal Discovery database.", :display-name "TCP Services Connectivity", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "maxPorts", :type "string", :description "Number of most important ports reported for each traffic link"}) #=(clojure.lang.PersistentArrayMap/create {:name "tcpOnly", :type "boolean", :description "Should discover only tcp traffic"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "boolean", :description "Report traffic from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "boolean", :description "Report traffic from client found in flows but not in scope"})), :discovered-classes ("ip_address" "node" "traffic" "containment"), :protocols (), :input-cit "discoveryprobemanager"}), "JMX_J2EE_JBoss_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_JBoss_Connection", :description "This adapter discovers JBoss servers instances based on the JMX protocol.", :display-name "Jboss Server Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("j2eedomain" "jeenode" "node" "composition" "usage" "ip_service_endpoint" "containment" "membership" "ip_address" "jbossas"), :protocols ("jbossprotocol"), :input-cit "ip_address"}), "ServiceNowPushAdapter" #=(clojure.lang.PersistentArrayMap/create {:id "ServiceNowPushAdapter", :description "Adapter to push data from uCMDB to Service-Now.com", :display-name "Service-Now Push", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ServiceNowDomain", :description "The Service-Now Instance Domain Name (Default: service-now.com)", :type "string", :display-name "Service-Now Domain", :mandatory "true", :order-index "10"}) #=(clojure.lang.PersistentArrayMap/create {:name "ServiceNowInstance", :description "The Service-Now Instance Name (Default: demo)", :type "string", :display-name "Service-Now Instance", :mandatory "true", :order-index "10"}) #=(clojure.lang.PersistentArrayMap/create {:name "port", :description "The Service-Now connection port (Default: 443))", :type "integer", :display-name "Port", :mandatory "true", :order-index "11"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocol", :description "The Service-Now connection protocol (Can be http or https, Default: https))", :type "string", :display-name "Protocol", :mandatory "true", :order-index "11"}) #=(clojure.lang.PersistentArrayMap/create {:name "ProxyServer", :description "Proxy server name/IP (if required for outgoing Internet connections)", :type "string", :display-name "Proxy Server Name/IP", :mandatory "false", :order-index "12"}) #=(clojure.lang.PersistentArrayMap/create {:name "ProxyPort", :description "Proxy server port (if required for outgoing Internet connections)", :type "integer", :display-name "Proxy Server Port", :mandatory "false", :order-index "12"}) #=(clojure.lang.PersistentArrayMap/create {:name "probeName", :description "The values will be automaticly replaced by the UCMDB UI", :type "string", :mandatory "true", :display-name "Probe", :order-index "13"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "The credentials to be used", :type "integer", :display-name "Credentials ID", :mandatory "true", :order-index "13"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("link" "object"), :protocols (), :input-cit "destination_config"}), "ibm_tivoli_network_manager_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "ibm_tivoli_network_manager_by_shell", :description "This adapter populates network topology using the XML file generated by IBM Tivoli Network Manager Discovery Library Adapter (DLA)", :display-name "IBM Tivoli Network Manager", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dla_config_file_name", :description "Configuration file which is used to export IdML", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ncp_dla_executable_path", :description "Filesystem path to ncp_dla.sh", :type "string"})), :discovered-classes (), :protocols ("sshprotocol"), :input-cit "ssh"}), "SQL_NET_Dis_Connection_Sybase" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection_Sybase", :description "This adapter discovers databases using SQL protocol.", :display-name "Sybase Connection By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :discovered-classes ("sybase" "composition" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :protocols ("sqlprotocol"), :input-cit "node"}), "EView iSeries Connection" #=(clojure.lang.PersistentArrayMap/create {:id "EView iSeries Connection", :description "This discovery adapterconnects to the Eview iSeries Agent ", :display-name "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "EViewInstallationFolder", :description "Installation root directory of the EView client on the probe server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "This flag (True/False) provides additional debug information in the debug logs.", :type "string"})), :discovered-classes ("as400_node" "composition" "containment" "eview" "ip_address"), :protocols (), :input-cit "discoveryprobegateway"}), "JMX_J2EE_WebSphere" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_WebSphere", :description "This adapter discovers WebSphere J2EE environment and components.", :display-name "Websphere J2EE Topology Discovery by JMX", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "applications", :type "string", :description "List of applications to discover (comma separated)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :type "string", :description "Discover modules, ejbs and servlets if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverConfigFile", :type "string", :description "Discover additional configuration files for cell, server, and application, if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverEAR", :type "string", :description "Discover J2ee application EAR files if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJDBCResources", :type "string", :description "Discover jdbc providers and datasources if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :type "string", :description "Discover jms providers and jms servers if set to true"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"}) #=(clojure.lang.PersistentArrayMap/create {:name "servers", :type "string", :description "List of servers to discover (comma separated)"})), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "composition" "dependency" "deployed" "membership" "usage" "webservice" "websphereas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "websphereprotocol" "udaprotocol"), :input-cit "websphereas"}), "UninstallUDAgent" #=(clojure.lang.PersistentArrayMap/create {:id "UninstallUDAgent", :description "This adapter uninstalls UD Agent.", :display-name "Uninstall UD Agent", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "RemoveAgentData", :description "Remove Agent data on remote host after the Agent itself was uninstalled. (e.g. log file, utilization data, etc.", :type "string"})), :discovered-classes ("composition" "node" "ntcmd" "ssh" "telnet"), :protocols ("ntadminprotocol" "sshprotocol" "udaprotocol"), :input-cit "node"}), "SQL_APP_Dis_Db2" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_APP_Dis_Db2", :description "Discover the physical elements within DB2 database.", :display-name "DB2 Topology By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "report_system_tables", :description "Flag indicating whether job should report system tables", :type "boolean"})), :discovered-classes ("db2" "db2_database" "db2_buffer_pool" "dbtable" "dbdatafile" "dbtablespace" "db2_partition_group" "db2_partition" "db2_schema" "ip_address" "ip_service_endpoint" "node" "process" "resource" "composition" "containment" "usage" "membership"), :protocols ("sqlprotocol"), :input-cit "db2_database"}), "Merge_Clustered_Software" #=(clojure.lang.PersistentArrayMap/create {:id "Merge_Clustered_Software", :description "Adapter used by the Merging topologies of the Clustered Software Elements", :display-name "Merge Clustered Software", :parameters (), :discovered-classes ("node" "running_software"), :protocols (), :input-cit "running_software"}), "NNM_Update_Ids" #=(clojure.lang.PersistentArrayMap/create {:id "NNM_Update_Ids", :description "Updates the nodes in the NNM topology with the UCMDB IDs of the corresponding nodes in UCMDB", :display-name "Push IDs into NNMi", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("nnmprotocol"), :input-cit "ip_address"}), "IBM_HMC_SHELL_PATTERN" #=(clojure.lang.PersistentArrayMap/create {:id "IBM_HMC_SHELL_PATTERN", :description "Discovery adapter for IBM HMC or IVM Software and related Virtualization PSeries Solution discovery", :display-name "IBM Virtualization by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportLparNameAsHostName", :description "Should the job report virtual host names as Lpar names.", :type "string"})), :discovered-classes ("shell" "physical_port" "virtualization_layer" "membership" "execution_environment" "scsi_adapter" "ibm_resource_pool" "ibm_lpar_profile" "cpu" "ioslot" "manage" "interface" "ibm_hmc" "containment" "ibm_pseries_frame" "ip_address" "node" "composition" "usage" "realization" "vlan" "ibm_ivm"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "ip_address"}), "VMware_VirtualCenter_Connection_by_WMI_and_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_VirtualCenter_Connection_by_WMI_and_VIM", :description "adapter discovers the VMware VirtualCenter connection using Virtual Infrastructure Management protocol.  If VIM port is specified in credentials, this port will be used. Otherwise it tries to connect to host using WMI protocol and retrieves the VirtualCenter's port information from registry.  The retrieved information is used to generate the connection URL.", :display-name "VMware VirtualCenter Connection by WMI and VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("node" "ip_address" "composition" "vmware_virtual_center" "containment"), :protocols ("vmwareprotocol" "wmiprotocol"), :input-cit "node"}), "Oracle Application Server" #=(clojure.lang.PersistentArrayMap/create {:id "Oracle Application Server", :description "Discovers Oracle Application Server", :display-name "Oracle Application Server", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "port", :description "", :type "string"})), :discovered-classes ("composition" "dependency" "ip_address" "node" "containment" "oc4j" "oc4jgroup" "oracleias" "running_software" "uri_endpoint"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "MICROSOFT_MQ" #=(clojure.lang.PersistentArrayMap/create {:id "MICROSOFT_MQ", :description "Discovery adapter for Microsoft MQ server. Used to retrieve Active Directory side information of MS MQ topology.", :display-name "Microsoft MQ server from Active Directory", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseDn", :type "string", :description ""})), :discovered-classes ("activedirectorysite" "node" "ip_address" "msmqmanager" "activedirectoryforest" "membership" "composition" "usage" "activedirectorysystem" "containment"), :protocols ("ldapprotocol"), :input-cit "domaincontroller"}), "UDDI_Registry_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "UDDI_Registry_Connection", :description "This adapter discovers the UDDI registry using a given URL.", :display-name "UDDI Registry Connection", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("uddiregistry"), :protocols ("uddiregistryprotocol"), :input-cit "discoveryprobemanager"}), "SIEBEL_DIS_WEBAPPS_NT" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_WEBAPPS_NT", :description "This adapter discovers Siebel Webserver Extension and all web applications by NTCMD or UDA protocol.", :display-name "Siebel Web Applications by NTCMD or UDA", :parameters (), :discovered-classes ("dependency" "ip_address" "node" "siebel_wse" "route" "siebel_site" "siebel_web_app" "composition" "configuration_document" "siebel_gateway" "web_server" "containment"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "web_server"}), "tcp_discovery_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "tcp_discovery_by_shell", :description "Discovers TCP information on particular host. Allows multiple discovery cycles to obtain temporary short-lived connections. Reports nothing to UCMDB but collected data used by other jobs to link other CIs to TCP data (like Host resources jobs).", :display-name "TCP Discovery by Shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "CaptureProcessInformation", :type "string", :description "Whether to capture processes information"}) #=(clojure.lang.PersistentArrayMap/create {:name "DelayBetweenTCPSnapshots", :type "string", :description "Pause in seconds between discovery cycles"}) #=(clojure.lang.PersistentArrayMap/create {:name "NumberOfTCPSnapshots", :type "string", :description "The count of discovery cycles on particular destination"}) #=(clojure.lang.PersistentArrayMap/create {:name "lsofPath", :type "string", :description "Path where lsof command can be found"}) #=(clojure.lang.PersistentArrayMap/create {:name "useLSOF", :type "string", :description "On Unix machine we can find port to process mapping with lsof command(if installed)"}) #=(clojure.lang.PersistentArrayMap/create {:name "useNetstatOnly", :type "string", :description "Use only netstat command during discovery TCP data. All lsof parameters will be ignored."})), :discovered-classes (), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "jboss_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "jboss_check_credential", :description nil, :display-name "Check credential for the JBoss JMX protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("jbossprotocol"), :input-cit "discoveryprobegateway"}), "ECC_Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "ECC_Discovery", :description "Populates storage devices and SAN infrastructure from the EMC control Center SRM database", :display-name "EMC Control Center", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"})), :discovered-classes ("composition" "containment" "cpu" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "node" "storagearray" "storagefabric" "storageprocessor" "unix" "nt"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "generic_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "generic_check_credential", :description nil, :display-name "Check credential for Generic protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("genericprotocol"), :input-cit "discoveryprobegateway"}), "CiscoWorks_NetDevices" #=(clojure.lang.PersistentArrayMap/create {:id "CiscoWorks_NetDevices", :description "This adapter populates network devices and layer two infrastructure from the Cisco Works Resource Manager Essentials database", :display-name "CiscoWorks NetDevices", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryChunkSize", :description "Number of nodes to query at a time (Default: 250)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "rmeDbName", :description "Name of the CiscoWorks Resource Manager Essentials database in Sybase (default: rmengdb)", :type "string"})), :discovered-classes ("composition" "containment" "hardware_board" "interface" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :protocols ("sqlprotocol"), :input-cit "ip_service_endpoint"}), "sim_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sim_check_credential", :description nil, :display-name "Check credential for SIM protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("simprotocol"), :input-cit "discoveryprobegateway"}), "Atrium to UCMDB" #=(clojure.lang.PersistentArrayMap/create {:id "Atrium to UCMDB", :description "Populates CIs and relationships from BMC Atrium", :display-name "Population from Atrium", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ARS_Server", :description "Hostname or IP address of the BMS ARS server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARS_Port", :description "Port for connecting to the ARS server. If portmapper is being used, this should be  left as 0, else specify the TCP port", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "BMC_NameSpace", :description "The BMC NameSpace to use (E.g. BMC.CORE)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :description "Chunk size in which the data should be retrieved from the remote server", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DateParsePattern", :description "Set the Date pattern to parse Atrium date strings", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :description "Set to true to run integration in debug mode. I.e. not send any data to UCMDB.", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "credentialsId", :description "Credential used for the specific integration", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("remedyprotocol"), :input-cit "discoveryprobegateway"}), "CiscoWorks_Layer2" #=(clojure.lang.PersistentArrayMap/create {:id "CiscoWorks_Layer2", :description "This adapter populates nodes layer two infrastructure from the Cisco Works Campus Manager database", :display-name "CiscoWorks Layer 2", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "allowDnsLookup", :description "If an IP address is not available for a node, setting this to true will enable DNS lookup using the node name", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "campusDbName", :description "Name of the CiscoWorks Campus database in Sybase (default: aniDB)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreNodesWithoutIP", :description "If this is set to false, CIs for nodes without IPs will be created with the storage system's internal ID as host_key (This may result in duplicate nodes)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "queryChunkSize", :description "Number of nodes to query at a time (Default: 1000)", :type "string"})), :discovered-classes ("composition" "containment" "hardware_board" "interface" "ip_address" "ip_subnet" "layer2_connection" "membership" "node" "physical_port" "realization" "vlan"), :protocols ("sqlprotocol"), :input-cit "ip_service_endpoint"}), "WebserviceByURL" #=(clojure.lang.PersistentArrayMap/create {:id "WebserviceByURL", :description "Discovers the Webservice topology by reading WSDL content from a given URL", :display-name "Web Services by URL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "autoAcceptCerts", :description "Temporary accept received certificates as trusted", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "importWsdlDocuments", :type "string", :description "If set to true, imported WSDL documents will be retrieved and processed."})), :discovered-classes ("webservice_operation" "dependency" "composition" "webservice" "configuration_document" "containment" "uri_endpoint"), :protocols ("httpprotocol"), :input-cit "uri_endpoint"}), "SQL_NET_Dis_Connection_DB2" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection_DB2", :description "This adapter discovers databases using SQL protocol.", :display-name "DB2 Connection By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :description "Used protocol type", :type "string"})), :discovered-classes ("db2" "db2_database" "ip_service_endpoint" "node" "composition" "usage"), :protocols ("sqlprotocol"), :input-cit "node"}), "TTY_Net_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "TTY_Net_Dis_Connection", :description "This adapter discovers SSH and Telnet agents by trying to connect to a machine using TTY as well as updating the correct host class (Windows, UNIX, router, and so on).", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "useAIXhwId", :description "Identify IBM AIX machines using hardware Id. Note: when set as true and used along with SNMP discovery, duplicate hosts might be created. when set as false no AIX LAPR will be discovered.", :type "string"})), :discovered-classes ("ip_address" "node" "membership" "composition" "parent" "interface" "ssh" "telnet" "ip_subnet" "containment"), :protocols ("sshprotocol" "telnetprotocol"), :input-cit "ip_address"}), "SQL_APP_Dis_Sybase" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_APP_Dis_Sybase", :description "This adapter discovers Sybase database topology by SQL.", :display-name "Sybase Topology by SQL", :parameters (), :discovered-classes ("process" "dbtablespace" "node" "sybase" "ip_address" "sybasedb" "dbdatafile" "composition" "resource" "dbclient" "containment"), :protocols ("sqlprotocol"), :input-cit "sybase"}), "SIEBEL_DIS_WEBAPPS_UNIX" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_WEBAPPS_UNIX", :description "Discover Siebel Webserver Extension and all web applications", :display-name "Siebel Web Applications by Unix shell", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "eappsCfgPath", :type "string", :description "Path to Siebel Webserver Extention cofiguration file (eapps.cfg)"})), :discovered-classes ("dependency" "ip_address" "node" "siebel_wse" "siebel_site" "siebel_web_app" "route" "composition" "configuration_document" "web_server" "siebel_gateway" "containment"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "web_server"}), "VMware_VIM_Connection_Manual" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_VIM_Connection_Manual", :description "adapter discovers the VMware Server connection using Virtual Infrastructure Management protocol. It is activated manually and it uses the URL string parameter for connection.", :display-name "VMware VirtualCenter and ESX Manual Connection by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("composition" "containment" "ip_address" "node" "vmware_esx_server" "vmware_virtual_center" "virtualization_layer"), :protocols ("vmwareprotocol"), :input-cit "ip_address"}), "JMX_J2EE_WebLogic" #=(clojure.lang.PersistentArrayMap/create {:id "JMX_J2EE_WebLogic", :description "This adapter discovers WebLogic j2ee environment and components.Supported WL versions:6.0, 6.1, 7.0, 8.1, 9.0, 9.1, 9.2,10", :display-name "Weblogic J2EE Topology Discovery by JMX", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "deploymentDescriptors", :description " Set to true to fetch deployment descriptors of J2EE Application, EJB Modules and Web Modules (value: true/false ).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverAppResources", :description "Discover modules, ejbs and servlets if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDeployedOnlyApplications", :description "Discover applications that are deployed and in running status"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverJMSResources", :description "Discover jms providers and jms servers if set to true", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :description "JVM parameters that should be passed to the remote process", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Should pattern run in separate thread", :type "string"})), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "composition" "dependency" "deployed" "membership" "usage" "webservice" "weblogicas"), :protocols ("weblogicprotocol"), :input-cit "weblogicas"}), "EMC_AutoStart_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "EMC_AutoStart_by_Shell", :description "Discover EMC AutoStart cluster by shell", :display-name "EMC AutoStart by Shell", :parameters (), :discovered-classes ("cluster_resource_config" "cluster_resource_group" "cluster_resource_group_config" "cluster_software" "composition" "containment" "emc_autostart_cluster" "execution_environment" "ip_address" "membership" "node" "ownership"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :input-cit "shell"}), "SNMP_NET_Dis_Connection_Client" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_Connection_Client", :description "Discovers SNMP agents by trying to connect to a client machine using the SNMP protocol, updates the node class (Windows, UNIX, router, and so on) according to the relevant OID.", :display-name "Client Connection by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "excludePatternsList", :description "Semicolon-separated (;) list of wildcard patterns. IP addresses matching any of the patterns are skipped. Pattern may include numbers, dots, * (matches zero or more characters) or ? (matches exactly one character).", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "pingProtocol", :description "Numeric ping protocol: ICMP (1), ECHO PORT (2) or both (3)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "range", :description "Range of IPs to ping separated by semicolon (Sample 1.2.3.0-1.2.3.10;1.2.3.50-1.2.3.60)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "retryDiscover", :description "Ping retry", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "threadPoolSize", :description "Number of threads in pool that performs port 7 echoing", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "timeoutDiscover", :description "Ping time out (Ms)", :type "string"})), :discovered-classes ("atmswitch" "composition" "containment" "fcswitch" "firewall" "interface" "ip_address" "ip_subnet" "ldom_virtual_switch" "lb" "mainframe" "marconiatmswitch" "membership" "netdevice" "netprinter" "node" "parent" "ras" "router" "snmp" "switch" "terminalserver" "unix" "vax" "vmware_virtual_switch" "nt"), :protocols ("snmpprotocol"), :input-cit "discoveryprobegateway"}), "WMI_HR_All" #=(clojure.lang.PersistentArrayMap/create {:id "WMI_HR_All", :description "This adapter discovers host resources and software elements on Windows machines using WMI protocol.", :display-name "Host Resources by WMI", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCPUs", :type "string", :description "Perform CPUs discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverDisks", :type "string", :description "Perform disks discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftware", :type "string", :description "Perform software discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverInstalledSoftwareByOldMechanism", :type "string", :description "Perform software discovery by old non-efficient mechanism"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverMemory", :type "string", :description "Perform memory discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverProcesses", :type "string", :description "Perform processes discovery.In case this value is true, all processes are reported disregarding whether they have signature"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverServices", :type "string", :description "Perform services discovery. In case this value is true, all services are reported. In case this value is false, services are not reported."}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverShares", :type "string", :description "Perform shared resources discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUsers", :type "string", :description "Perform users discovery"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRunningSW", :type "string", :description "Perform Running Software discovery by Application Signature."})), :discovered-classes ("file_system_export" "cpu" "winosuser" "windows_service" "containment" "dependency" "process" "ip_address" "node" "running_software" "iisapppool" "composition" "realization" "usage" "ip_service_endpoint" "installed_software" "file_system"), :protocols ("wmiprotocol"), :input-cit "wmi"}), "MS_Exchange_Topology_by_WMI" #=(clojure.lang.PersistentArrayMap/create {:id "MS_Exchange_Topology_by_WMI", :description "Connects to the remote host and brings topology for Microsoft Exchange Server 2003", :display-name "Microsoft Exchange Topology by WMI", :parameters (), :discovered-classes ("exchange_administrative_group" "ms_exchange_folder" "ip_address" "node" "membership" "routing_group" "exchangesystem" "composition" "ms_exchange_folder_tree" "containment" "ms_exchange_server"), :protocols ("wmiprotocol"), :input-cit "ms_exchange_server"}), "Service_Guard_Cluster_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "Service_Guard_Cluster_Topology", :description "Discover ServiceGuard cluster server architecture by TTY", :display-name "Service Guard Cluster Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "cmclconfig_file", :type "string", :description "Configuration file(extention or file name,default - extention 'ascii')"}) #=(clojure.lang.PersistentArrayMap/create {:name "cmclconfig_path", :type "string", :description "The path to the configuration files"}) #=(clojure.lang.PersistentArrayMap/create {:name "codepage", :type "string", :description "Discovered machine code page"})), :discovered-classes ("membership" "execution_environment" "serviceguardcluster" "configuration_document" "containment" "dependency" "ip_address" "node" "sgpackage" "ownership" "sgresource" "composition" "cluster_software"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "IHS_Dis_WebspherePlugin" #=(clojure.lang.PersistentArrayMap/create {:id "IHS_Dis_WebspherePlugin", :description "Discovers IBM Http Server's WebSphere plugin configuration by parsing the IHS plugin configuration file.", :display-name "IHS Plugins by Shell", :parameters (), :discovered-classes ("httpcontext" "ibmhttpserver" "ip_address" "node" "route" "composition" "ip_service_endpoint" "configuration_document" "containment"), :protocols ("sshprotocol" "telnetprotocol" "ntadminprotocol" "udaprotocol"), :input-cit "shell"}), "oracle_vm_manager_by_maincli" #=(clojure.lang.PersistentArrayMap/create {:id "oracle_vm_manager_by_maincli", :description "Make discovery of virtualization inventory using manager's main CLI accessible by SSH protocol", :display-name "Oracle VM Manager Discovery By MainCli", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportStoppedVMs", :type "string", :description "Perform discovery of stopped VMs"}) #=(clojure.lang.PersistentArrayMap/create {:name "commandExecutionDurationInMs", :type "Integer", :description "Time (ms) allocated for CLI commands execution. The value depends on the load factor of manager host. Default value is 2 seconds"})), :discovered-classes ("composition" "containment" "dependency" "execution_environment" "ip_address" "ip_service_endpoint" "node" "realization" "running_software" "usage" "virtualization_layer" "xen_domain_config" "server_pool" "interface"), :protocols ("sshprotocol"), :input-cit "oracle_vm_manager"}), "Import_DB" #=(clojure.lang.PersistentArrayMap/create {:id "Import_DB", :description " Imports data from an external database into CMDB using mapping of table columns to CIT attributes. Mapping is defined by the following parameters:   ciType: to define the CIT name which you want to create, mappingString: to define the mapping of the CIT attributes to the table columns   Mapping file is used for more complex mapping definitions. Mapping file name is specified by 'mappingFile' parameter.    A SQL 'select' query is generated automatically and selects all columns in specified table, which defined by parameter: tableName   In advanced cases you can specify custom SQL query.", :display-name "Import from DB", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ciType", :type "string", :description "Name of CI to import"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingFile", :type "string", :description "XML file containing the mapping from column to attribute"}) #=(clojure.lang.PersistentArrayMap/create {:name "mappingString", :type "string", :description "Mapping string. Format: column-name : attribute-name (e.g: A_IP_ADDRESS:ip_address, A_IP_DOMAIN:ip_domain)"}) #=(clojure.lang.PersistentArrayMap/create {:name "schemaName", :type "string", :description "Name of schema"}) #=(clojure.lang.PersistentArrayMap/create {:name "sqlQuery", :type "string", :description "SQL query, if specified, than mapping will be performed against its result. This parameter is ignored in case \"tableName\" parameter is set"}) #=(clojure.lang.PersistentArrayMap/create {:name "tableName", :type "string", :description "Table name, if specified, mapping will be performed against its columns."}) #=(clojure.lang.PersistentArrayMap/create {:name "flushObjects", :type "string", :description "Indicates if job will send objects by chunks."}) #=(clojure.lang.PersistentArrayMap/create {:name "bulkSize", :type "string", :description "Maximum number of CI in the chunk."})), :discovered-classes ("configuration_item"), :protocols ("sqlprotocol"), :input-cit "database"}), "VMware_VirtualCenter_Topology_by_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_VirtualCenter_Topology_by_VIM", :description "Adapter collects Virtual Infrastructure topology information using vCenter Server by VI Management protocol.", :display-name "VMware vCenter Topology by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBasicTopology", :description "Report basic virtualization topology", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVMs", :description "Whether we should report Virtual Machines that are powered-off:  - if the value is false, powered-off VMs will not be reported  - if the value is true, powered-off VMs will be reported unless there is a powered-on machine with the same host key (powered-on machine has priority)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("composition" "containment" "cpu" "dependency" "execution_environment" "file_system_export" "interface" "ip_address" "license_feature" "license_reservation" "license_server" "manage" "membership" "node" "usage" "vmware_cluster" "vmware_datacenter" "vmware_das_config" "vmware_dpm_config" "vmware_drs_config" "vmware_datastore" "vmware_distributed_switch" "vmware_esx_server" "vmware_host_resource" "vmware_networking_policy" "vmware_port_group" "vmware_resource_pool" "vmware_uplink" "vmware_virtual_switch" "vmware_virtual_center" "virtualization_layer"), :protocols ("vmwareprotocol"), :input-cit "vmware_virtual_center"}), "NSLOOKUP_on_DNS_Server" #=(clojure.lang.PersistentArrayMap/create {:id "NSLOOKUP_on_DNS_Server", :description "Discovers hosts by querying all available DNS servers", :display-name "NSLOOKUP on DNS Server", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DNSServerDomain", :type "string", :description "DNS Server Domain"}) #=(clojure.lang.PersistentArrayMap/create {:name "DNSServerName", :type "string", :description "DNS Server Name"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of probe range as well"})), :discovered-classes ("nt" "node" "ip_address" "netprinter" "unix" "containment"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "NTCMD_APP_Dis_IIS" #=(clojure.lang.PersistentArrayMap/create {:id "NTCMD_APP_Dis_IIS", :description "This adapter discovers Microsoft Internet Information Services (IIS).", :display-name "IIS by NTCMD or UDA", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "acceptedStatusCodes", :type "string", :description "Comma separated list of accepted HTTP status codes, indicating availability of discovered url."}) #=(clojure.lang.PersistentArrayMap/create {:name "adsutil_path", :type "string", :description "Path to the adsutil.vbs script"}) #=(clojure.lang.PersistentArrayMap/create {:name "checkConnectionToUrl", :type "string", :description "Should or not reported URLs be verified by HTTP(s)"}) #=(clojure.lang.PersistentArrayMap/create {:name "do_web_service", :type "string", :description "If true, the script will discover web-services"}) #=(clojure.lang.PersistentArrayMap/create {:name "web_service_file_extensions", :type "string", :description "List of file extensions which will detect as web services.Note: Wildcards is not supported"}) #=(clojure.lang.PersistentArrayMap/create {:name "report_legacy_topology", :type "string", :description "Whether to report the legacy IIS topology or new one."})), :discovered-classes ("iis_ftp_server" "deployed" "iis_smtp_server" "configuration_document" "containment" "dependency" "iis" "client_server" "node" "ip_address" "uri_endpoint" "webvirtualhost" "composition" "iisresource" "usage" "ip_service_endpoint"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "iis"}), "ms_exchange_topology_by_ntcmd" #=(clojure.lang.PersistentArrayMap/create {:id "ms_exchange_topology_by_ntcmd", :description "This adapter discovers Microsoft Exchange topology by NTCMD or UDA protocol. It is based on executing of PowerShell scenario on the remote machine.", :display-name "Microsoft Exchange Topology by NTCMD or UDA", :parameters (), :discovered-classes ("exchange_administrative_group" "composition" "exchangeclientaccessserver" "ms_exchange_clustered_mailbox" "ms_exchange_dag" "exchangeedgeserver" "exchangehubserver" "exchangemailserver" "exchangesystem" "exchangeunifiedmessagingserver" "membership" "ms_exchange_server" "node"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "ms_exchange_server"}), "vmware_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "vmware_check_credential", :description nil, :display-name "Check credential for VMware protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("vmwareprotocol"), :input-cit "discoveryprobegateway"}), "tcp_discovery_by_snmp" #=(clojure.lang.PersistentArrayMap/create {:id "tcp_discovery_by_snmp", :description "Discovers TCP information on particular host. Allows multiple discovery cycles to obtain temporary short-lived connections. Reports nothing to UCMDB but collected data used by other jobs to link other CIs to TCP data (like Host resources jobs).", :display-name "TCP Discovery by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "CaptureProcessInformation", :type "string", :description "Whether to capture processes information"}) #=(clojure.lang.PersistentArrayMap/create {:name "DelayBetweenTCPSnapshots", :type "string", :description "Pause in seconds between discovery cycles"}) #=(clojure.lang.PersistentArrayMap/create {:name "NumberOfTCPSnapshots", :type "string", :description "The count of discovery cycles on particular destination"})), :discovered-classes (), :protocols ("snmpprotocol"), :input-cit "snmp"}), "Layer2_Topology_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Layer2_Topology_by_Shell", :description "Reports Layer2 and networking related data by ssh or shell from network switches", :display-name "Layer2 Topology by Shell", :parameters (), :discovered-classes ("composition" "interface" "layer2_connection" "membership" "node" "physical_port" "realization" "switch"), :protocols ("sshprotocol" "telnetprotocol"), :input-cit "shell"}), "CF_Oracle" #=(clojure.lang.PersistentArrayMap/create {:id "CF_Oracle", :description "Discovers Oracle database configurations based on the v$parameter table", :display-name "Oracle Config Files", :parameters (), :discovered-classes ("composition" "oracle" "configuration_document"), :protocols ("sqlprotocol"), :input-cit "oracle"}), "Storage_Devices_Connection_by_CIM" #=(clojure.lang.PersistentArrayMap/create {:id "Storage_Devices_Connection_by_CIM", :description "This adapter is used for initial connection to CIM Agent", :display-name "Storage Devices Connection by CIM", :parameters (), :discovered-classes ("cim" "composition" "ip_address" "node" "containment"), :protocols ("cimprotocol"), :input-cit "ip_address"}), "SAP_Dis_ITS" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Dis_ITS", :description "Discover SAP Internet Transaction Server based on parsing configuration files.", :display-name "SAP Internet Transaction Server Discovery", :parameters (), :discovered-classes ("dependency" "sap_its_wgate" "node" "ip_address" "sap_its_agate" "sap_r3_server" "composition" "web_server" "containment"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "iis"}), "DNS_Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "DNS_Discovery", :description "Discover DNS names on IPs and hosts", :display-name "DNS Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "dnsServers", :description "Comma-separated value of DNS Servers to use upon Node Name lookup", :type "string"})), :discovered-classes ("node" "ip_address"), :protocols (), :input-cit "node"}), "sapjmx_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sapjmx_check_credential", :description nil, :display-name "Check credential for SAP JMX protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sapjmxprotocol"), :input-cit "discoveryprobegateway"}), "wmi_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "wmi_check_credential", :description nil, :display-name "Check credential for WMI protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("wmiprotocol"), :input-cit "discoveryprobegateway"}), "MigrateDDMItoUDAgentAdapter" #=(clojure.lang.PersistentArrayMap/create {:id "MigrateDDMItoUDAgentAdapter", :description "This adapter updates UD Agent.", :display-name "Migrate DDMI Agent to UD Agent", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "BandwidthLimit", :description "Bandwidth limit to be applied while uploading/downloading in kb/s", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Format ([] indicates an optional field):<ip address|host name>[:<80|1977>]", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Format ([] indicates an optional field):<ip address|host name>[:<80|1977>]", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"})), :discovered-classes ("composition" "node" "uda"), :protocols ("udaprotocol"), :input-cit "ip_address"}), "uda_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "uda_check_credential", :description nil, :display-name "Check credential for UDA protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("udaprotocol"), :input-cit "discoveryprobegateway"}), "Sap_Profile_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Sap_Profile_By_Shell", :description "Discover profile files for SAP Application Servers", :display-name "SAP Profiles by Shell", :parameters (), :discovered-classes ("composition" "usage" "configuration_document"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "sap_app_server"}), "Sap_System_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "Sap_System_By_Shell", :description "The job discovers SAP Systems using information from the configuration files", :display-name "SAP Systems by Shell", :parameters (), :discovered-classes ("membership" "sap_system" "composition" "usage" "sap_app_server" "configuration_document"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "sap_app_server"}), "TTY_HACMP_Applications" #=(clojure.lang.PersistentArrayMap/create {:id "TTY_HACMP_Applications", :description "Discovers IBM HACMP virtual applications ", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "cldisp_command", :type "string", :description "Actual command to use for cldisp. Can use full path or even root /path/cldisp"}) #=(clojure.lang.PersistentArrayMap/create {:name "cllsif_command", :type "string", :description "Actual command to use for cllsif -c. Can use full path or even root /path/cllsif -c. But do not leave off the -c."}) #=(clojure.lang.PersistentArrayMap/create {:name "vg_command", :type "string", :description "Actual command to use for gathering info about a volume group (lspv -p for AIX,  lvdisplay for Linux)"})), :discovered-classes ("membership" "execution_environment" "physicalvolume" "cluster_resource_group" "interface" "containment" "hacmpcluster" "dependency" "volumegroup" "node" "ip_address" "ownership" "running_software" "hacmpgroup" "composition" "usage" "cluster_software" "hacmpresource"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SQL_NET_Dis_Connection_Oracle" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_Connection_Oracle", :description "This adapter discovers databases using SQL protocol.", :display-name "Oracle Connection By SQL", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "protocolType", :type "string", :description "Used protocol type"})), :discovered-classes ("composition" "oracle" "containment" "ip_address" "ip_service_endpoint" "node" "usage"), :protocols ("sqlprotocol"), :input-cit "node"}), "InstallUDAgent" #=(clojure.lang.PersistentArrayMap/create {:id "InstallUDAgent", :description "This adapter installs UD Agent.", :display-name "Install UD Agent", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "UdAgentInstallCredentialId", :description "UD Agent credential id to be used to install UD Agent. Try all if empty.", :type "string", :display-type "UDACredential"}) #=(clojure.lang.PersistentArrayMap/create {:name "EnableSoftwareUtilization", :description "Should Software Utilization be enabled (true/false)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SoftwareUtilizationPeriod", :description "Software utilization data shows the number of days that an application was used (as a percentage) over a period of time. Default values 31/90/365", :type "integer"}) #=(clojure.lang.PersistentArrayMap/create {:name "PrimaryCallhomeProbeAddress", :description "Primary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "SecondaryCallhomeProbeAddress", :description "Secondary Callhome Probe Address. Use one of the following formats:1. IPAddress; 2. HostName; 3. HostNameOrIPv4Address:1977; 4. [IPv6Address]:1977. For example: 10.11.12.13, probehost, probehost:1977, [2010:836b:4179::836b:4179]:1977 ", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "CallhomeFrequency", :description "Specify frequency of CallHome request, days", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "RunUDAgentUnderRootAccount", :description "Install UD Agent to run under root account on Unix machines, otherwise use installing user account (true/false, default true).", :type "string"})), :discovered-classes ("composition" "uda" "node"), :protocols ("ntadminprotocol" "sshprotocol"), :input-cit "node"}), "SQL_NET_Dis_db2_Conn" #=(clojure.lang.PersistentArrayMap/create {:id "SQL_NET_Dis_db2_Conn", :description "DB2 database connection adapter.", :display-name nil, :parameters (), :discovered-classes ("composition" "db2"), :protocols ("sqlprotocol"), :input-cit "ip_address"}), "SAP_Dis_Site_AS" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Dis_Site_AS", :description "Discover SAP environment based on Computer Center Management System (CCMS).", :display-name "SAP ABAP Topology Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "reportComponentsAsConfigFile", :type "string", :description "When set to 'true' report software components as registry (configuration file). When set to 'false' - report separate CI per component. Default value is 'true'"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverRFCConnections", :type "string", :description "Get the RFC Connections of the sap system if true"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverSAPProfiles", :type "string", :description "Discovery SAP profiles by querying SAP database"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("sap_r3_server" "membership" "sap_system" "jdbcdatasource" "sap_gateway" "sap_work_process" "configuration_document" "sap_client" "containment" "database" "dependency" "node" "ip_address" "running_software" "composition" "usage" "sap_rfc_connection" "sap_software_component"), :protocols ("sapprotocol"), :input-cit "sap_r3_server"}), "NTCMD_HR_REG_Software" #=(clojure.lang.PersistentArrayMap/create {:id "NTCMD_HR_REG_Software", :description "Discover Installed software information on Windows machines using NTCMD or UDA protocol. In order for this adapter to work Windows XP's reg.exe file must be renamed to reg_mam.exe and be copied to 'probeManager\\discoveryResources' under probe install directory.", :display-name "Host Software by NTCMD or UDA", :parameters (), :discovered-classes ("composition" "installed_software"), :protocols ("ntadminprotocol"), :input-cit "shell"}), "SIEBEL_DIS_APP_SERVERS" #=(clojure.lang.PersistentArrayMap/create {:id "SIEBEL_DIS_APP_SERVERS", :description "Discover Siebel topology using srvrmgr client", :display-name "Siebel Application Servers by Siebel Gateway", :parameters (), :discovered-classes ("dependency" "ip_address" "siebel_comp_grp" "node" "membership" "composition" "siebel_component" "siebel_app_server" "configuration_document" "containment" "siebel_application"), :protocols ("siebelgtwyprotocol"), :input-cit "siebel_gateway"}), "uddiregistry_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "uddiregistry_check_credential", :description nil, :display-name "Check credential for UDDI Registry", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes (), :protocols ("uddiregistryprotocol"), :input-cit "discoveryprobegateway"}), "NTCMD_NET_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "NTCMD_NET_Dis_Connection", :description "Try to connect to a WIN server using HPCmd (NetBIOS) or UD Agent.", :display-name "Connection by NTCMD or UDA protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "codepage", :description "Discovered machine code page", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "language", :description "Discovered machine language", :type "string"})), :discovered-classes ("nt" "node" "ip_address" "running_software" "membership" "dns_server" "composition" "parent" "interface" "containment" "ip_subnet" "ntcmd"), :protocols ("ntadminprotocol" "udaprotocol"), :input-cit "ip_address"}), "iSeries Resources by EView" #=(clojure.lang.PersistentArrayMap/create {:id "iSeries Resources by EView", :description "This adapter discovers the IBM ISeries Resources on the on an Iseries box such as CPUs , Memory, Disks, Network Controllers, Installed Software.", :display-name "", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "commandTimeout", :description "Timeout value (in seconds) after which the command issued against the EView agent with timeout", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "debugMode", :description "Set to true to enable detailed logging in probe debug log", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_ASP", :description "Discover the the Auxillary Storage Pools and Disk Units", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_CPUs", :description "Whether to discover Iseries LPAR CPU CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Network", :description "Whether to discover ISeries Interface CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Software", :description "Whether to discover Iseries Installed Software CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_Subsystems", :description "Whether to discover Iseries Subsystem CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discover_TCP_UDP", :description "Whether to discover Iseries LPAR TCP ports and connectivity and UDP ports", :type "string"})), :discovered-classes ("client_server" "composition" "containment" "cpu" "dependency" "ibm_pseries_frame" "installed_software" "interface" "ip_address" "ip_service_endpoint" "ip_subnet" "logical_volume" "membership" "node" "parent" "storagepool" "as400_node" "iseriessubsystem"), :protocols (), :input-cit "eview"}), "TCP_Services" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_Services", :description "Discover key services on the network according to portNumberToPortName.xml configuration file. Brings data from Universal Discovery database", :display-name "TCP_Services", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ignoreUnackedTcpConn", :type "string", :description "TCP specific options"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "string", :description "Report connections from client IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "string", :description "Report connections from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "onlyHostDependLinks", :type "string", :description "Report only host dependancy"}) #=(clojure.lang.PersistentArrayMap/create {:name "services", :type "string", :description "Services to discover, can include number or known name and can be separated by comma(* for all known ports from configuration file)"}) #=(clojure.lang.PersistentArrayMap/create {:name "updateUtilizationInfo", :type "string", :description "Report accummulated packet and octets (bytes) count on links"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoredIps", :type "String", :description "Ips that should be filtered,comma separated (like 10.*.*.*,15.45.*.*). Default none (empty)."})), :discovered-classes ("dependency" "client_server" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "containment"), :protocols (), :input-cit "discoveryprobemanager"}), "ApacheTomcat_Topology" #=(clojure.lang.PersistentArrayMap/create {:id "ApacheTomcat_Topology", :description "Discovers Apache Tomcat Web servers", :display-name "Apache Tomcat Topology", :parameters (), :discovered-classes ("membership" "webapplication" "jdbcdatasource" "configuration_document" "containment" "database" "dependency" "node" "ip_address" "tomcatservice" "webvirtualhost" "tomcat" "composition" "usage" "tomcatcluster" "ip_service_endpoint"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "ARIS_To_UCMDB" #=(clojure.lang.PersistentArrayMap/create {:id "ARIS_To_UCMDB", :description "Populates CIs from IDS Scheer ARIS using an XML export file from ARIS", :display-name "Software AG ARIS", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "DebugMode", :description "If set to true, the integration will only create the result XML file and not push data", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARIS_XML_file", :description "The Full path with filename for the XML input file that will be used to import CIs", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "ARISLocaleId", :description "Locale ID that should be used if there are multiple locales in the ARIS XML file", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("business_application" "business_function" "business_service" "containment" "node" "organization" "ownership" "person"), :protocols (), :input-cit "discoveryprobegateway"}), "WebLogic_By_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "WebLogic_By_Shell", :description "Discovers WebLogic J2EE environment and components by shell. Supported versions: 8.1, 9.0, 9.1, 9.2, 10", :display-name "Weblogic J2EE Topology Discovery by Shell", :parameters (), :discovered-classes ("node" "ip_address" "j2eedomain" "jeenode" "ip_service_endpoint" "j2eecluster" "database" "configuration_document" "jdbcdatasource" "j2eemanagedobject" "containment" "database_instance" "composition" "dependency" "deployed" "membership" "usage" "webservice" "weblogicas"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "SNMP_NET_Dis_Router_Arp" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_Router_Arp", :description "This adapter discovers the ARP table of a router using the SNMP protocol. This discovery reveals IP addresses by querying the protocol that translates IPs into the Ethernet addresses used by local area networks, as well as the host and network it belongs to.", :display-name "Router ARP by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "backupSnmpMethod", :type "string", :description "Backup snmp method (walk, bulk, getnext)"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverUnknownIPs", :type "string", :description "Discover IPs which are out of scope range as well"}) #=(clojure.lang.PersistentArrayMap/create {:name "moonWalkBulkSize", :type "string", :description "Moon walk bulk size"}) #=(clojure.lang.PersistentArrayMap/create {:name "moonWalkSleep", :type "string", :description "Moon walk sleep time (Ms)"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpBulkSize", :type "string", :description "What is the size of the bulk in a bulk mode"}) #=(clojure.lang.PersistentArrayMap/create {:name "snmpMethod", :type "string", :description "Snmp method (walk, bulk, getnext)"})), :discovered-classes ("node" "ip_address" "membership" "composition" "parent" "interface" "containment" "ip_subnet"), :protocols (), :input-cit "snmp"}), "TCP_Potential_Services" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_Potential_Services", :description "The job tries to identify servers by network traffic data or number of clients. Brings data from Universal Discovery database.", :display-name "TCP Potential Services", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverDependLinks", :type "string", :description ""}) #=(clojure.lang.PersistentArrayMap/create {:name "disregardListenPorts", :type "string", :description "Should we disregard that port is listening and check minimal conditions instead"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoreLocalConnections", :type "string", :description "Should ignore local connections"}) #=(clojure.lang.PersistentArrayMap/create {:name "ignoredIps", :type "string", :description "Ips that should be filtered,comma separated (like 10.*.*.*,15.45.*.*). Default none (empty)."}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeClients", :type "string", :description "Report connections from client IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeServers", :type "string", :description "Report connections from server IPs found in flows but not in scope"}) #=(clojure.lang.PersistentArrayMap/create {:name "minClients", :type "string", :description "How many connected clients make this service a suspected server. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "minOctets", :type "string", :description "Only include clients that sent more than X octets (bytes) to a service. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "minPackets", :type "string", :description "Only include clients that sent more than X packets to a service. Relevant when disregardListenPorts is true"}) #=(clojure.lang.PersistentArrayMap/create {:name "protocols", :type "string", :description "Limit query to these IP protocols (delimited by commas)"})), :discovered-classes ("dependency" "client_server" "ip_address" "node" "composition" "usage" "ip_service_endpoint" "containment"), :protocols (), :input-cit "ip_address"}), "Mainframe_TCP_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Mainframe_TCP_by_SNMP", :description "This adapter discovers IBM mainframe.", :display-name "Mainframe TCP by SNMP", :parameters (), :discovered-classes ("process" "composition"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "SANscreen_Discovery" #=(clojure.lang.PersistentArrayMap/create {:id "SANscreen_Discovery", :description "This adapter discovers storage devices and SAN infrastructure from NetApp SANscreen/OnCommand", :display-name "NetApp SANScreen/OnCommand", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "ChunkSize", :description "Maximum number of items to pull (per query) from the SANscreen WebService API", :type "string"})), :discovered-classes ("composition" "containment" "cpu" "dependency" "fcconnect" "fchba" "fcport" "fcswitch" "ip_address" "logical_volume" "membership" "memory" "node" "storagearray" "storageprocessor" "unix" "nt"), :protocols ("sanscreenprotocol"), :input-cit "ip_service_endpoint"}), "WMI_NET_Dis_Connection" #=(clojure.lang.PersistentArrayMap/create {:id "WMI_NET_Dis_Connection", :description "This adapter discovers WMI agents by trying to connect to a Windows machine using the WMI protocol.", :display-name "Host Connection by WMI", :parameters (), :discovered-classes ("node" "ip_address" "wmi" "membership" "composition" "parent" "interface" "containment" "ip_subnet"), :protocols ("wmiprotocol"), :input-cit "ip_address"}), "HanaDb_by_Shell" #=(clojure.lang.PersistentArrayMap/create {:id "HanaDb_by_Shell", :description "Discover HanaDb instances", :display-name "HanaDb by shell", :parameters (), :discovered-classes ("composition" "ownership" "usage" "containment" "ip_service_endpoint" "dependency" "running_software" "ip_address" "node" "hana_database" "database_instance" "db_log_file" "dbdatafile" "db_trace_file" "dbuser" "configuration_document"), :protocols ("ntadminprotocol" "sshprotocol" "telnetprotocol"), :input-cit "hana_database"}), "hp_npar_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "hp_npar_by_shell", :description "This adapter discovers HP partitionable server (either cell-based or not) topology by connecting to the vPar or nPar", :display-name "HP nPartitions by Shell", :parameters (), :discovered-classes ("hp_vpar_config" "membership" "io_chassis" "scsi_adapter" "cpu" "physicalvolume" "interface_aggregation" "interface" "cell_board" "containment" "dependency" "volumegroup" "node" "fchba" "hp_complex" "hp_npar_config" "composition" "usage" "logical_volume" "file_system"), :protocols ("sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "shell"}), "ms_sharepoint_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "ms_sharepoint_by_shell", :description "adapter contains mechanism of MS SharePoint topology discovery", :display-name nil, :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverSharePointUrls", :type "string", :description "Parameter defines should or not be discovered URLs of SharePoint sites"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportIntermediateWebService", :type "string", :description "Should or not be reported IIS WebService between IIS Web Server and IIS Web Site. Should be set in accord to IIS Application by NTCMD job."}) #=(clojure.lang.PersistentArrayMap/create {:name "relativeCommandTimeoutMultiplier", :type "string", :description "How much time to wait the result against default command execution time"})), :discovered-classes ("nt" "membership" "sharepoint_service" "iiswebsite" "containment" "iiswebservice" "iis" "ip_address" "uri_endpoint" "client_server" "running_software" "iisapppool" "composition" "usage" "sqlserver" "sharepoint_farm"), :protocols ("ntadminprotocol" "powershellprotocol" "sshprotocol" "telnetprotocol" "udaprotocol"), :input-cit "agent"}), "Alteon_app_switch_by_SNMP" #=(clojure.lang.PersistentArrayMap/create {:id "Alteon_app_switch_by_SNMP", :description "Discovers Nortel Application Switches using the SNMP protocol", :display-name "Alteon application switch by SNMP", :parameters (), :discovered-classes ("ip_address" "node" "ownership" "membership" "loadbalancecluster" "composition" "alteon_app_switch" "ip_service_endpoint" "lb" "configuration_document" "containment"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "SNMP_NET_Dis_Catalyst_Vlans" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_NET_Dis_Catalyst_Vlans", :description "This adapter discovers VLANs on a switch by SNMP.", :display-name "Catalist Vlans by SNMP", :parameters (), :discovered-classes ("elan" "physical_port" "membership" "composition" "elanvlanmap" "vlan" "bcastdomain"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "ssl_certificate_by_https" #=(clojure.lang.PersistentArrayMap/create {:id "ssl_certificate_by_https", :description "Adapter Description", :display-name "SSL Certificate Discovery", :parameters (), :discovered-classes ("dependency" "digital_certificate" "running_software" "usage" "ip_service_endpoint"), :protocols (), :input-cit "ip_service_endpoint"}), "sql_oracle_check_credential" #=(clojure.lang.PersistentArrayMap/create {:id "sql_oracle_check_credential", :description nil, :display-name "Check credential for Oracle SQL protocol", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes (), :protocols ("sqlprotocol"), :input-cit "discoveryprobegateway"}), "DNS_Zone_by_DNS" #=(clojure.lang.PersistentArrayMap/create {:id "DNS_Zone_by_DNS", :description "Discovers the DNS Resource Record topology of DNS Zone by querying name server from local shell (Probe) via DNS protocol", :display-name "DNS Zone Topology", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "includeOutscopeIPs", :type "string", :description "If IP is out of probes range and parameter set to false IP is not reported. The default value is \"false\"."}) #=(clojure.lang.PersistentArrayMap/create {:name "reportBrokenAliases", :type "string", :description "If parameter set to true aliases which canonical resource does not exists will be reported"}) #=(clojure.lang.PersistentArrayMap/create {:name "zoneList", :type "string", :description "Comma separated list of zones is an obligatory attribute. It provides names of zones to transfer."})), :discovered-classes ("ip_address" "dnszone" "composition" "realization" "dns_record"), :protocols (), :input-cit "node"}), "SNMP_CDP_LLDP_neighbors" #=(clojure.lang.PersistentArrayMap/create {:id "SNMP_CDP_LLDP_neighbors", :description "This adapter discovers Layer 2 neighbors network devices", :display-name "CDP/LLDP neighbors layer 2 devices by SNMP", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "discoverCdpMib", :description "Perform layer 2 discovery from CDP mib", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "discoverLldpMib", :description "Perform layer 2 discovery from LLDP mib", :type "string"})), :discovered-classes ("layer2_connection" "node" "membership" "containment" "composition" "interface" "ip_address"), :protocols ("snmpprotocol"), :input-cit "snmp"}), "SAP_Sys_Dis" #=(clojure.lang.PersistentArrayMap/create {:id "SAP_Sys_Dis", :description "Discover SAP Systems based on SAP JCO.", :display-name "SAP ABAP Discovery", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMArgs", :type "string", :description "JVM parameters that should be passed to the remote process"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :type "string", :description "Should pattern run in separate thread"})), :discovered-classes ("node" "ip_address" "sap_r3_server" "membership" "sap_system" "composition" "containment"), :protocols ("sapprotocol"), :input-cit "ip_address"}), "XLS_Parser" #=(clojure.lang.PersistentArrayMap/create {:id "XLS_Parser", :description "Imports data from Excel Workbooks. Parses through multiple worksheet XLS files. Uses 'CIImports.xls' (default) file to import data.", :display-name "Import from Excel Workbook", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "file_name", :type "string", :description "The location of Excel (xls, xlsx) file. The script does NOT handle multiple files at once so enter the full path to single file."}) #=(clojure.lang.PersistentArrayMap/create {:name "integer_list_delimiter", :type "string", :description "The delimiter used to handle values in the spreadsheet that are to be treated as the uCMDB data type 'integer_list'"}) #=(clojure.lang.PersistentArrayMap/create {:name "relationship_attr_delimiter", :type "string", :description "On the relationship tab of source file object the link attributes could be added. The default is attribute_name|attribute_value. Should be aligned with actual data."}) #=(clojure.lang.PersistentArrayMap/create {:name "string_list_delimiter", :type "string", :description "The delimiter used to handle values in the spreadsheet which would be mapped as uCMDB data type 'string_list'"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("configuration_item" "managed_relationship"), :protocols (), :input-cit "discoveryprobemanager"}), "NetFlow_StartCollector" #=(clojure.lang.PersistentArrayMap/create {:id "NetFlow_StartCollector", :description "This adapter listens to NetFlow data broadcasts and writes the data to the Probe database, where the data is aggregated and made available for the following adapters:  Potential Services by TCP DB, Services Connections by TCP DB, and Services by TCP DB.", :display-name "Net Flow Start Collector", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "delayDurationInMinutes", :description "How long the listener should sleep(-1 means no delay)", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "listenDurationInMinutes", :type "string", :description "How long the listener should run and accept incoming NetFlow data (-1 means run until manually stopped)"}) #=(clojure.lang.PersistentArrayMap/create {:name "localAddress", :type "string", :description "IP address of Discover Probe"}) #=(clojure.lang.PersistentArrayMap/create {:name "listenPort", :type "integer", :description "Port the Discover probe listen on for NetFlow data"}) #=(clojure.lang.PersistentArrayMap/create {:name "authorizedRouters", :type "string", :description "List of IPs of authorized Netflow exporters(comma-separated, * for all)"})), :discovered-classes (), :protocols (), :input-cit "discoveryprobemanager"}), "red_hat_cluster_by_shell" #=(clojure.lang.PersistentArrayMap/create {:id "red_hat_cluster_by_shell", :description "Discover Red Hat Cluster Suite.", :display-name "Red Hat Cluster by Shell", :parameters (), :discovered-classes ("node" "membership" "red_hat_cluster" "composition" "cluster_software" "file_system" "clustered_file_system" "realization"), :protocols ("sshprotocol" "telnetprotocol"), :input-cit "shell"}), "VMware_VMotion_discovery_by_VIM" #=(clojure.lang.PersistentArrayMap/create {:id "VMware_VMotion_discovery_by_VIM", :description "adapter monitors migration events of Virtual Machines from one host to another.", :display-name "VMware VMotion by VIM", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "connectionRetryNumber", :type "string", :description "Maximum attempts to restore connection.  Zero as value means unlimited number of attempts."}) #=(clojure.lang.PersistentArrayMap/create {:name "eventBasedDiscoveryEnabled", :type "string", :description "At the beginning job checks history in range of past hours, then if this parameter is set to true waits for the new vmotion events."}) #=(clojure.lang.PersistentArrayMap/create {:name "historyHours", :type "string", :description "In scope of specified hours job will check for vmotion events when it starts"}) #=(clojure.lang.PersistentArrayMap/create {:name "remoteJVMClasspath", :description "External JVM classpath", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "runInSeparateProcess", :description "Whether to run the adapter in external JVM", :type "string"})), :discovered-classes ("vmware_port_group" "node" "ip_address" "virtualization_layer" "vmware_host_resource" "execution_environment" "composition" "usage" "vmware_virtual_switch" "interface" "containment"), :protocols ("vmwareprotocol"), :input-cit "vmware_virtual_center"}), "vCloud_Director_URL_by_vCloud_API" #=(clojure.lang.PersistentArrayMap/create {:id "vCloud_Director_URL_by_vCloud_API", :description "Adapter discovers VMware vCloud Director using direct connection URL by vCloud API", :display-name "vCloud Director URL by vCloud API", :parameters (#=(clojure.lang.PersistentArrayMap/create {:name "baseUrl", :description "Base URL to VMWare Cloud Director", :type "string"}) #=(clojure.lang.PersistentArrayMap/create {:name "reportPoweredOffVms", :description "Set this parameter to true to report powered off VMs", :type "string"})), :discovered-classes ("ip_address" "node" "interface" "vmware_vcloud" "vmware_vcloud_director" "vcloud_organization" "vcloud_vdc" "vcloud_vapp" "vcloud_vapp_template" "vcloud_media" "vcloud_catalog" "uri_endpoint" "usage" "manage" "composition" "containment" "aggregation"), :protocols ("vcloudprotocol"), :input-cit "discoveryprobegateway"}), "TCP_Webserver_Detection" #=(clojure.lang.PersistentArrayMap/create {:id "TCP_Webserver_Detection", :description "This adapter discovers web servers using TCP ports.", :display-name "TCP Web Server Detection", :parameters (), :discovered-classes ("iis" "node" "running_software" "containment" "ip_address" "composition" "usage" "ip_service_endpoint" "sunoneserver" "web_server"), :protocols (), :input-cit "ip_address"}), "Link DB Datafiles With Clustered FS" #=(clojure.lang.PersistentArrayMap/create {:id "Link DB Datafiles With Clustered FS", :description "This adapter is used for linking of database datafiles with clustered file system", :display-name "Link DB Datafiles With Clustered FileSystem", :parameters (), :discovered-classes ("dbdatafile" "file_system" "node" "usage"), :protocols (), :input-cit "dbdatafile"})}})